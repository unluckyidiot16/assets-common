<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Í∞ØÎ≤å Ï†ÑÌà¨ ÏãúÎÆ¨Î†àÏù¥ÌÑ∞</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500;700&display=swap" rel="stylesheet">
  <style>
    body {
      font-family: 'Noto Sans KR', sans-serif;
      background-color: #F0EAD6; /* Î™®ÎûòÏÇ¨Ïû• ÎäêÎÇåÏùò Î∞∞Í≤ΩÏÉâ */
    }
    .unit-card {
      transition: all 0.2s ease;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      cursor: pointer;
      -webkit-user-select: none; /* Safari */
      -ms-user-select: none; /* IE 10+ */
      user-select: none;
    }
    .unit-card:hover {
      transform: translateY(-4px);
      box-shadow: 0 4px 8px rgba(0,0,0,0.2);
    }
    .selected {
      outline: 3px solid #4A90E2;
      transform: translateY(-4px) scale(1.05);
      box-shadow: 0 6px 12px rgba(74,144,226,0.4);
    }
    .faint-animation {
      animation: faint 0.5s ease-out forwards;
    }
    @keyframes faint {
      from { opacity: 1; transform: scale(1); }
      to { opacity: 0; transform: scale(0.8); }
    }
    .attack-animation {
      animation: attack 0.4s ease-in-out;
    }
    @keyframes attack {
      0% { transform: translateX(0); }
      50% { transform: translateX(15px); }
      100% { transform: translateX(0); }
    }
    .enemy-attack-animation {
      animation: enemy-attack 0.4s ease-in-out;
    }
    @keyframes enemy-attack {
      0% { transform: translateX(0); }
      50% { transform: translateX(-15px); }
      100% { transform: translateX(0); }
    }
    .damage-text {
      animation: damage-show 0.5s ease-out forwards;
      position: absolute;
      bottom: 50%;
      left: 50%;
      transform: translateX(-50%);
      font-weight: bold;
      font-size: 1.5rem;
      color: #E53E3E; /* Red */
      text-shadow: 1px 1px #fff;
      pointer-events: none;
    }
    @keyframes damage-show {
      from { opacity: 1; transform: translate(-50%, 0); }
      to { opacity: 0; transform: translate(-50%, -30px); }
    }
    #life-counter {
      font-size: 1.5rem;
      letter-spacing: 0.1em;
    }
    .team-board {
      transition: background-color 0.5s ease-in-out;
    }
    .unit-card img {
      -webkit-user-drag: none; /* Safari */
      -khtml-user-drag: none; /* Konqueror */
      -moz-user-drag: none; /* Firefox */
      -o-user-drag: none; /* Opera */
      user-drag: none;
    }
  </style>
</head>
<body class="bg-[#F0EAD6] text-gray-800 p-4">

<div id="game-container" class="max-w-7xl mx-auto">
  <!-- ÏÉÅÎã® Ï†ïÎ≥¥ UI -->
  <div id="info-bar" class="flex justify-between items-center bg-[#A4C3B2] p-3 rounded-lg shadow-md mb-4 text-white">
    <div class="flex items-center space-x-6">
      <div><span class="font-bold">ÌÑ¥:</span> <span id="turn-counter">1</span></div>
      <div id="life-counter"></div>
    </div>
    <div class="text-2xl font-bold" id="environment-indicator"></div>
  </div>

  <!-- ÏÑ†ÌÉù Ï†ïÎ≥¥ -->
  <div id="selection-info" class="text-center mb-2 h-6 font-semibold text-blue-700"></div>

  <!-- ÏÉÅÎåÄ ÌåÄ (Ï†ÑÌà¨ ÏãúÏóêÎßå Î≥¥ÏûÑ) -->
  <div id="enemy-team-area" class="mb-4 min-h-[160px]">
    <h2 class="text-center text-xl font-bold text-gray-500 mb-2">ÏÉÅÎåÄ ÌåÄ</h2>
    <div id="enemy-team" class="team-board flex justify-center items-center space-x-2"></div>
  </div>

  <!-- Ï†ÑÌà¨ Î°úÍ∑∏ -->
  <div id="battle-log-container" class="h-24 bg-white/50 rounded-lg p-2 overflow-y-auto mb-4 border-2 border-gray-300 shadow-inner hidden">
    <div id="battle-log" class="text-sm"></div>
  </div>

  <!-- ÌîåÎ†àÏù¥Ïñ¥ ÌåÄ -->
  <div id="player-team-area" class="mb-2 min-h-[160px]">
    <h2 class="text-center text-xl font-bold text-gray-600 mb-2">ÎÇòÏùò ÌåÄ</h2>
    <div id="player-team" class="team-board flex justify-center items-start space-x-2 p-4 rounded-lg"></div>
  </div>

  <!-- ÌîåÎ†àÏù¥Ïñ¥ Î≤§Ïπò -->
  <div id="player-bench-area" class="mb-4 min-h-[160px]">
    <h2 class="text-center text-lg font-semibold text-gray-500 mb-2">Î≤§Ïπò</h2>
    <div id="player-bench" class="team-board flex justify-center items-start space-x-2 p-4 rounded-lg bg-black/5"></div>
  </div>

  <!-- ÏÉÅÏ†ê -->
  <div id="shop-area" class="bg-[#6B9080]/80 p-4 rounded-xl shadow-lg relative">
    <div class="flex justify-between items-center mb-4">
      <div class="flex space-x-2">
        <h2 class="text-2xl font-bold text-white">ÏÉÅÏ†ê</h2>
      </div>
      <div class="flex items-center space-x-2">
        <button id="roll-button" class="bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition-transform transform hover:scale-105">Î¶¨Î°§ (1G)</button>
        <button id="end-turn-button" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-6 rounded-lg shadow-md transition-transform transform hover:scale-105">ÌÑ¥ Ï¢ÖÎ£å</button>
      </div>
    </div>
    <div class="flex justify-center space-x-4">
      <div id="shop-units" class="flex justify-start items-center space-x-2"></div>
      <div id="shop-foods" class="flex justify-start items-center space-x-2"></div>
    </div>
    <div id="shop-gold-display" class="absolute bottom-4 right-6 text-white text-xl font-bold">
      <span id="gold-counter">10</span> G
    </div>
  </div>

  <!-- ÏäπÎ¶¨ Ìä∏Î°úÌîº Î∞î -->
  <div id="win-trophy-bar" class="mt-4 bg-[#A4C3B2] p-3 rounded-lg shadow-md flex justify-center items-center space-x-2 h-16"></div>
</div>

<!-- Í≤åÏûÑ Ïò§Î≤Ñ/ÏäπÎ¶¨ Î™®Îã¨ -->
<div id="modal" class="hidden fixed inset-0 bg-black bg-opacity-60 flex justify-center items-center z-50">
  <div class="bg-white p-8 rounded-2xl shadow-2xl text-center">
    <h2 id="modal-title" class="text-4xl font-bold mb-4"></h2>
    <p id="modal-text" class="text-lg mb-6"></p>
    <button id="restart-button" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-8 rounded-lg text-xl">Îã§Ïãú ÏãúÏûë</button>
  </div>
</div>

<script type="module">
  // --- Í≤åÏûÑ Îç∞Ïù¥ÌÑ∞ Ï†ïÏùò ---
  const ENVIRONMENTS = {
    HIGH_TIDE: { name: 'Î∞ÄÎ¨º', color: '#a2d2ff' },
    LOW_TIDE: { name: 'Ïç∞Î¨º', color: '#b08968' },
  };

  // NEW: Tier-based colors
  const TIER_COLORS = {
    1: 'bg-stone-100', 2: 'bg-green-100', 3: 'bg-blue-100',
    4: 'bg-purple-100', 5: 'bg-yellow-100', 6: 'bg-red-100',
    'T': 'bg-gray-200'
  };

  // NEW: Added power scores for AI balancing
  const UNIT_DATA = {
    bajirak: { name: 'Î∞îÏßÄÎùΩ', tier: 1, atk: 3, hp: 2, trigger: 'hurt', desc: 'ÌîºÍ≤©: ÏûêÏã† Í≥µÍ≤©Î†• +1.', score: 3, level2: { atk: 6, hp: 4, desc: 'ÌîºÍ≤©: ÏûêÏã† Í≥µÍ≤©Î†• +2.', score: 11 } },
    mudworm: { name: 'Í∞ØÏßÄÎ†ÅÏù¥', tier: 1, atk: 2, hp: 2, trigger: 'faint', desc: 'Ìá¥Ïû•: 1/1 Î≤åÎ†à ÏÜåÌôò.', score: 4, level2: { atk: 4, hp: 4, desc: 'Ìá¥Ïû•: 2/2 Î≤åÎ†à 2ÎßàÎ¶¨ ÏÜåÌôò.', score: 14 } },
    mudSnail: { name: 'Í∞ØÎ≤å Îã¨ÌåΩÏù¥', tier: 1, atk: 1, hp: 3, trigger: 'buy', desc: 'Íµ¨Îß§: Î¨¥ÏûëÏúÑ ÏïÑÍµ∞ Ï≤¥Î†• +1.', score: 3, level2: { atk: 2, hp: 6, desc: 'Íµ¨Îß§: Î¨¥ÏûëÏúÑ ÏïÑÍµ∞ Îëò Ï≤¥Î†• +1.', score: 11 } },
    smallCrab: { name: 'ÏûëÏùÄ Í≤å', tier: 1, atk: 3, hp: 2, trigger: 'startOfBattle', desc: 'ÏãúÏûë: Îí§ ÏπúÍµ¨ Í≥µÍ≤©Î†• +1.', score: 4, level2: { atk: 6, hp: 4, desc: 'ÏãúÏûë: Îí§ ÏπúÍµ¨ Í≥µÍ≤©Î†• +2.', score: 14 } },
    daehap: { name: 'ÎåÄÌï©', tier: 2, atk: 2, hp: 4, trigger: 'startOfBattle', desc: 'ÏãúÏûë: Îí§ ÏπúÍµ¨ +1/+1.', score: 6, level2: { atk: 4, hp: 8, desc: 'ÏãúÏûë: Îí§ ÏπúÍµ¨ +2/+2.', score: 21 } },
    ppulsora: { name: 'ÎøîÏÜåÎùº', tier: 2, atk: 3, hp: 3, trigger: 'startOfBattle', desc: 'ÏãúÏûë: Ï†ÑÏó¥Ïù¥Î©¥ ÌöåÌîº 1Ìöå.', score: 6, level2: { atk: 6, hp: 6, desc: 'ÏãúÏûë: Ï†ÑÏó¥Ïù¥Î©¥ ÌöåÌîº 2Ìöå.', score: 21 } },
    mangdungeo: { name: 'ÎßùÎë•Ïñ¥', tier: 2, atk: 3, hp: 3, trigger: 'startOfBattle', desc: 'ÏãúÏûë: Î¨¥ÏûëÏúÑ ÏïÑÍµ∞ Í≥µÍ≤©Î†• +1.', score: 5, level2: { atk: 6, hp: 6, desc: 'ÏãúÏûë: Î¨¥ÏûëÏúÑ ÏïÑÍµ∞ Îëò Í≥µÍ≤©Î†• +1.', score: 18 } },
    nongge: { name: 'ÎÜçÍ≤å', tier: 2, atk: 4, hp: 2, trigger: 'beforeAttack', desc: 'Í≥µÍ≤© Ï†Ñ: Ïïû Ï†ÅÏóêÍ≤å 1 ÌîºÌï¥.', score: 7, level2: { atk: 8, hp: 4, desc: 'Í≥µÍ≤© Ï†Ñ: Ïïû Ï†ÅÏóêÍ≤å 2 ÌîºÌï¥.', score: 25 } },
    honghap: { name: 'ÌôçÌï©', tier: 3, atk: 4, hp: 3, trigger: 'hurt', desc: 'ÌîºÍ≤©: Ïïû Ï†Å Í≥µÍ≤©Î†• -1.', score: 8, level2: { atk: 8, hp: 6, desc: 'ÌîºÍ≤©: Ïïû Ï†Å Í≥µÍ≤©Î†• -2.', score: 28 } },
    garibi: { name: 'Í∞ÄÎ¶¨ÎπÑ', tier: 3, atk: 5, hp: 3, trigger: 'faint', desc: 'Ìá¥Ïû•: 2/2 Í∞ÄÎ¶¨ÎπÑ 2ÎßàÎ¶¨ ÏÜåÌôò.', score: 10, level2: { atk: 10, hp: 6, desc: 'Ìá¥Ïû•: 4/4 Í∞ÄÎ¶¨ÎπÑ 2ÎßàÎ¶¨ ÏÜåÌôò.', score: 35 } },
    jjangddungeo: { name: 'Ïß±Îö±Ïñ¥', tier: 3, atk: 5, hp: 3, trigger: 'beforeAttack', desc: 'Í≥µÍ≤© Ï†Ñ: Ïïû Ï†ÅÏóêÍ≤å 2 ÌîºÌï¥.', score: 9, level2: { atk: 10, hp: 6, desc: 'Í≥µÍ≤© Ï†Ñ: Ïïû Ï†ÅÏóêÍ≤å 4 ÌîºÌï¥.', score: 32 } },
    chilmyeoncho: { name: 'Ïπ†Î©¥Ï¥à', tier: 3, atk: 3, hp: 5, trigger: 'startOfBattle', desc: 'ÏãúÏûë: Îí§ ÏπúÍµ¨ +1/+1.', score: 8, level2: { atk: 6, hp: 10, desc: 'ÏãúÏûë: Îí§ ÏπúÍµ¨ +2/+2.', score: 28 } },
    haehongnamul: { name: 'Ìï¥ÌôçÎÇòÎ¨º', tier: 4, atk: 2, hp: 8, trigger: 'startOfBattle', desc: 'ÏãúÏûë: Î™®Îì† ÏïÑÍµ∞ Ï≤¥Î†• +1.', score: 11, level2: { atk: 4, hp: 16, desc: 'ÏãúÏûë: Î™®Îì† ÏïÑÍµ∞ Ï≤¥Î†• +2.', score: 39 } },
    sora: { name: 'ÏÜåÎùº', tier: 4, atk: 6, hp: 3, trigger: 'startOfBattle', desc: 'ÏãúÏûë: Îí§ ÏπúÍµ¨ Í≥µÍ≤©Î†• +2.', score: 10, level2: { atk: 12, hp: 6, desc: 'ÏãúÏûë: Îí§ ÏπúÍµ¨ Í≥µÍ≤©Î†• +4.', score: 35 } },
    kkotge: { name: 'ÍΩÉÍ≤å', tier: 4, atk: 5, hp: 4, trigger: 'beforeAttack', desc: 'Í≥µÍ≤© Ï†Ñ: Ïïû ÎëòÏóêÍ≤å 1 ÌîºÌï¥.', score: 12, level2: { atk: 10, hp: 8, desc: 'Í≥µÍ≤© Ï†Ñ: Ïïû ÎëòÏóêÍ≤å 2 ÌîºÌï¥.', score: 42 } },
    chilge: { name: 'Ïπ†Í≤å', tier: 4, atk: 4, hp: 7, trigger: 'startOfBattle', desc: 'ÏãúÏûë: Î∞õÎäî ÌîºÌï¥ -2.', score: 11, level2: { atk: 8, hp: 14, desc: 'ÏãúÏûë: Î∞õÎäî ÌîºÌï¥ -4.', score: 39 } },
    nakji: { name: 'ÎÇôÏßÄ', tier: 5, atk: 6, hp: 3, trigger: 'startOfBattle', desc: 'ÏãúÏûë: ÌõÑÏó¥ Ïù¥Îèô. Ï≤´ ÌîºÍ≤© -2.', score: 13, level2: { atk: 12, hp: 6, desc: 'ÏãúÏûë: ÌõÑÏó¥ Ïù¥Îèô. Ï≤´ ÌîºÍ≤© -4.', score: 46 } },
    bigSnail: { name: 'ÌÅ∞ Îã¨ÌåΩÏù¥', tier: 5, atk: 4, hp: 9, trigger: 'startOfBattle', desc: 'ÏãúÏûë: Î™®Îì† ÏïÑÍµ∞ Î∞õÎäî ÌîºÌï¥ -1.', score: 14, level2: { atk: 8, hp: 18, desc: 'ÏãúÏûë: Î™®Îì† ÏïÑÍµ∞ Î∞õÎäî ÌîºÌï¥ -2.', score: 49 } },
    muneo: { name: 'Î¨∏Ïñ¥', tier: 5, atk: 6, hp: 5, trigger: 'beforeAttack', desc: 'Í≥µÍ≤© Ï†Ñ: Ïïû Ï†Å 1 ÌîºÌï¥, Îí§ ÏπúÍµ¨ Í≥µ+1.', score: 13, level2: { atk: 12, hp: 10, desc: 'Í≥µÍ≤© Ï†Ñ: Ïïû Ï†Å 2 ÌîºÌï¥, Îí§ ÏπúÍµ¨ Í≥µ+2.', score: 46 } },
    sungeo: { name: 'Ïà≠Ïñ¥', tier: 5, atk: 7, hp: 6, trigger: 'startOfBattle', desc: 'ÏãúÏûë: Î¨¥ÏûëÏúÑ ÏïÑÍµ∞ Í≥µ+2.', score: 13, level2: { atk: 14, hp: 12, desc: 'ÏãúÏûë: Î¨¥ÏûëÏúÑ ÏïÑÍµ∞ Îëò Í≥µ+2.', score: 46 } },
    doyosae: { name: 'ÎèÑÏöîÏÉà', tier: 6, atk: 8, hp: 8, trigger: 'startOfBattle', desc: 'ÏãúÏûë: Ïïû Ï†ÅÏóêÍ≤å 2 ÌîºÌï¥.', score: 16, level2: { atk: 16, hp: 16, desc: 'ÏãúÏûë: Ïïû Ï†ÅÏóêÍ≤å 4 ÌîºÌï¥.', score: 56 } },
    galmaegi: { name: 'Í∞àÎß§Í∏∞', tier: 6, atk: 8, hp: 8, trigger: 'startOfBattle', desc: 'ÏãúÏûë: Î™®Îì† ÏïÑÍµ∞ Í≥µ+1.', score: 17, level2: { atk: 16, hp: 16, desc: 'ÏãúÏûë: Î™®Îì† ÏïÑÍµ∞ Í≥µ+2.', score: 60 } },
    waegari: { name: 'ÏôúÍ∞ÄÎ¶¨', tier: 6, atk: 9, hp: 9, trigger: 'startOfBattle', desc: 'ÏãúÏûë: Îí§ ÏπúÍµ¨ +2/+2.', score: 17, level2: { atk: 18, hp: 18, desc: 'ÏãúÏûë: Îí§ ÏπúÍµ¨ +4/+4.', score: 60 } },
    daewangjogae: { name: 'ÎåÄÏôïÏ°∞Í∞ú', tier: 6, atk: 10, hp: 5, trigger: 'beforeAttack', desc: 'Í≥µÍ≤© Ï†Ñ: Í¥ÄÌÜµ 1 ÌîºÌï¥.', score: 16, level2: { atk: 20, hp: 10, desc: 'Í≥µÍ≤© Ï†Ñ: Í¥ÄÌÜµ 2 ÌîºÌï¥.', score: 56 } },
    smallWorm: { name: 'ÏûëÏùÄ Î≤åÎ†à', tier: 'T', atk: 1, hp: 1, isToken: true, desc: '' },
    level2Worm: { name: 'Î≤åÎ†à', tier: 'T', atk: 2, hp: 2, isToken: true, desc: '' },
    smallScallop: { name: 'ÏûëÏùÄ Í∞ÄÎ¶¨ÎπÑ', tier: 'T', atk: 2, hp: 2, isToken: true, desc: '' },
    level2Scallop: { name: 'Í∞ÄÎ¶¨ÎπÑ', tier: 'T', atk: 4, hp: 4, isToken: true, desc: '' },
  };

  const FOOD_DATA = {
    plankton: { name: 'ÌîåÎûëÌÅ¨ÌÜ§', cost: 3, desc: 'Ïú†ÎãõÏóêÍ≤å ÏòÅÍµ¨ +1/+1 Î∂ÄÏó¨.', effect: (unit) => { unit.atk += 1; unit.hp += 1; } },
    pincer: { name: 'ÏßëÍ≤å Í∞ïÌôî', cost: 3, desc: 'Ïú†ÎãõÏóêÍ≤å ÏòÅÍµ¨ Í≥µÍ≤©Î†• +2 Î∂ÄÏó¨.', effect: (unit) => { unit.atk += 2; } },
    shell: { name: 'ÍªçÏßà Í∞ïÌôî', cost: 3, desc: 'Ïú†ÎãõÏóêÍ≤å ÏòÅÍµ¨ Ï≤¥Î†• +2 Î∂ÄÏó¨.', effect: (unit) => { unit.hp += 2; } },
  };

  let gameState = {};

  function createUnitInstance(id, level = 1) {
    const data = UNIT_DATA[id];
    let unit = {
      id, ...data, instanceId: crypto.randomUUID(),
      atk: data.atk, hp: data.hp, level,
      battleAtk: 0, battleHp: 0,
      effects: { evade: 0, damageReduction: 0, firstHitTaken: false }
    };
    if (level === 2) {
      Object.assign(unit, data.level2);
    }
    return unit;
  }

  const $ = (selector) => document.querySelector(selector);

  function renderUnit(unit, index, teamType) {
    const isEmpty = !unit;
    const tierColor = unit ? TIER_COLORS[unit.tier] : '';
    const baseClasses = `unit-card w-32 h-36 rounded-lg p-2 flex flex-col justify-between items-center relative flex-shrink-0`;
    if (isEmpty) {
      return `<div class="${baseClasses} border-2 border-dashed border-gray-400/50" data-team="${teamType}" data-index="${index}"></div>`;
    }
    const selectedClass = gameState.selectedItem?.instanceId === unit.instanceId ? 'selected' : '';
    const costText = teamType === 'shop' ? `<div class="absolute -top-2 -left-2 bg-yellow-500 text-white rounded-full w-6 h-6 text-sm flex items-center justify-center z-10 font-bold shadow-md">3</div>` : '';
    const sellButton = (teamType === 'player' || teamType === 'bench') && gameState.phase === 'shop' ? `<button class="sell-button absolute -top-2 -right-2 bg-red-500 text-white rounded-full w-6 h-6 text-xs z-10 shadow-md" data-team="${teamType}" data-index="${index}">ÌåêÎß§</button>` : '';
    const imageURL = `https://unluckyidiot16.github.io/assets-common/MudAnimalAutoBattle/${unit.id}.png`;
    const stars = '‚òÖ'.repeat(unit.level);
    return `
        <div id="unit-${unit.instanceId}" class="${baseClasses} ${tierColor} ${selectedClass}" data-team="${teamType}" data-index="${index}" data-id="${unit.id}" data-instance-id="${unit.instanceId}">
            ${sellButton}${costText}
            <div class="text-xs font-bold text-center mt-2">${unit.name} <span class="text-yellow-400">${stars}</span></div>
            <img src="${imageURL}" alt="${unit.name}" class="my-1 w-20 h-20 object-contain" onerror="this.style.display='none'">
            <div class="text-center text-lg">
                <span class="text-red-500 font-bold">${unit.atk + unit.battleAtk}</span> / 
                <span class="text-blue-500 font-bold">${unit.hp + unit.battleHp}</span>
            </div>
            <div class="damage-text-container absolute inset-0"></div>
        </div>
    `;
  }

  function renderFood(food, index) {
    if (!food) return `<div class="w-24 h-24 border-2 border-dashed border-gray-400/50 rounded-lg"></div>`;
    const selectedClass = gameState.selectedItem?.type === 'food' && gameState.selectedItem.index === index ? 'selected' : '';
    return `
        <div class="unit-card w-24 h-24 bg-green-200/80 rounded-lg p-2 flex flex-col justify-center items-center text-center ${selectedClass}" data-type="food" data-index="${index}">
            <div class="text-sm font-bold">${food.name}</div>
            <div class="text-xs mt-1">${food.desc}</div>
            <div class="font-bold mt-1 text-yellow-600">${food.cost} G</div>
        </div>
     `;
  }

  function renderAll() {
    $('#turn-counter').textContent = gameState.turn;
    $('#life-counter').innerHTML = '‚ù§Ô∏è'.repeat(gameState.lives) + 'ü§ç'.repeat(4 - gameState.lives);
    $('#gold-counter').textContent = gameState.gold;
    const currentEnvData = ENVIRONMENTS[gameState.currentEnvironment];
    $('#environment-indicator').textContent = currentEnvData.name;
    $('#player-team').style.backgroundColor = currentEnvData.color;

    let selectionText = '';
    if (gameState.selectedItem) {
      const { data } = gameState.selectedItem;
      selectionText = `[${data.name}] ${data.desc}`;
    }
    $('#selection-info').textContent = selectionText;

    $('#player-team').innerHTML = gameState.playerTeam.map((u, i) => renderUnit(u, i, 'player')).join('');
    $('#player-bench').innerHTML = gameState.benchTeam.map((u, i) => renderUnit(u, i, 'bench')).join('');

    let enemyTeamHtml = '<div class="h-36"></div>';
    if (gameState.phase === 'battle') {
      $('#enemy-team').style.backgroundColor = currentEnvData.color;
      $('#enemy-team').classList.add('p-4', 'rounded-lg');
      enemyTeamHtml = gameState.enemyTeam.map((u, i) => renderUnit(u, i, 'enemy')).join('');
    } else {
      $('#enemy-team').style.backgroundColor = 'transparent';
      $('#enemy-team').classList.remove('p-4', 'rounded-lg');
    }
    $('#enemy-team').innerHTML = enemyTeamHtml;

    $('#shop-area').classList.toggle('hidden', gameState.phase !== 'shop');
    $('#enemy-team-area').classList.toggle('hidden', gameState.phase === 'shop');
    $('#battle-log-container').classList.toggle('hidden', gameState.phase === 'shop');
    if (gameState.phase === 'shop') {
      $('#shop-units').innerHTML = gameState.shop.units.map((u, i) => renderUnit(u, i, 'shop')).join('');
      $('#shop-foods').innerHTML = gameState.shop.foods.map((f, i) => renderFood(f, i)).join('');
    }

    const trophyBar = $('#win-trophy-bar');
    trophyBar.innerHTML = '';
    const filledTrophySVG = `<svg class="h-10 w-10 text-yellow-400" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M13 3.25A2.25 2.25 0 0 0 10.75 1H6.25A2.25 2.25 0 0 0 4 3.25V5.5h9.25v10.25h-3.5a.75.75 0 0 1 0-1.5h2v-1.5h-2a.75.75 0 0 1 0-1.5h2v-1.5h-2a.75.75 0 0 1 0-1.5h2V8h-2a.75.75 0 0 1 0-1.5h2.75A2.25 2.25 0 0 0 13 4.25V3.25Z M8.5 18.25a.75.75 0 0 0-1.5 0v1.5h-1.5a.75.75 0 0 0 0 1.5H7v1.5a.75.75 0 0 0 1.5 0V21h1.5a.75.75 0 0 0 0-1.5H8.5v-1.25Z M18 17a1 1 0 1 0 0 2 1 1 0 0 0 0-2Z"></path></svg>`;
    const emptyTrophySVG = `<svg class="h-10 w-10 text-white/40" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M13 3.25A2.25 2.25 0 0 0 10.75 1H6.25A2.25 2.25 0 0 0 4 3.25V5.5h9.25v10.25h-3.5a.75.75 0 0 1 0-1.5h2v-1.5h-2a.75.75 0 0 1 0-1.5h2v-1.5h-2a.75.75 0 0 1 0-1.5h2V8h-2a.75.75 0 0 1 0-1.5h2.75A2.25 2.25 0 0 0 13 4.25V3.25Z M8.5 18.25a.75.75 0 0 0-1.5 0v1.5h-1.5a.75.75 0 0 0 0 1.5H7v1.5a.75.75 0 0 0 1.5 0V21h1.5a.75.75 0 0 0 0-1.5H8.5v-1.25Z M18 17a1 1 0 1 0 0 2 1 1 0 0 0 0-2Z"></path></svg>`;
    for (let i = 0; i < 10; i++) trophyBar.innerHTML += (i < gameState.wins) ? filledTrophySVG : emptyTrophySVG;
    addClickListeners();
  }

  function getAvailableUnits(tier) { return Object.keys(UNIT_DATA).filter(id => !UNIT_DATA[id].isToken && UNIT_DATA[id].tier <= tier); }

  function populateShop() {
    const maxTier = Math.min(6, Math.floor((gameState.turn - 1) / 2) + 1);
    const availableUnits = getAvailableUnits(maxTier);
    gameState.shop.units = [];
    for(let i=0; i<3; i++) {
      if (availableUnits.length > 0) {
        const randomId = availableUnits[Math.floor(Math.random() * availableUnits.length)];
        gameState.shop.units.push(createUnitInstance(randomId));
      }
    }
    const availableFoods = Object.keys(FOOD_DATA);
    gameState.shop.foods = [];
    for(let i=0; i<2; i++) {
      const randomId = availableFoods[Math.floor(Math.random() * availableFoods.length)];
      gameState.shop.foods.push({id: randomId, ...FOOD_DATA[randomId]});
    }
  }

  function levelUp(unit) {
    Object.assign(unit, UNIT_DATA[unit.id].level2);
    unit.level = 2;
  }

  function checkForCombine(unitId) {
    if (!unitId) return;
    const allPlayerUnits = [...gameState.playerTeam, ...gameState.benchTeam];
    const unitsToCombine = [];
    allPlayerUnits.forEach((u, index) => {
      if (u && u.id === unitId && u.level === 1) {
        unitsToCombine.push({ unit: u, index, teamKey: index < 5 ? 'playerTeam' : 'benchTeam' });
      }
    });

    if (unitsToCombine.length >= 3) {
      const [unitToKeep, ...unitsToRemove] = unitsToCombine;
      levelUp(unitToKeep.unit);
      unitsToRemove.slice(0, 2).forEach(item => {
        gameState[item.teamKey][item.index % 5] = null;
      });
    }
  }

  function clearSelection() { gameState.selectedItem = null; renderAll(); }
  function sellUnit(team, index) {
    const teamKey = team === 'player' ? 'playerTeam' : 'benchTeam';
    const unit = gameState[teamKey][index];
    if (!unit) return;
    gameState.gold += unit.level;
    gameState[teamKey][index] = null;
    clearSelection();
  }
  function rollShop() { if (gameState.gold < 1) return; gameState.gold -= 1; populateShop(); renderAll(); }

  function startTurn() {
    gameState.turn++;
    gameState.gold = 10;
    gameState.phase = 'shop';
    const environments = Object.keys(ENVIRONMENTS);
    gameState.currentEnvironment = environments[Math.floor(Math.random() * environments.length)];
    populateShop();
    renderAll();
  }

  function initGame() {
    gameState = {
      turn: 1, wins: 0, lives: 4, gold: 10, phase: 'shop',
      playerTeam: Array(5).fill(null), benchTeam: Array(5).fill(null), enemyTeam: [],
      shop: { units: [], foods: [] },
      currentEnvironment: 'LOW_TIDE', selectedItem: null,
    };
    const environments = Object.keys(ENVIRONMENTS);
    gameState.currentEnvironment = environments[Math.floor(Math.random() * environments.length)];
    populateShop();
    renderAll();
  }

  // Battle logic...
  async function startBattle() {
    gameState.phase = 'battle';
    generateEnemyTeam();
    let playerBattleTeam = gameState.playerTeam.filter(u => u).map(u => JSON.parse(JSON.stringify(u)));
    playerBattleTeam.forEach(u => u.instanceId = crypto.randomUUID());
    let enemyBattleTeam = gameState.enemyTeam.filter(u => u).map(u => JSON.parse(JSON.stringify(u)));
    renderAll();
    await delay(100);
    renderBattleState(playerBattleTeam, enemyBattleTeam);
    const battleLog = $('#battle-log');
    battleLog.innerHTML = '';
    const log = (msg) => {
      const p = document.createElement('p');
      p.textContent = msg;
      battleLog.appendChild(p);
      battleLog.scrollTop = battleLog.scrollHeight;
    };

    log('--- Ï†ÑÌà¨ ÏãúÏûë ---');
    await delay(500);
    await resolveTriggers('startOfBattle', playerBattleTeam, playerBattleTeam, enemyBattleTeam, log);
    await resolveTriggers('startOfBattle', enemyBattleTeam, enemyBattleTeam, playerBattleTeam, log);
    renderBattleState(playerBattleTeam, enemyBattleTeam);
    await delay(1000);

    while (playerBattleTeam.length > 0 && enemyBattleTeam.length > 0) {
      const playerUnit = playerBattleTeam[0];
      const enemyUnit = enemyBattleTeam[0];
      if (!playerUnit || !enemyUnit) break;
      await delay(500);
      await resolveTriggers('beforeAttack', [playerUnit], playerBattleTeam, enemyBattleTeam, log);
      renderBattleState(playerBattleTeam, enemyBattleTeam);
      await resolveTriggers('beforeAttack', [enemyUnit], enemyBattleTeam, playerBattleTeam, log);
      renderBattleState(playerBattleTeam, enemyBattleTeam);
      await delay(500);
      playerBattleTeam = playerBattleTeam.filter(u => u && u.hp + u.battleHp > 0);
      enemyBattleTeam = enemyBattleTeam.filter(u => u && u.hp + u.battleHp > 0);
      if (playerBattleTeam.length === 0 || enemyBattleTeam.length === 0) break;

      $(`#unit-${playerUnit.instanceId}`)?.classList.add('attack-animation');
      $(`#unit-${enemyUnit.instanceId}`)?.classList.add('enemy-attack-animation');

      await applyDamage(enemyUnit, playerUnit.atk + playerUnit.battleAtk, enemyBattleTeam, playerBattleTeam, log, playerUnit);
      if (enemyBattleTeam.some(u => u && u.hp + u.battleHp > 0)) {
        await applyDamage(playerUnit, enemyUnit.atk + enemyUnit.battleAtk, playerBattleTeam, enemyBattleTeam, log, enemyUnit);
      }

      await delay(500);
      $(`#unit-${playerUnit.instanceId}`)?.classList.remove('attack-animation');
      $(`#unit-${enemyUnit.instanceId}`)?.classList.remove('enemy-attack-animation');
      playerBattleTeam = playerBattleTeam.filter(u => u && u.hp + u.battleHp > 0);
      enemyBattleTeam = enemyBattleTeam.filter(u => u && u.hp + u.battleHp > 0);
      renderBattleState(playerBattleTeam, enemyBattleTeam);
      await delay(500);
    }

    await delay(1000);
    if (playerBattleTeam.length > 0 && enemyBattleTeam.length === 0) {
      log('--- ÏäπÎ¶¨! ---');
      gameState.wins++;
    } else if (playerBattleTeam.length === 0 && enemyBattleTeam.length > 0) {
      log('--- Ìå®Î∞∞... ---');
      gameState.lives--;
    } else {
      log('--- Î¨¥ÏäπÎ∂Ä ---');
    }
    await delay(2000);
    if (gameState.wins >= 10) {
      showModal('ÏµúÏ¢Ö ÏäπÎ¶¨!', 'Í∞ØÎ≤åÏùò ÏßÄÎ∞∞ÏûêÍ∞Ä ÎêòÏÖ®ÏäµÎãàÎã§!');
    } else if (gameState.lives <= 0) {
      showModal('Í≤åÏûÑ Ïò§Î≤Ñ', `ÏµúÏ¢Ö ${gameState.wins}ÏäπÏùÑ Îã¨ÏÑ±ÌñàÏäµÎãàÎã§.`);
    } else {
      startTurn();
    }
  }
  function renderBattleState(playerTeam, enemyTeam) {
    $('#player-team').innerHTML = playerTeam.map((u, i) => renderUnit(u, i, 'player')).join('') + Array(5 - playerTeam.length).fill(renderUnit(null)).join('');
    $('#enemy-team').innerHTML = enemyTeam.map((u, i) => renderUnit(u, i, 'enemy')).join('') + Array(5 - enemyTeam.length).fill(renderUnit(null)).join('');
  }
  async function applyDamage(target, damage, targetTeam, attackerTeam, log, attacker) {
    if (!target || target.hp + target.battleHp <= 0) return;
    let finalDamage = damage;
    if (target.effects.evade > 0) {
      target.effects.evade--;
      log(`${target.name}Ïù¥(Í∞Ä) Í≥µÍ≤©ÏùÑ ÌöåÌîºÌñàÏäµÎãàÎã§!`);
      return;
    }
    if (target.id === 'nakji' && !target.effects.firstHitTaken) {
      finalDamage = Math.max(0, finalDamage - (target.level === 2 ? 4 : 2));
      target.effects.firstHitTaken = true;
    }
    finalDamage = Math.max(0, finalDamage - target.effects.damageReduction);
    const damageNumber = document.createElement('div');
    damageNumber.className = 'damage-text';
    damageNumber.textContent = `-${finalDamage}`;
    $(`#unit-${target.instanceId} .damage-text-container`)?.appendChild(damageNumber);
    target.hp -= finalDamage;
    log(`${attacker.name}Ïù¥(Í∞Ä) ${target.name}ÏóêÍ≤å ${finalDamage} ÌîºÌï¥. (ÎÇ®ÏùÄ Ï≤¥Î†•: ${Math.max(0, target.hp + target.battleHp)})`);
    if (target.hp + target.battleHp > 0) {
      await resolveTriggers('hurt', [target], targetTeam, attackerTeam, log);
    } else {
      $(`#unit-${target.instanceId}`)?.classList.add('faint-animation');
      log(`${target.name} Ìá¥Ïû•!`);
      await resolveTriggers('faint', [target], targetTeam, attackerTeam, log);
    }
  }
  async function dealDirectDamage(target, damage, log, source) {
    if(!target || target.hp + target.battleHp <= 0) return;
    const damageNumber = document.createElement('div');
    damageNumber.className = 'damage-text';
    damageNumber.textContent = `-${damage}`;
    $(`#unit-${target.instanceId} .damage-text-container`)?.appendChild(damageNumber);
    target.hp -= damage;
    log(`[${source.name}] Ìö®Í≥ºÎ°ú ${target.name}Ïù¥(Í∞Ä) ${damage}Ïùò ÌîºÌï¥Î•º ÏûÖÌòîÏäµÎãàÎã§.`);
  }
  // AI Generation Logic
  function calculateTeamScore(team) {
    return team.reduce((total, unit) => {
      if (!unit) return total;
      return total + (unit.level === 2 ? unit.level2.score : unit.score);
    }, 0);
  }
  function generateEnemyTeam() {
    const playerTeamScore = calculateTeamScore([...gameState.playerTeam, ...gameState.benchTeam]);
    const targetScore = playerTeamScore > 0 ? playerTeamScore * (Math.random() * 0.4 + 0.9) : gameState.turn * 5; // Base score for early turns
    const maxTier = Math.min(6, Math.floor((gameState.turn - 1) / 2) + 1);
    const availableUnits = getAvailableUnits(maxTier);

    let enemyTeam = [];
    let currentScore = 0;

    while(currentScore < targetScore && enemyTeam.length < 5 && availableUnits.length > 0) {
      const shouldTryLevel2 = Math.random() < 0.25 && gameState.turn > 3;
      let chosenUnit;

      if (shouldTryLevel2) {
        const randomId = availableUnits[Math.floor(Math.random() * availableUnits.length)];
        chosenUnit = createUnitInstance(randomId, 2);
      } else {
        const randomId = availableUnits[Math.floor(Math.random() * availableUnits.length)];
        chosenUnit = createUnitInstance(randomId, 1);
      }

      if (chosenUnit) {
        enemyTeam.push(chosenUnit);
        currentScore += (chosenUnit.level === 2 ? chosenUnit.level2.score : chosenUnit.score);
      }
    }
    gameState.enemyTeam = enemyTeam;
  }
  async function resolveTriggers(trigger, actors, actorTeam, enemyTeam, log) {
    for (const actor of actors) {
      if (!actor || (actor.hp + actor.battleHp <= 0 && trigger !== 'faint')) continue;
      if (actor.trigger === trigger) {
        const effect = UNIT_EFFECTS[actor.id];
        if (effect) await effect(actor, actorTeam, enemyTeam, log);
      }
    }
  }
  const UNIT_EFFECTS = {
    bajirak: (self, _1, _2, log) => { const buff = self.level === 2 ? 2 : 1; self.battleAtk += buff; log(`[${self.name}] Ìö®Í≥º: Í≥µÍ≤©Î†• +${buff}.`); },
    mudworm: (self, team, _, log) => {
      log(`[${self.name}] Ìö®Í≥º: Î≤åÎ†à ÏÜåÌôò!`);
      const index = team.findIndex(u => u && u.instanceId === self.instanceId);
      if (index === -1) return;
      const count = self.level === 2 ? 2 : 1;
      const summonId = self.level === 2 ? 'level2Worm' : 'smallWorm';
      for (let i = 0; i < count && team.filter(u=>u).length < 5; i++) { team.splice(index + 1 + i, 0, createUnitInstance(summonId)); }
    },
    mudSnail: () => {},
    smallCrab: (self, team, _, log) => {
      const i = team.findIndex(u => u && u.instanceId === self.instanceId);
      if (i > -1 && team[i+1]) { const buff = self.level === 2 ? 2 : 1; team[i+1].battleAtk += buff; log(`[${self.name}] Ìö®Í≥º: ${team[i+1].name} Í≥µÍ≤©Î†• +${buff}.`); }
    },
    daehap: (self, team, _, log) => {
      const i = team.findIndex(u => u && u.instanceId === self.instanceId);
      if (i > -1 && team[i+1]) { const buff = self.level === 2 ? 2 : 1; team[i+1].battleAtk += buff; team[i+1].battleHp += buff; log(`[${self.name}] Ìö®Í≥º: ${team[i+1].name} +${buff}/+${buff}.`); }
    },
    ppulsora: (self, team, _, log) => { if (team.findIndex(u=>u && u.instanceId===self.instanceId) === 0) { const amount = self.level === 2 ? 2:1; self.effects.evade = amount; log(`[${self.name}] Ìö®Í≥º: ÌöåÌîº ${amount}Ìöå ÌöçÎìù.`); } },
    mangdungeo: (self, team, _, log) => {
      const allies = team.filter(u => u && u.instanceId !== self.instanceId);
      if (allies.length > 0) {
        const count = self.level === 2 ? 2 : 1;
        for(let i=0; i<count; i++){ const target = allies[Math.floor(Math.random() * allies.length)]; target.battleAtk += 1; log(`[${self.name}] Ìö®Í≥º: ${target.name} Í≥µÍ≤©Î†• +1.`); }
      }
    },
    nongge: async (self, _, enemyTeam, log) => { const dmg = self.level === 2 ? 2:1; await dealDirectDamage(enemyTeam[0], dmg, log, self); },
    honghap: (self, _, enemyTeam, log) => {
      if (enemyTeam[0]) { const debuff = self.level === 2 ? 2 : 1; enemyTeam[0].battleAtk = Math.max(0, (enemyTeam[0].atk + enemyTeam[0].battleAtk) - debuff) - enemyTeam[0].atk; log(`[${self.name}] Ìö®Í≥º: ${enemyTeam[0].name} Í≥µÍ≤©Î†• -${debuff}.`); }
    },
    garibi: (self, team, _, log) => {
      log(`[${self.name}] Ìö®Í≥º: Í∞ÄÎ¶¨ÎπÑ ÏÜåÌôò!`);
      const index = team.findIndex(u => u && u.instanceId === self.instanceId);
      if (index === -1) return;
      const summonId = self.level === 2 ? 'level2Scallop' : 'smallScallop';
      for(let i = 0; i < 2 && team.filter(u=>u).length < 5; i++) { team.splice(index + 1 + i, 0, createUnitInstance(summonId)); }
    },
    jjangddungeo: async (self, _, enemyTeam, log) => { const dmg = self.level === 2 ? 4 : 2; await dealDirectDamage(enemyTeam[0], dmg, log, self); },
    chilmyeoncho: (self, team, _, log) => { UNIT_EFFECTS.daehap(self, team, _, log); },
    haehongnamul: (self, team, _, log) => { const buff = self.level === 2 ? 2 : 1; team.forEach(u => u && (u.battleHp += buff)); log(`[${self.name}] Ìö®Í≥º: Î™®Îì† ÏïÑÍµ∞ Ï≤¥Î†• +${buff}.`); },
    sora: (self, team, _, log) => {
      const i = team.findIndex(u => u && u.instanceId === self.instanceId);
      if (i > -1 && team[i+1]) { const buff = self.level === 2 ? 4 : 2; team[i+1].battleAtk += buff; log(`[${self.name}] Ìö®Í≥º: ${team[i+1].name} Í≥µÍ≤©Î†• +${buff}.`); }
    },
    kkotge: async (self, _, enemyTeam, log) => { const dmg = self.level === 2 ? 2 : 1; await dealDirectDamage(enemyTeam[0], dmg, log, self); await dealDirectDamage(enemyTeam[1], dmg, log, self); },
    chilge: (self, _, _2, log) => { const reduc = self.level === 2 ? 4 : 2; self.effects.damageReduction = reduc; log(`[${self.name}] Ìö®Í≥º: Î∞õÎäî ÌîºÌï¥ -${reduc}.`); },
    nakji: (self, team, _, log) => {
      const i = team.findIndex(u => u && u.instanceId === self.instanceId);
      if (i !== -1 && i < team.filter(u=>u).length - 1) { const [unit] = team.splice(i, 1); team.push(unit); log(`[${self.name}] Ìö®Í≥º: ÌõÑÏó¥Î°ú Ïù¥Îèô.`); }
    },
    bigSnail: (self, team, _, log) => { const reduc = self.level === 2 ? 2 : 1; team.forEach(u => u && (u.effects.damageReduction += reduc)); log(`[${self.name}] Ìö®Í≥º: Î™®Îì† ÏïÑÍµ∞ Î∞õÎäî ÌîºÌï¥ -${reduc}.`); },
    muneo: async (self, team, enemyTeam, log) => {
      const dmg = self.level === 2 ? 2 : 1; const buff = self.level === 2 ? 2 : 1;
      await dealDirectDamage(enemyTeam[0], dmg, log, self);
      const i = team.findIndex(u => u && u.instanceId === self.instanceId);
      if (i > -1 && team[i+1]) { team[i+1].battleAtk += buff; log(`[${self.name}] Ìö®Í≥º: ${team[i+1].name} Í≥µÍ≤©Î†• +${buff}.`); }
    },
    sungeo: (self, team, _, log) => {
      const allies = team.filter(u => u && u.instanceId !== self.instanceId);
      if (allies.length > 0) {
        const count = self.level === 2 ? 2 : 1;
        for(let i=0; i<count; i++){ const target = allies[Math.floor(Math.random() * allies.length)]; target.battleAtk += 2; log(`[${self.name}] Ìö®Í≥º: ${target.name} Í≥µÍ≤©Î†• +2.`); }
      }
    },
    doyosae: async (self, _, enemyTeam, log) => { const dmg = self.level === 2 ? 4 : 2; await dealDirectDamage(enemyTeam[0], dmg, log, self); },
    galmaegi: (self, team, _, log) => { const buff = self.level === 2 ? 2 : 1; team.forEach(u => u && u.instanceId !== self.instanceId && (u.battleAtk += buff)); log(`[${self.name}] Ìö®Í≥º: Îã§Î•∏ Î™®Îì† ÏïÑÍµ∞ Í≥µÍ≤©Î†• +${buff}.`); },
    waegari: (self, team, _, log) => {
      const i = team.findIndex(u => u && u.instanceId === self.instanceId);
      if (i > -1 && team[i+1]) { const buff = self.level === 2 ? 4 : 2; team[i+1].battleAtk += buff; team[i+1].battleHp += buff; log(`[${self.name}] Ìö®Í≥º: ${team[i+1].name} +${buff}/+${buff}.`); }
    },
    daewangjogae: async (self, _, enemyTeam, log) => { const dmg = self.level === 2 ? 2 : 1; await dealDirectDamage(enemyTeam[0], dmg, log, self); await dealDirectDamage(enemyTeam[1], dmg, log, self); },
  };

  function delay(ms) { return new Promise(res => setTimeout(res, ms)); }
  function showModal(title, text) { $('#modal-title').textContent = title; $('#modal-text').textContent = text; $('#modal').classList.remove('hidden'); }

  function addClickListeners() {
    document.querySelectorAll('.unit-card').forEach(card => card.addEventListener('click', e => { e.stopPropagation(); handleCardClick(card.dataset); }));
    document.querySelectorAll('.sell-button').forEach(button => button.addEventListener('click', e => { e.stopPropagation(); sellUnit(button.dataset.team, parseInt(button.dataset.index)); }));
  }

  function handleCardClick(dataset) {
    const { team, type, index } = dataset;
    const isPlayerArea = team === 'player' || team === 'bench';
    const selected = gameState.selectedItem;

    if (!selected) {
      if (team === 'shop' || type === 'food') {
        const itemIndex = parseInt(index);
        const itemData = type === 'food' ? gameState.shop.foods[itemIndex] : gameState.shop.units[itemIndex];
        if (itemData) gameState.selectedItem = { type: type || 'unit', index: itemIndex, data: itemData };
      } else if (isPlayerArea) {
        const teamKey = team === 'player' ? 'playerTeam' : 'benchTeam';
        const unit = gameState[teamKey][index];
        if (unit) gameState.selectedItem = { type: 'playerUnit', team, index: parseInt(index), instanceId: unit.instanceId, data: unit };
      }
    } else {
      if (selected.type === 'unit') {
        if (isPlayerArea && gameState.gold >= 3) {
          const teamKey = team === 'player' ? 'playerTeam' : 'benchTeam';
          if (!gameState[teamKey][index]) {
            gameState.gold -= 3;
            const boughtUnit = createUnitInstance(selected.data.id);
            gameState[teamKey][index] = boughtUnit;
            gameState.shop.units[selected.index] = null;
            if (boughtUnit.trigger === 'buy') handleBuyTrigger(boughtUnit);
            checkForCombine(boughtUnit.id);
            clearSelection();
          }
        }
      } else if (selected.type === 'food') {
        if (isPlayerArea) {
          const teamKey = team === 'player' ? 'playerTeam' : 'benchTeam';
          const targetUnit = gameState[teamKey][index];
          if (targetUnit && gameState.gold >= selected.data.cost) {
            gameState.gold -= selected.data.cost;
            selected.data.effect(targetUnit);
            gameState.shop.foods[selected.index] = null;
            clearSelection();
          }
        }
      } else if (selected.type === 'playerUnit') {
        if (isPlayerArea) {
          const sourceTeamKey = selected.team === 'player' ? 'playerTeam' : 'benchTeam';
          const targetTeamKey = team === 'player' ? 'playerTeam' : 'benchTeam';
          [gameState[sourceTeamKey][selected.index], gameState[targetTeamKey][index]] = [gameState[targetTeamKey][index], gameState[sourceTeamKey][selected.index]];
          clearSelection();
        }
      }
    }
    renderAll();
  }

  function handleBuyTrigger(boughtUnit) {
    if (boughtUnit.id === 'mudSnail') {
      const allAllies = [...gameState.playerTeam, ...gameState.benchTeam].filter(u => u);
      if (allAllies.length > 0) {
        const count = boughtUnit.level === 2 ? 2 : 1;
        for(let i=0; i<count; i++){
          const target = allAllies[Math.floor(Math.random() * allAllies.length)];
          target.hp++;
        }
      }
    }
  }

  $('#roll-button').addEventListener('click', rollShop);
  $('#end-turn-button').addEventListener('click', startBattle);
  $('#restart-button').addEventListener('click', () => { $('#modal').classList.add('hidden'); initGame(); });
  document.body.addEventListener('click', (e) => {
    if (e.target.closest('.unit-card, button')) return;
    clearSelection();
  });

  initGame();
</script>

</body>
</html>

