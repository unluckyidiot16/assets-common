<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>갯벌 전투 시뮬레이터</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500;700&display=swap" rel="stylesheet">
  <style>
    body {
      font-family: 'Noto Sans KR', sans-serif;
      background-color: #F0EAD6; /* 모래사장 느낌의 배경색 */
    }
    .unit-card {
      transition: all 0.2s ease;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      cursor: pointer;
      -webkit-user-select: none; /* Safari */
      -ms-user-select: none; /* IE 10+ */
      user-select: none;
    }
    .unit-card:hover {
      transform: translateY(-4px);
      box-shadow: 0 4px 8px rgba(0,0,0,0.2);
    }
    .selected {
      outline: 3px solid #4A90E2;
      transform: translateY(-4px) scale(1.05);
      box-shadow: 0 6px 12px rgba(74,144,226,0.4);
    }
    .faint-animation {
      animation: faint 0.5s ease-out forwards;
    }
    @keyframes faint {
      from { opacity: 1; transform: scale(1); }
      to { opacity: 0; transform: scale(0.8); }
    }
    .attack-animation {
      animation: attack 0.4s ease-in-out;
    }
    @keyframes attack {
      0% { transform: translateX(0); }
      50% { transform: translateX(15px); }
      100% { transform: translateX(0); }
    }
    .enemy-attack-animation {
      animation: enemy-attack 0.4s ease-in-out;
    }
    @keyframes enemy-attack {
      0% { transform: translateX(0); }
      50% { transform: translateX(-15px); }
      100% { transform: translateX(0); }
    }
    .damage-text {
      animation: damage-show 0.5s ease-out forwards;
      position: absolute;
      bottom: 50%;
      left: 50%;
      transform: translateX(-50%);
      font-weight: bold;
      font-size: 1.5rem;
      color: #E53E3E; /* Red */
      text-shadow: 1px 1px #fff;
      pointer-events: none;
    }
    @keyframes damage-show {
      from { opacity: 1; transform: translate(-50%, 0); }
      to { opacity: 0; transform: translate(-50%, -30px); }
    }
    #life-counter {
      font-size: 1.5rem;
      letter-spacing: 0.1em;
    }
    .team-board {
      transition: background-color 0.5s ease-in-out;
    }
    .unit-card img {
      -webkit-user-drag: none; /* Safari */
      -khtml-user-drag: none; /* Konqueror */
      -moz-user-drag: none; /* Firefox */
      -o-user-drag: none; /* Opera */
      user-drag: none;
    }
  </style>
</head>
<body class="bg-[#F0EAD6] text-gray-800 p-4">

<div id="game-container" class="max-w-7xl mx-auto">
  <!-- 상단 정보 UI -->
  <div id="info-bar" class="flex justify-between items-center bg-[#A4C3B2] p-3 rounded-lg shadow-md mb-4 text-white">
    <div class="flex items-center space-x-6">
      <div><span class="font-bold">턴:</span> <span id="turn-counter">1</span></div>
      <div id="life-counter"></div>
    </div>
    <div class="text-2xl font-bold" id="environment-indicator"></div>
    <div><span class="font-bold">골드:</span> <span id="gold-counter">10</span> 💰</div>
  </div>

  <!-- 선택 정보 -->
  <div id="selection-info" class="text-center mb-2 h-6 font-semibold text-blue-700"></div>

  <!-- 상대 팀 (전투 시에만 보임) -->
  <div id="enemy-team-area" class="mb-4 min-h-[160px]">
    <h2 class="text-center text-xl font-bold text-gray-500 mb-2">상대 팀</h2>
    <div id="enemy-team" class="team-board flex justify-center items-center space-x-2"></div>
  </div>

  <!-- 전투 로그 -->
  <div id="battle-log-container" class="h-24 bg-white/50 rounded-lg p-2 overflow-y-auto mb-4 border-2 border-gray-300 shadow-inner hidden">
    <div id="battle-log" class="text-sm"></div>
  </div>

  <!-- 플레이어 팀 -->
  <div id="player-team-area" class="mb-2 min-h-[160px]">
    <h2 class="text-center text-xl font-bold text-gray-600 mb-2">나의 팀</h2>
    <div id="player-team" class="team-board flex justify-center items-start space-x-2 p-4 rounded-lg"></div>
  </div>

  <!-- 플레이어 벤치 -->
  <div id="player-bench-area" class="mb-4 min-h-[160px]">
    <h2 class="text-center text-lg font-semibold text-gray-500 mb-2">벤치</h2>
    <div id="player-bench" class="team-board flex justify-center items-start space-x-2 p-4 rounded-lg bg-black/5"></div>
  </div>

  <!-- 상점 -->
  <div id="shop-area" class="bg-[#6B9080]/80 p-4 rounded-xl shadow-lg">
    <div class="flex justify-between items-center mb-4">
      <div class="flex space-x-2">
        <h2 class="text-2xl font-bold text-white">상점</h2>
      </div>
      <div class="flex items-center space-x-2">
        <button id="roll-button" class="bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition-transform transform hover:scale-105">리롤 (1 골드)</button>
        <button id="end-turn-button" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-6 rounded-lg shadow-md transition-transform transform hover:scale-105">턴 종료</button>
      </div>
    </div>
    <div class="flex justify-center space-x-4">
      <div id="shop-units" class="flex justify-start items-center space-x-2"></div>
      <div id="shop-foods" class="flex justify-start items-center space-x-2"></div>
    </div>
  </div>

  <!-- 승리 트로피 바 -->
  <div id="win-trophy-bar" class="mt-4 bg-[#A4C3B2] p-3 rounded-lg shadow-md flex justify-center items-center space-x-2 h-16"></div>
</div>

<!-- 게임 오버/승리 모달 -->
<div id="modal" class="hidden fixed inset-0 bg-black bg-opacity-60 flex justify-center items-center z-50">
  <div class="bg-white p-8 rounded-2xl shadow-2xl text-center">
    <h2 id="modal-title" class="text-4xl font-bold mb-4"></h2>
    <p id="modal-text" class="text-lg mb-6"></p>
    <button id="restart-button" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-8 rounded-lg text-xl">다시 시작</button>
  </div>
</div>

<script type="module">
  // --- 게임 데이터 정의 ---
  const ENVIRONMENTS = {
    HIGH_TIDE: { name: '밀물', color: '#a2d2ff' },
    LOW_TIDE: { name: '썰물', color: '#b08968' },
  };

  const UNIT_DATA = {
    bajirak: { name: '바지락', tier: 1, atk: 3, hp: 2, trigger: 'hurt', desc: '피격: 자신 공격력 +1.', level2: { atk: 6, hp: 4, desc: '피격: 자신 공격력 +2.' } },
    mudworm: { name: '갯지렁이', tier: 1, atk: 2, hp: 2, trigger: 'faint', desc: '퇴장: 1/1 벌레 소환.', level2: { atk: 4, hp: 4, desc: '퇴장: 2/2 벌레 2마리 소환.' } },
    mudSnail: { name: '갯벌 달팽이', tier: 1, atk: 1, hp: 3, trigger: 'buy', desc: '구매: 무작위 아군 체력 +1.', level2: { atk: 2, hp: 6, desc: '구매: 무작위 아군 둘 체력 +1.' } },
    smallCrab: { name: '작은 게', tier: 1, atk: 3, hp: 2, trigger: 'startOfBattle', desc: '시작: 뒤 친구 공격력 +1.', level2: { atk: 6, hp: 4, desc: '시작: 뒤 친구 공격력 +2.' } },
    daehap: { name: '대합', tier: 2, atk: 2, hp: 4, trigger: 'startOfBattle', desc: '시작: 뒤 친구 +1/+1.', level2: { atk: 4, hp: 8, desc: '시작: 뒤 친구 +2/+2.' } },
    ppulsora: { name: '뿔소라', tier: 2, atk: 3, hp: 3, trigger: 'startOfBattle', desc: '시작: 전열이면 회피 1회.', level2: { atk: 6, hp: 6, desc: '시작: 전열이면 회피 2회.' } },
    mangdungeo: { name: '망둥어', tier: 2, atk: 3, hp: 3, trigger: 'startOfBattle', desc: '시작: 무작위 아군 공격력 +1.', level2: { atk: 6, hp: 6, desc: '시작: 무작위 아군 둘 공격력 +1.' } },
    nongge: { name: '농게', tier: 2, atk: 4, hp: 2, trigger: 'beforeAttack', desc: '공격 전: 앞 적에게 1 피해.', level2: { atk: 8, hp: 4, desc: '공격 전: 앞 적에게 2 피해.' } },
    honghap: { name: '홍합', tier: 3, atk: 4, hp: 3, trigger: 'hurt', desc: '피격: 앞 적 공격력 -1.', level2: { atk: 8, hp: 6, desc: '피격: 앞 적 공격력 -2.' } },
    garibi: { name: '가리비', tier: 3, atk: 5, hp: 3, trigger: 'faint', desc: '퇴장: 2/2 가리비 2마리 소환.', level2: { atk: 10, hp: 6, desc: '퇴장: 4/4 가리비 2마리 소환.' } },
    jjangddungeo: { name: '짱뚱어', tier: 3, atk: 5, hp: 3, trigger: 'beforeAttack', desc: '공격 전: 앞 적에게 2 피해.', level2: { atk: 10, hp: 6, desc: '공격 전: 앞 적에게 4 피해.' } },
    chilmyeoncho: { name: '칠면초', tier: 3, atk: 3, hp: 5, trigger: 'startOfBattle', desc: '시작: 뒤 친구 +1/+1.', level2: { atk: 6, hp: 10, desc: '시작: 뒤 친구 +2/+2.' } },
    haehongnamul: { name: '해홍나물', tier: 4, atk: 2, hp: 8, trigger: 'startOfBattle', desc: '시작: 모든 아군 체력 +1.', level2: { atk: 4, hp: 16, desc: '시작: 모든 아군 체력 +2.' } },
    sora: { name: '소라', tier: 4, atk: 6, hp: 3, trigger: 'startOfBattle', desc: '시작: 뒤 친구 공격력 +2.', level2: { atk: 12, hp: 6, desc: '시작: 뒤 친구 공격력 +4.' } },
    kkotge: { name: '꽃게', tier: 4, atk: 5, hp: 4, trigger: 'beforeAttack', desc: '공격 전: 앞 둘에게 1 피해.', level2: { atk: 10, hp: 8, desc: '공격 전: 앞 둘에게 2 피해.' } },
    chilge: { name: '칠게', tier: 4, atk: 4, hp: 7, trigger: 'startOfBattle', desc: '시작: 받는 피해 -2.', level2: { atk: 8, hp: 14, desc: '시작: 받는 피해 -4.' } },
    nakji: { name: '낙지', tier: 5, atk: 6, hp: 3, trigger: 'startOfBattle', desc: '시작: 후열 이동. 첫 피격 -2.', level2: { atk: 12, hp: 6, desc: '시작: 후열 이동. 첫 피격 -4.' } },
    bigSnail: { name: '큰 달팽이', tier: 5, atk: 4, hp: 9, trigger: 'startOfBattle', desc: '시작: 모든 아군 받는 피해 -1.', level2: { atk: 8, hp: 18, desc: '시작: 모든 아군 받는 피해 -2.' } },
    muneo: { name: '문어', tier: 5, atk: 6, hp: 5, trigger: 'beforeAttack', desc: '공격 전: 앞 적 1 피해, 뒤 친구 공+1.', level2: { atk: 12, hp: 10, desc: '공격 전: 앞 적 2 피해, 뒤 친구 공+2.' } },
    sungeo: { name: '숭어', tier: 5, atk: 7, hp: 6, trigger: 'startOfBattle', desc: '시작: 무작위 아군 공+2.', level2: { atk: 14, hp: 12, desc: '시작: 무작위 아군 둘 공+2.' } },
    doyosae: { name: '도요새', tier: 6, atk: 8, hp: 8, trigger: 'startOfBattle', desc: '시작: 앞 적에게 2 피해.', level2: { atk: 16, hp: 16, desc: '시작: 앞 적에게 4 피해.' } },
    galmaegi: { name: '갈매기', tier: 6, atk: 8, hp: 8, trigger: 'startOfBattle', desc: '시작: 모든 아군 공+1.', level2: { atk: 16, hp: 16, desc: '시작: 모든 아군 공+2.' } },
    waegari: { name: '왜가리', tier: 6, atk: 9, hp: 9, trigger: 'startOfBattle', desc: '시작: 뒤 친구 +2/+2.', level2: { atk: 18, hp: 18, desc: '시작: 뒤 친구 +4/+4.' } },
    daewangjogae: { name: '대왕조개', tier: 6, atk: 10, hp: 5, trigger: 'beforeAttack', desc: '공격 전: 관통 1 피해.', level2: { atk: 20, hp: 10, desc: '공격 전: 관통 2 피해.' } },
    smallWorm: { name: '작은 벌레', tier: 'T', atk: 1, hp: 1, isToken: true, desc: '' },
    level2Worm: { name: '벌레', tier: 'T', atk: 2, hp: 2, isToken: true, desc: '' },
    smallScallop: { name: '작은 가리비', tier: 'T', atk: 2, hp: 2, isToken: true, desc: '' },
    level2Scallop: { name: '가리비', tier: 'T', atk: 4, hp: 4, isToken: true, desc: '' },
  };

  const FOOD_DATA = {
    plankton: { name: '플랑크톤', cost: 3, desc: '유닛에게 영구 +1/+1 부여.', effect: (unit) => { unit.atk += 1; unit.hp += 1; } },
    pincer: { name: '집게 강화', cost: 3, desc: '유닛에게 영구 공격력 +2 부여.', effect: (unit) => { unit.atk += 2; } },
    shell: { name: '껍질 강화', cost: 3, desc: '유닛에게 영구 체력 +2 부여.', effect: (unit) => { unit.hp += 2; } },
  };

  let gameState = {};

  function createUnitInstance(id, level = 1) {
    const data = UNIT_DATA[id];
    let unit = {
      id, ...data, instanceId: crypto.randomUUID(),
      atk: data.atk, hp: data.hp, level,
      battleAtk: 0, battleHp: 0,
      effects: { evade: 0, damageReduction: 0, firstHitTaken: false }
    };
    if (level === 2) {
      Object.assign(unit, data.level2);
    }
    return unit;
  }

  const $ = (selector) => document.querySelector(selector);
  const $$ = (selector) => document.querySelectorAll(selector);

  function renderUnit(unit, index, teamType) {
    const isEmpty = !unit;
    const baseClasses = `unit-card w-32 h-36 rounded-lg p-2 flex flex-col justify-between items-center relative flex-shrink-0`;
    if (isEmpty) {
      return `<div class="${baseClasses} border-2 border-dashed border-gray-400/50" data-team="${teamType}" data-index="${index}"></div>`;
    }
    const selectedClass = gameState.selectedItem?.instanceId === unit.instanceId ? 'selected' : '';
    const costText = teamType === 'shop' ? `<div class="absolute -top-2 -left-2 bg-yellow-500 text-white rounded-full w-6 h-6 text-sm flex items-center justify-center z-10 font-bold shadow-md">3</div>` : '';
    const sellButton = (teamType === 'player' || teamType === 'bench') && gameState.phase === 'shop' ? `<button class="sell-button absolute -top-2 -right-2 bg-red-500 text-white rounded-full w-6 h-6 text-xs z-10 shadow-md" data-team="${teamType}" data-index="${index}">판매</button>` : '';
    const imageURL = `https://unluckyidiot16.github.io/assets-common/MudAnimalAutoBattle/${unit.id}.png`;
    const stars = '★'.repeat(unit.level);
    return `
        <div id="unit-${unit.instanceId}" class="${baseClasses} bg-white ${selectedClass}" data-team="${teamType}" data-index="${index}" data-id="${unit.id}" data-instance-id="${unit.instanceId}">
            ${sellButton}${costText}
            <div class="text-xs font-bold text-center mt-2">${unit.name} <span class="text-yellow-400">${stars}</span></div>
            <img src="${imageURL}" alt="${unit.name}" class="my-1 w-20 h-20 object-contain" onerror="this.style.display='none'">
            <div class="text-center text-lg">
                <span class="text-red-500 font-bold">${unit.atk + unit.battleAtk}</span> / 
                <span class="text-blue-500 font-bold">${unit.hp + unit.battleHp}</span>
            </div>
            <div class="damage-text-container absolute inset-0"></div>
        </div>
    `;
  }

  function renderFood(food, index) {
    if (!food) return `<div class="w-24 h-24 border-2 border-dashed border-gray-400/50 rounded-lg"></div>`;
    const selectedClass = gameState.selectedItem?.type === 'food' && gameState.selectedItem.index === index ? 'selected' : '';
    return `
        <div class="unit-card w-24 h-24 bg-green-100 rounded-lg p-2 flex flex-col justify-center items-center text-center ${selectedClass}" data-type="food" data-index="${index}">
            <div class="text-sm font-bold">${food.name}</div>
            <div class="text-xs mt-1">${food.desc}</div>
            <div class="font-bold mt-1 text-yellow-600">${food.cost} 골드</div>
        </div>
     `;
  }

  function renderAll() {
    $('#turn-counter').textContent = gameState.turn;
    $('#life-counter').innerHTML = '❤️'.repeat(gameState.lives) + '🤍'.repeat(4 - gameState.lives);
    $('#gold-counter').textContent = gameState.gold;
    const currentEnvData = ENVIRONMENTS[gameState.currentEnvironment];
    $('#environment-indicator').textContent = currentEnvData.name;
    $('#player-team').style.backgroundColor = currentEnvData.color;

    let selectionText = '';
    if (gameState.selectedItem) {
      const { data } = gameState.selectedItem;
      selectionText = `[${data.name}] ${data.desc}`;
    }
    $('#selection-info').textContent = selectionText;

    $('#player-team').innerHTML = gameState.playerTeam.map((u, i) => renderUnit(u, i, 'player')).join('');
    $('#player-bench').innerHTML = gameState.benchTeam.map((u, i) => renderUnit(u, i, 'bench')).join('');

    let enemyTeamHtml = '<div class="h-36"></div>';
    if (gameState.phase === 'battle') {
      $('#enemy-team').style.backgroundColor = currentEnvData.color;
      $('#enemy-team').classList.add('p-4', 'rounded-lg');
      enemyTeamHtml = gameState.enemyTeam.map((u, i) => renderUnit(u, i, 'enemy')).join('');
    } else {
      $('#enemy-team').style.backgroundColor = 'transparent';
      $('#enemy-team').classList.remove('p-4', 'rounded-lg');
    }
    $('#enemy-team').innerHTML = enemyTeamHtml;

    $('#shop-area').classList.toggle('hidden', gameState.phase !== 'shop');
    $('#enemy-team-area').classList.toggle('hidden', gameState.phase === 'shop');
    $('#battle-log-container').classList.toggle('hidden', gameState.phase === 'shop');
    if (gameState.phase === 'shop') {
      $('#shop-units').innerHTML = gameState.shop.units.map((u, i) => renderUnit(u, i, 'shop')).join('');
      $('#shop-foods').innerHTML = gameState.shop.foods.map((f, i) => renderFood(f, i)).join('');
    }

    const trophyBar = $('#win-trophy-bar');
    trophyBar.innerHTML = '';
    const filledTrophySVG = `<svg class="h-10 w-10 text-yellow-400" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M13 3.25A2.25 2.25 0 0 0 10.75 1H6.25A2.25 2.25 0 0 0 4 3.25V5.5h9.25v10.25h-3.5a.75.75 0 0 1 0-1.5h2v-1.5h-2a.75.75 0 0 1 0-1.5h2v-1.5h-2a.75.75 0 0 1 0-1.5h2V8h-2a.75.75 0 0 1 0-1.5h2.75A2.25 2.25 0 0 0 13 4.25V3.25Z M8.5 18.25a.75.75 0 0 0-1.5 0v1.5h-1.5a.75.75 0 0 0 0 1.5H7v1.5a.75.75 0 0 0 1.5 0V21h1.5a.75.75 0 0 0 0-1.5H8.5v-1.25Z M18 17a1 1 0 1 0 0 2 1 1 0 0 0 0-2Z"></path></svg>`;
    const emptyTrophySVG = `<svg class="h-10 w-10 text-white/40" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M13 3.25A2.25 2.25 0 0 0 10.75 1H6.25A2.25 2.25 0 0 0 4 3.25V5.5h9.25v10.25h-3.5a.75.75 0 0 1 0-1.5h2v-1.5h-2a.75.75 0 0 1 0-1.5h2v-1.5h-2a.75.75 0 0 1 0-1.5h2V8h-2a.75.75 0 0 1 0-1.5h2.75A2.25 2.25 0 0 0 13 4.25V3.25Z M8.5 18.25a.75.75 0 0 0-1.5 0v1.5h-1.5a.75.75 0 0 0 0 1.5H7v1.5a.75.75 0 0 0 1.5 0V21h1.5a.75.75 0 0 0 0-1.5H8.5v-1.25Z M18 17a1 1 0 1 0 0 2 1 1 0 0 0 0-2Z"></path></svg>`;
    for (let i = 0; i < 10; i++) trophyBar.innerHTML += (i < gameState.wins) ? filledTrophySVG : emptyTrophySVG;
    addClickListeners();
  }

  function getAvailableUnits(tier) { return Object.keys(UNIT_DATA).filter(id => !UNIT_DATA[id].isToken && UNIT_DATA[id].tier <= tier); }

  function populateShop() {
    const maxTier = Math.min(6, Math.floor((gameState.turn - 1) / 2) + 1);
    const availableUnits = getAvailableUnits(maxTier);
    gameState.shop.units = [];
    for(let i=0; i<3; i++) {
      if (availableUnits.length === 0) continue;
      const randomId = availableUnits[Math.floor(Math.random() * availableUnits.length)];
      gameState.shop.units.push(createUnitInstance(randomId));
    }
    const availableFoods = Object.keys(FOOD_DATA);
    gameState.shop.foods = [];
    for(let i=0; i<2; i++) {
      const randomId = availableFoods[Math.floor(Math.random() * availableFoods.length)];
      gameState.shop.foods.push({id: randomId, ...FOOD_DATA[randomId]});
    }
  }

  function levelUp(unit) {
    Object.assign(unit, UNIT_DATA[unit.id].level2);
    unit.level = 2;
  }

  function checkForCombine(unitId) {
    if (!unitId) return;
    const allPlayerUnits = [...gameState.playerTeam, ...gameState.benchTeam];
    const unitsToCombine = [];
    allPlayerUnits.forEach((u, index) => {
      if (u && u.id === unitId && u.level === 1) {
        unitsToCombine.push({ unit: u, index, teamKey: index < 5 ? 'playerTeam' : 'benchTeam' });
      }
    });

    if (unitsToCombine.length >= 3) {
      const [unitToKeep, ...unitsToRemove] = unitsToCombine;
      levelUp(unitToKeep.unit);
      unitsToRemove.slice(0, 2).forEach(item => {
        gameState[item.teamKey][item.index % 5] = null;
      });
    }
  }

  function clearSelection() { gameState.selectedItem = null; renderAll(); }
  function sellUnit(team, index) {
    const teamKey = team === 'player' ? 'playerTeam' : 'benchTeam';
    const unit = gameState[teamKey][index];
    if (!unit) return;
    gameState.gold += unit.level;
    gameState[teamKey][index] = null;
    clearSelection();
  }
  function rollShop() { if (gameState.gold < 1) return; gameState.gold -= 1; populateShop(); renderAll(); }

  function startTurn() {
    gameState.turn++;
    gameState.gold = 10;
    gameState.phase = 'shop';
    const environments = Object.keys(ENVIRONMENTS);
    gameState.currentEnvironment = environments[Math.floor(Math.random() * environments.length)];
    populateShop();
    renderAll();
  }

  function initGame() {
    gameState = {
      turn: 1, wins: 0, lives: 4, gold: 10, phase: 'shop',
      playerTeam: Array(5).fill(null), benchTeam: Array(5).fill(null), enemyTeam: [],
      shop: { units: [], foods: [] },
      currentEnvironment: 'LOW_TIDE', selectedItem: null,
    };
    const environments = Object.keys(ENVIRONMENTS);
    gameState.currentEnvironment = environments[Math.floor(Math.random() * environments.length)];
    populateShop();
    renderAll();
  }

  async function startBattle() {
    gameState.phase = 'battle';
    generateEnemyTeam();
    let playerBattleTeam = gameState.playerTeam.filter(u => u).map(u => JSON.parse(JSON.stringify(u)));
    playerBattleTeam.forEach(u => u.instanceId = crypto.randomUUID());
    let enemyBattleTeam = gameState.enemyTeam.filter(u => u).map(u => JSON.parse(JSON.stringify(u)));
    renderAll();
    await delay(100);
    renderBattleState(playerBattleTeam, enemyBattleTeam);
    const battleLog = $('#battle-log');
    battleLog.innerHTML = '';
    const log = (msg) => {
      const p = document.createElement('p');
      p.textContent = msg;
      battleLog.appendChild(p);
      battleLog.scrollTop = battleLog.scrollHeight;
    };

    log('--- 전투 시작 ---');
    await delay(500);
    await resolveTriggers('startOfBattle', playerBattleTeam, playerBattleTeam, enemyBattleTeam, log);
    await resolveTriggers('startOfBattle', enemyBattleTeam, enemyBattleTeam, playerBattleTeam, log);
    renderBattleState(playerBattleTeam, enemyBattleTeam);
    await delay(1000);

    while (playerBattleTeam.length > 0 && enemyBattleTeam.length > 0) {
      const playerUnit = playerBattleTeam[0];
      const enemyUnit = enemyBattleTeam[0];
      if (!playerUnit || !enemyUnit) break;
      await delay(500);
      await resolveTriggers('beforeAttack', [playerUnit], playerBattleTeam, enemyBattleTeam, log);
      renderBattleState(playerBattleTeam, enemyBattleTeam);
      await resolveTriggers('beforeAttack', [enemyUnit], enemyBattleTeam, playerBattleTeam, log);
      renderBattleState(playerBattleTeam, enemyBattleTeam);
      await delay(500);
      playerBattleTeam = playerBattleTeam.filter(u => u && u.hp + u.battleHp > 0);
      enemyBattleTeam = enemyBattleTeam.filter(u => u && u.hp + u.battleHp > 0);
      if (playerBattleTeam.length === 0 || enemyBattleTeam.length === 0) break;

      $(`#unit-${playerUnit.instanceId}`)?.classList.add('attack-animation');
      $(`#unit-${enemyUnit.instanceId}`)?.classList.add('enemy-attack-animation');

      await applyDamage(enemyUnit, playerUnit.atk + playerUnit.battleAtk, enemyBattleTeam, playerBattleTeam, log, playerUnit);
      if (enemyBattleTeam.some(u => u && u.hp + u.battleHp > 0)) {
        await applyDamage(playerUnit, enemyUnit.atk + enemyUnit.battleAtk, playerBattleTeam, enemyBattleTeam, log, enemyUnit);
      }

      await delay(500);
      $(`#unit-${playerUnit.instanceId}`)?.classList.remove('attack-animation');
      $(`#unit-${enemyUnit.instanceId}`)?.classList.remove('enemy-attack-animation');
      playerBattleTeam = playerBattleTeam.filter(u => u && u.hp + u.battleHp > 0);
      enemyBattleTeam = enemyBattleTeam.filter(u => u && u.hp + u.battleHp > 0);
      renderBattleState(playerBattleTeam, enemyBattleTeam);
      await delay(500);
    }

    await delay(1000);
    if (playerBattleTeam.length > 0 && enemyBattleTeam.length === 0) {
      log('--- 승리! ---');
      gameState.wins++;
    } else if (playerBattleTeam.length === 0 && enemyBattleTeam.length > 0) {
      log('--- 패배... ---');
      gameState.lives--;
    } else {
      log('--- 무승부 ---');
    }
    await delay(2000);
    if (gameState.wins >= 10) {
      showModal('최종 승리!', '갯벌의 지배자가 되셨습니다!');
    } else if (gameState.lives <= 0) {
      showModal('게임 오버', `최종 ${gameState.wins}승을 달성했습니다.`);
    } else {
      startTurn();
    }
  }
  function renderBattleState(playerTeam, enemyTeam) {
    $('#player-team').innerHTML = playerTeam.map((u, i) => renderUnit(u, i, 'player')).join('') + Array(5 - playerTeam.length).fill(renderUnit(null)).join('');
    $('#enemy-team').innerHTML = enemyTeam.map((u, i) => renderUnit(u, i, 'enemy')).join('') + Array(5 - enemyTeam.length).fill(renderUnit(null)).join('');
  }
  async function applyDamage(target, damage, targetTeam, attackerTeam, log, attacker) {
    if (!target || target.hp + target.battleHp <= 0) return;
    let finalDamage = damage;
    if (target.effects.evade > 0) {
      target.effects.evade--;
      log(`${target.name}이(가) 공격을 회피했습니다!`);
      return;
    }
    if (target.id === 'nakji' && !target.effects.firstHitTaken) {
      finalDamage = Math.max(0, finalDamage - (target.level === 2 ? 4 : 2));
      target.effects.firstHitTaken = true;
    }
    finalDamage = Math.max(0, finalDamage - target.effects.damageReduction);
    const damageNumber = document.createElement('div');
    damageNumber.className = 'damage-text';
    damageNumber.textContent = `-${finalDamage}`;
    $(`#unit-${target.instanceId} .damage-text-container`)?.appendChild(damageNumber);
    target.hp -= finalDamage;
    log(`${attacker.name}이(가) ${target.name}에게 ${finalDamage} 피해. (남은 체력: ${Math.max(0, target.hp + target.battleHp)})`);
    if (target.hp + target.battleHp > 0) {
      await resolveTriggers('hurt', [target], targetTeam, attackerTeam, log);
    } else {
      $(`#unit-${target.instanceId}`)?.classList.add('faint-animation');
      log(`${target.name} 퇴장!`);
      await resolveTriggers('faint', [target], targetTeam, attackerTeam, log);
    }
  }
  async function dealDirectDamage(target, damage, log, source) {
    if(!target || target.hp + target.battleHp <= 0) return;
    const damageNumber = document.createElement('div');
    damageNumber.className = 'damage-text';
    damageNumber.textContent = `-${damage}`;
    $(`#unit-${target.instanceId} .damage-text-container`)?.appendChild(damageNumber);
    target.hp -= damage;
    log(`[${source.name}] 효과로 ${target.name}이(가) ${damage}의 피해를 입었습니다.`);
  }
  function generateEnemyTeam() {
    gameState.enemyTeam = [];
    const enemyUnitCount = Math.min(5, Math.floor(gameState.turn / 2) + 2);
    const maxTier = Math.min(6, Math.floor((gameState.turn - 1) / 2) + 1);
    const availableUnits = getAvailableUnits(maxTier);
    for (let i=0; i<enemyUnitCount; i++) {
      if (availableUnits.length === 0) continue;
      const randomId = availableUnits[Math.floor(Math.random() * availableUnits.length)];
      const unit = createUnitInstance(randomId);
      if (gameState.turn > 5 && Math.random() < 0.2) levelUp(unit);
      gameState.enemyTeam.push(unit);
    }
  }
  async function resolveTriggers(trigger, actors, actorTeam, enemyTeam, log) {
    for (const actor of actors) {
      if (!actor || (actor.hp + actor.battleHp <= 0 && trigger !== 'faint')) continue;
      if (actor.trigger === trigger) {
        const effect = UNIT_EFFECTS[actor.id];
        if (effect) await effect(actor, actorTeam, enemyTeam, log);
      }
    }
  }
  const UNIT_EFFECTS = {
    bajirak: (self, _1, _2, log) => { const buff = self.level === 2 ? 2 : 1; self.battleAtk += buff; log(`[${self.name}] 효과: 공격력 +${buff}.`); },
    mudworm: (self, team, _, log) => {
      log(`[${self.name}] 효과: 벌레 소환!`);
      const index = team.findIndex(u => u && u.instanceId === self.instanceId);
      if (index === -1) return;
      const count = self.level === 2 ? 2 : 1;
      const summonId = self.level === 2 ? 'level2Worm' : 'smallWorm';
      for (let i = 0; i < count && team.filter(u=>u).length < 5; i++) { team.splice(index + 1 + i, 0, createUnitInstance(summonId)); }
    },
    mudSnail: () => {},
    smallCrab: (self, team, _, log) => {
      const i = team.findIndex(u => u && u.instanceId === self.instanceId);
      if (i > -1 && team[i+1]) { const buff = self.level === 2 ? 2 : 1; team[i+1].battleAtk += buff; log(`[${self.name}] 효과: ${team[i+1].name} 공격력 +${buff}.`); }
    },
    daehap: (self, team, _, log) => {
      const i = team.findIndex(u => u && u.instanceId === self.instanceId);
      if (i > -1 && team[i+1]) { const buff = self.level === 2 ? 2 : 1; team[i+1].battleAtk += buff; team[i+1].battleHp += buff; log(`[${self.name}] 효과: ${team[i+1].name} +${buff}/+${buff}.`); }
    },
    ppulsora: (self, team, _, log) => { if (team.findIndex(u=>u && u.instanceId===self.instanceId) === 0) { const amount = self.level === 2 ? 2:1; self.effects.evade = amount; log(`[${self.name}] 효과: 회피 ${amount}회 획득.`); } },
    mangdungeo: (self, team, _, log) => {
      const allies = team.filter(u => u && u.instanceId !== self.instanceId);
      if (allies.length > 0) {
        const count = self.level === 2 ? 2 : 1;
        for(let i=0; i<count; i++){ const target = allies[Math.floor(Math.random() * allies.length)]; target.battleAtk += 1; log(`[${self.name}] 효과: ${target.name} 공격력 +1.`); }
      }
    },
    nongge: async (self, _, enemyTeam, log) => { const dmg = self.level === 2 ? 2:1; await dealDirectDamage(enemyTeam[0], dmg, log, self); },
    honghap: (self, _, enemyTeam, log) => {
      if (enemyTeam[0]) { const debuff = self.level === 2 ? 2 : 1; enemyTeam[0].battleAtk = Math.max(0, (enemyTeam[0].atk + enemyTeam[0].battleAtk) - debuff) - enemyTeam[0].atk; log(`[${self.name}] 효과: ${enemyTeam[0].name} 공격력 -${debuff}.`); }
    },
    garibi: (self, team, _, log) => {
      log(`[${self.name}] 효과: 가리비 소환!`);
      const index = team.findIndex(u => u && u.instanceId === self.instanceId);
      if (index === -1) return;
      const summonId = self.level === 2 ? 'level2Scallop' : 'smallScallop';
      for(let i = 0; i < 2 && team.filter(u=>u).length < 5; i++) { team.splice(index + 1 + i, 0, createUnitInstance(summonId)); }
    },
    jjangddungeo: async (self, _, enemyTeam, log) => { const dmg = self.level === 2 ? 4 : 2; await dealDirectDamage(enemyTeam[0], dmg, log, self); },
    chilmyeoncho: (self, team, _, log) => { UNIT_EFFECTS.daehap(self, team, _, log); },
    haehongnamul: (self, team, _, log) => { const buff = self.level === 2 ? 2 : 1; team.forEach(u => u && (u.battleHp += buff)); log(`[${self.name}] 효과: 모든 아군 체력 +${buff}.`); },
    sora: (self, team, _, log) => {
      const i = team.findIndex(u => u && u.instanceId === self.instanceId);
      if (i > -1 && team[i+1]) { const buff = self.level === 2 ? 4 : 2; team[i+1].battleAtk += buff; log(`[${self.name}] 효과: ${team[i+1].name} 공격력 +${buff}.`); }
    },
    kkotge: async (self, _, enemyTeam, log) => { const dmg = self.level === 2 ? 2 : 1; await dealDirectDamage(enemyTeam[0], dmg, log, self); await dealDirectDamage(enemyTeam[1], dmg, log, self); },
    chilge: (self, _, _2, log) => { const reduc = self.level === 2 ? 4 : 2; self.effects.damageReduction = reduc; log(`[${self.name}] 효과: 받는 피해 -${reduc}.`); },
    nakji: (self, team, _, log) => {
      const i = team.findIndex(u => u && u.instanceId === self.instanceId);
      if (i !== -1 && i < team.filter(u=>u).length - 1) { const [unit] = team.splice(i, 1); team.push(unit); log(`[${self.name}] 효과: 후열로 이동.`); }
    },
    bigSnail: (self, team, _, log) => { const reduc = self.level === 2 ? 2 : 1; team.forEach(u => u && (u.effects.damageReduction += reduc)); log(`[${self.name}] 효과: 모든 아군 받는 피해 -${reduc}.`); },
    muneo: async (self, team, enemyTeam, log) => {
      const dmg = self.level === 2 ? 2 : 1; const buff = self.level === 2 ? 2 : 1;
      await dealDirectDamage(enemyTeam[0], dmg, log, self);
      const i = team.findIndex(u => u && u.instanceId === self.instanceId);
      if (i > -1 && team[i+1]) { team[i+1].battleAtk += buff; log(`[${self.name}] 효과: ${team[i+1].name} 공격력 +${buff}.`); }
    },
    sungeo: (self, team, _, log) => {
      const allies = team.filter(u => u && u.instanceId !== self.instanceId);
      if (allies.length > 0) {
        const count = self.level === 2 ? 2 : 1;
        for(let i=0; i<count; i++){ const target = allies[Math.floor(Math.random() * allies.length)]; target.battleAtk += 2; log(`[${self.name}] 효과: ${target.name} 공격력 +2.`); }
      }
    },
    doyosae: async (self, _, enemyTeam, log) => { const dmg = self.level === 2 ? 4 : 2; await dealDirectDamage(enemyTeam[0], dmg, log, self); },
    galmaegi: (self, team, _, log) => { const buff = self.level === 2 ? 2 : 1; team.forEach(u => u && u.instanceId !== self.instanceId && (u.battleAtk += buff)); log(`[${self.name}] 효과: 다른 모든 아군 공격력 +${buff}.`); },
    waegari: (self, team, _, log) => {
      const i = team.findIndex(u => u && u.instanceId === self.instanceId);
      if (i > -1 && team[i+1]) { const buff = self.level === 2 ? 4 : 2; team[i+1].battleAtk += buff; team[i+1].battleHp += buff; log(`[${self.name}] 효과: ${team[i+1].name} +${buff}/+${buff}.`); }
    },
    daewangjogae: async (self, _, enemyTeam, log) => { const dmg = self.level === 2 ? 2 : 1; await dealDirectDamage(enemyTeam[0], dmg, log, self); await dealDirectDamage(enemyTeam[1], dmg, log, self); },
  };

  function delay(ms) { return new Promise(res => setTimeout(res, ms)); }
  function showModal(title, text) { $('#modal-title').textContent = title; $('#modal-text').textContent = text; $('#modal').classList.remove('hidden'); }

  function addClickListeners() {
    $$('.unit-card').forEach(card => card.addEventListener('click', e => { e.stopPropagation(); handleCardClick(card.dataset); }));
    $$('.sell-button').forEach(button => button.addEventListener('click', e => { e.stopPropagation(); sellUnit(button.dataset.team, parseInt(button.dataset.index)); }));
  }

  function handleCardClick(dataset) {
    const { team, type, index } = dataset;
    const isPlayerArea = team === 'player' || team === 'bench';
    const selected = gameState.selectedItem;

    if (!selected) {
      if (team === 'shop' || type === 'food') {
        const itemIndex = parseInt(index);
        const itemData = type === 'food' ? gameState.shop.foods[itemIndex] : gameState.shop.units[itemIndex];
        if (itemData) gameState.selectedItem = { type: type || 'unit', index: itemIndex, data: itemData };
      } else if (isPlayerArea) {
        const teamKey = team === 'player' ? 'playerTeam' : 'benchTeam';
        const unit = gameState[teamKey][index];
        if (unit) gameState.selectedItem = { type: 'playerUnit', team, index: parseInt(index), instanceId: unit.instanceId, data: unit };
      }
    } else {
      if (selected.type === 'unit') {
        if (isPlayerArea && gameState.gold >= 3) {
          const teamKey = team === 'player' ? 'playerTeam' : 'benchTeam';
          if (!gameState[teamKey][index]) {
            gameState.gold -= 3;
            const boughtUnit = createUnitInstance(selected.data.id);
            gameState[teamKey][index] = boughtUnit;
            gameState.shop.units[selected.index] = null;
            if (boughtUnit.trigger === 'buy') handleBuyTrigger(boughtUnit);
            checkForCombine(boughtUnit.id);
            clearSelection();
          }
        }
      } else if (selected.type === 'food') {
        if (isPlayerArea) {
          const teamKey = team === 'player' ? 'playerTeam' : 'benchTeam';
          const targetUnit = gameState[teamKey][index];
          if (targetUnit && gameState.gold >= selected.data.cost) {
            gameState.gold -= selected.data.cost;
            selected.data.effect(targetUnit);
            gameState.shop.foods[selected.index] = null;
            clearSelection();
          }
        }
      } else if (selected.type === 'playerUnit') {
        if (isPlayerArea) {
          const sourceTeamKey = selected.team === 'player' ? 'playerTeam' : 'benchTeam';
          const targetTeamKey = team === 'player' ? 'playerTeam' : 'benchTeam';
          [gameState[sourceTeamKey][selected.index], gameState[targetTeamKey][index]] = [gameState[targetTeamKey][index], gameState[sourceTeamKey][selected.index]];
          clearSelection();
        }
      }
    }
    renderAll();
  }

  function handleBuyTrigger(boughtUnit) {
    if (boughtUnit.id === 'mudSnail') {
      const allAllies = [...gameState.playerTeam, ...gameState.benchTeam].filter(u => u);
      if (allAllies.length > 0) {
        const count = boughtUnit.level === 2 ? 2 : 1;
        for(let i=0; i<count; i++){
          const target = allAllies[Math.floor(Math.random() * allAllies.length)];
          target.hp++;
        }
      }
    }
  }

  $('#roll-button').addEventListener('click', rollShop);
  $('#end-turn-button').addEventListener('click', startBattle);
  $('#restart-button').addEventListener('click', () => { $('#modal').classList.add('hidden'); initGame(); });
  document.body.addEventListener('click', (e) => {
    if (e.target.closest('.unit-card, button')) return;
    clearSelection();
  });

  initGame();
</script>

</body>
</html>

