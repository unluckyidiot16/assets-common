<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ì •ë¦¬í•˜ê¸° ê¸€ì“°ê¸° ê²Œì„ (ì‚¬ë¬¼í•¨)</title>
    <!-- Tailwind CSS ë¡œë“œ -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* ìº”ë²„ìŠ¤ ìŠ¤íƒ€ì¼ */
        canvas {
            background-color: #ffffff;
            border-radius: 12px;
            border: 1px solid #e2e8f0;
            cursor: pointer;
        }
        body {
            font-family: 'Inter', sans-serif;
        }
    </style>
</head>
<body class="bg-gradient-to-b from-slate-50 to-slate-100 min-h-screen py-8 px-4">

<div class="max-w-3xl mx-auto">
    <!-- í—¤ë” -->
    <header class="mb-6 flex flex-col gap-2 sm:flex-row sm:items-end sm:justify-between">
        <div>
            <h1 class="text-2xl font-extrabold text-slate-800">ì‚¬ë¬¼í•¨ ì •ë¦¬ ê¸€ì“°ê¸°</h1>
            <p class="text-slate-600 text-sm">ë‹¨ê³„ë³„ë¡œ ë¬¸ì¥ì„ ì™„ì„±í•˜ê³ , ë§ˆì§€ë§‰ì— 'ì²˜ìŒ-ì¤‘ê°„-ë' êµ¬ì¡°ì˜ ê¸€ë¡œ ë¬¶ì–´ë´ìš”.</p>
        </div>
        <div class="flex items-center gap-3">
            <button
                    id="restartButton"
                    class="px-3 py-1 rounded-lg border bg-white text-slate-700 hover:shadow text-sm"
            >
                ì²˜ìŒë¶€í„° ë‹¤ì‹œí•˜ê¸°
            </button>
        </div>
    </header>

    <!-- ì§„í–‰ë„ (HTML) -->
    <div class="mb-6">
        <div class="flex justify-between text-xs text-slate-600">
            <span id="progressText">ë‹¨ê³„ 1 / 4</span>
            <span id="progressPct">0%</span>
        </div>
        <div class="h-2 mt-1 rounded-full bg-slate-200 overflow-hidden">
            <div id="progressBar" class="h-full bg-blue-500 transition-all" style="width: 0%"></div>
        </div>
    </div>

    <!-- ìº”ë²„ìŠ¤ -->
    <canvas id="gameCanvas" width="800" height="700" class="w-full"></canvas>

    <!-- ë„ì›€ë§ (HTML) -->
    <div class="mt-6">
        <h2 class="text-sm font-bold text-slate-700">í•™ìŠµíŒ</h2>
        <div class="p-4 rounded-xl border bg-white text-sm text-slate-700 leading-relaxed">
            <ul class="list-disc pl-5 space-y-1">
                <li>'ì²˜ìŒ' ë¶€ë¶„(ì‚¬ë¬¼í•¨)ì€ ì •ë¦¬í•˜ëŠ” ì´ìœ ë¥¼ ìƒê°í•˜ë©° ê³¨ë¼ë´ìš”.</li>
                <li>'ì¤‘ê°„' ë¶€ë¶„(ì‚¬ë¬¼+ë°©ë²•)ì€ ì‚¬ë¬¼ì— ì–´ìš¸ë¦¬ëŠ” ì •ë¦¬ ë°©ë²•ì„ ì§ì§€ì–´ ë¬¸ì¥ì„ ë§Œë“¤ì–´ìš”.</li>
                <li>ë§ˆì§€ë§‰ì— ì™„ì„±ëœ ê¸€ì„ íŒ¨ë“¤ë ›ì— ë¶™ì—¬ë„£ê³  ì¹œêµ¬ë“¤ê³¼ ê³µìœ í•´ ë³´ì„¸ìš”.</li>
            </ul>
        </div>
    </div>
</div>

<script>
    // ===== ë°ì´í„° ì •ì˜ (ì‚¬ìš©ì ìš”ì²­ ë°˜ì˜) =====

    // [ì¤‘ê°„] íŒŒíŠ¸ìš© ë°ì´í„°
    const ITEMS = [
        { id: "textbook", name: "êµê³¼ì„œ", emoji: "ğŸ“š" },
        { id: "notebook", name: "ê³µì±…", emoji: "ğŸ—’ï¸" },
        { id: "file", name: "íŒŒì¼", emoji: "ğŸ“" },
        { id: "pencils", name: "ìƒ‰ì—°í•„", emoji: "ğŸ–ï¸" },
        { id: "glue", name: "í’€", emoji: "ğŸ§´" },
        { id: "scissors", name: "ê°€ìœ„", emoji: "âœ‚ï¸" },
        { id: "recorder", name: "ë¦¬ì½”ë”", emoji: "ğŸµ" },
        { id: "jumprope", name: "ì¤„ë„˜ê¸°", emoji: "ğŸ¤¸" },
        { id: "artwork", name: "ìˆ˜ì—… ì‘í’ˆ", emoji: "ğŸ¨" },
    ];

    const METHODS = [
        { id: "stand_up", name: "ì„¸ìš°ê±°ë‚˜ ê½‚ê¸°", hint: "ì±…ì²˜ëŸ¼ ì„¸ì›Œìš”" },
        { id: "in_basket", name: "ì •ë¦¬ ë°”êµ¬ë‹ˆì— ë‹´ê¸°", hint: "ë°”êµ¬ë‹ˆì— ëª¨ì•„ìš”" },
        { id: "in_pouch", name: "ì •ë¦¬ ì£¼ë¨¸ë‹ˆì— ë„£ê¸°", hint: "ì£¼ë¨¸ë‹ˆì— ë„£ì–´ìš”" },
        { id: "take_home", name: "ë¶„ë¥˜í•´ì„œ ì§‘ìœ¼ë¡œ ê°€ì ¸ê°€ê¸°", hint: "ì§‘ìœ¼ë¡œ!" },
    ];

    // ìƒˆë¡œìš´ ë°ì´í„°ì— ë§ì¶˜ ì§ì§“ê¸° ê·œì¹™
    const VALID = {
        textbook: ["stand_up", "take_home"],
        notebook: ["stand_up", "take_home"],
        file: ["stand_up", "take_home"],
        pencils: ["in_basket", "in_pouch"],
        glue: ["in_basket", "in_pouch"],
        scissors: ["in_basket", "in_pouch"],
        recorder: ["in_basket", "in_pouch", "take_home"],
        jumprope: ["in_basket", "in_pouch", "take_home"],
        artwork: ["take_home", "in_basket"],
    };

    // [ì²˜ìŒ] íŒŒíŠ¸ìš© ë°ì´í„° (ì´ì „ê³¼ ë™ì¼)
    const LOCKER_STATEMENTS = [
        { id: "good1", text: "í•„ìš”í•œ ë¬¼ê±´ì„ ê¸ˆë°© ì°¾ì„ ìˆ˜ ìˆì–´ìš”.", type: "good" },
        { id: "good2", text: "ì‚¬ë¬¼í•¨ì´ ê¹¨ë—í•´ì ¸ì„œ ê¸°ë¶„ì´ ì¢‹ì•„ìš”.", type: "good" },
        { id: "good3", text: "ì¤€ë¹„ë¬¼ì„ ìŠì–´ë²„ë¦¬ì§€ ì•Šì•„ìš”.", type: "good" },
        { id: "bad1", text: "ì‹œê°„ì´ ë„ˆë¬´ ì˜¤ë˜ ê±¸ë ¤ì„œ ê·€ì°®ì•„ìš”.", type: "bad" },
        { id: "bad2", text: "ì •ë¦¬í•˜ëŠ” ê²ƒì€ ì¬ë¯¸ì—†ì–´ìš”.", type: "bad" },
        { id: "bad3", text: "ì–´ì°¨í”¼ ê¸ˆë°© ë‹¤ì‹œ ë”ëŸ¬ì›Œì ¸ìš”.", type: "bad" },
    ];

    const TOTAL_ROUNDS = 4; // ì²˜ìŒ 1 + ì¤‘ê°„ 3
    const PADLET_URL = "https://padlet.com/anjaehyeong0619/samulham"; // íŒ¨ë“¤ë › ì£¼ì†Œ

    // ===== ìº”ë²„ìŠ¤ ë° ê²Œì„ ìƒíƒœ =====
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const restartButton = document.getElementById('restartButton');

    // HTML ì§„í–‰ë„ UI ìš”ì†Œ
    const progressTextEl = document.getElementById('progressText');
    const progressPctEl = document.getElementById('progressPct');
    const progressBarEl = document.getElementById('progressBar');

    // ê²Œì„ ìƒíƒœ ë³€ìˆ˜
    let phase = 'start'; // 'start', 'middle', 'finished'
    let acceptedSentences = [];
    let usedItemIds = [];

    // 'ì²˜ìŒ' íŒŒíŠ¸ ìƒíƒœ
    let selectedLockerIds = [];

    // 'ì¤‘ê°„' íŒŒíŠ¸ ìƒíƒœ
    let selectedItem = null;
    let selectedMethod = null;
    let generatedSentence = "";

    let errorMessage = "";

    // í´ë¦­ ê°€ëŠ¥í•œ ì˜ì—­ (ì¹´ë“œ, ë²„íŠ¼)
    let clickables = [];

    // ===== ìœ í‹¸ í•¨ìˆ˜ =====
    function stripTrailingPeriod(s) {
        return s.trim().replace(/[.ã€‚]+$/g, "");
    }

    // [ì²˜ìŒ] íŒŒíŠ¸ ë¬¸ì¥ ìƒì„± (ì´ìœ ê°€ ì•ìœ¼ë¡œ)
    function makeStartSentence() {
        const reasons = LOCKER_STATEMENTS
            .filter(s => selectedLockerIds.includes(s.id))
            .map(s => {
                // "í•„ìš”í•œ ë¬¼ê±´ì„ ê¸ˆë°© ì°¾ì„ ìˆ˜ ìˆì–´ìš”." -> "í•„ìš”í•œ ë¬¼ê±´ì„ ê¸ˆë°© ì°¾ê³ "
                // "ì‚¬ë¬¼í•¨ì´ ê¹¨ë—í•´ì ¸ì„œ ê¸°ë¶„ì´ ì¢‹ì•„ìš”." -> "ì‚¬ë¬¼í•¨ì´ ê¹¨ë—í•´ì ¸ì„œ ê¸°ë¶„ì´ ì¢‹ê³ "
                return stripTrailingPeriod(s.text)
                    .replace(/ ìˆì–´ìš”.$/, " ìˆê³ ")
                    .replace(/ ì¢‹ì•„ìš”.$/, " ì¢‹ê³ ")
                    .replace(/ ì•Šì•„ìš”.$/, " ì•Šê³ ");
            });

        // "í•„ìš”í•œ ë¬¼ê±´ì„ ê¸ˆë°© ì°¾ê³ , ì‚¬ë¬¼í•¨ì´ ê¹¨ë—í•´ì ¸ì„œ ê¸°ë¶„ì´ ì¢‹ê³ "
        let reasonText = reasons.join(", ");
        // ë§ˆì§€ë§‰ 'ê³ 'ë¥¼ 'ê¸°'ë¡œ ë³€ê²½
        if (reasonText.endsWith("ê³ ")) {
            reasonText = reasonText.substring(0, reasonText.lastIndexOf("ê³ ")) + "ê¸°";
        }

        return `${reasonText} ìœ„í•´ì„œ, ì €ëŠ” ì‚¬ë¬¼í•¨ì„ ì •ë¦¬í–ˆìŠµë‹ˆë‹¤.`;
    }

    // [ì¤‘ê°„] íŒŒíŠ¸ ë¬¸ì¥ ìƒì„± (ì´ìœ ê°€ ì•ìœ¼ë¡œ)
    function makeMiddleSentence(item, method) {
        const core = `ë‚˜ëŠ” ${item.name}ì„(ë¥¼) ${method.name} ë°©ë²•ìœ¼ë¡œ ì •ë¦¬í–ˆë‹¤.`;

        // ìƒˆ ì•„ì´í…œì— ë§ì¶˜ ì´ìœ 
        const reasonMap = {
            textbook: "êµê³¼ì„œë¥¼ ë¹¨ë¦¬ ì°¾ê¸°",
            notebook: "ê³µì±…ì„ ë°”ë¡œ êº¼ë‚´ê¸°",
            file: "í•„ìš”í•œ íŒŒì¼ì„ ì°¾ê¸°",
            pencils: "í•™ìš©í’ˆì„ í¸í•˜ê²Œ ì“°ê¸°",
            glue: "í•™ìš©í’ˆì„ í¸í•˜ê²Œ ì“°ê¸°",
            scissors: "í•™ìš©í’ˆì„ í¸í•˜ê²Œ ì“°ê¸°",
            recorder: "ì•…ê¸°ë¥¼ ì•ˆì „í•˜ê²Œ ë³´ê´€í•˜ê¸°",
            jumprope: "ì²´ìœ¡ ë„êµ¬ë¥¼ ì±™ê¸°ê¸°",
            artwork: "ì‘í’ˆì„ ì†Œì¤‘íˆ ë³´ê´€í•˜ê¸°",
        };

        const reason = (reasonMap[item.id] ?? "ê¹”ë”í•˜ê²Œ ì‚¬ìš©í•˜ê¸°") + " ìœ„í•´ì„œ";
        return `${reason}, ${core}`;
    }

    // 'ë' íŒŒíŠ¸ ê¸€ ì¡°í•© (ìˆ˜ì •ë¨)
    function buildComposition() {
        if (acceptedSentences.length < TOTAL_ROUNDS) return "ë¬¸ì¥ì´ ë¶€ì¡±í•©ë‹ˆë‹¤.";

        const [startRaw, mid1Raw, mid2Raw, mid3Raw] = acceptedSentences;

        const intro = "ì €ì˜ ì‚¬ë¬¼í•¨ ì •ë¦¬ ê²½í—˜ì„ ì†Œê°œí•©ë‹ˆë‹¤.";

        // [ì´ìœ ] ìœ„í•´ì„œ, ì €ëŠ” ì‚¬ë¬¼í•¨ì„ ì •ë¦¬í–ˆìŠµë‹ˆë‹¤. ->
        // [ì´ìœ ] ìœ„í•´ì„œ, ë¨¼ì € ì €ëŠ” ì‚¬ë¬¼í•¨ì„ ì •ë¦¬í–ˆìŠµë‹ˆë‹¤.
        const start = stripTrailingPeriod(startRaw).replace("ì €ëŠ”", "ë¨¼ì € ì €ëŠ”");

        // [ì´ìœ ] ìœ„í•´ì„œ, ë‚˜ëŠ” [ì‚¬ë¬¼]ì„ ì •ë¦¬í–ˆë‹¤. ->
        // [ì´ìœ ] ìœ„í•´ì„œ, ì²«ì§¸ë¡œ, [ì‚¬ë¬¼]ì„ ì •ë¦¬í–ˆë‹¤.
        const mid1 = stripTrailingPeriod(mid1Raw).replace("ë‚˜ëŠ”", "ì²«ì§¸ë¡œ,");
        const mid2 = stripTrailingPeriod(mid2Raw).replace("ë‚˜ëŠ”", "ë‘˜ì§¸ë¡œ,");
        const mid3 = stripTrailingPeriod(mid3Raw).replace("ë‚˜ëŠ”", "ì…‹ì§¸ë¡œ,");

        const end = "ì´ë ‡ê²Œ ì •ë¦¬ë¥¼ í•˜ê³  ë‚˜ë‹ˆ ê¸°ë¶„ì´ ìƒì¾Œí•˜ê³  ì¢‹ì•˜ìŠµë‹ˆë‹¤. ì•ìœ¼ë¡œë„ ì œ ë¬¼ê±´ì„ ìŠ¤ìŠ¤ë¡œ ì •ë¦¬í•˜ëŠ” ìŠµê´€ì„ ë“¤ì´ê² ìŠµë‹ˆë‹¤.";

        // \n\nìœ¼ë¡œ ë¬¸ë‹¨ êµ¬ë¶„
        return `${intro}\n\n${start}.\n\n${mid1}. ${mid2}. ${mid3}.\n\n${end}`;
    }

    // ===== ìº”ë²„ìŠ¤ ê·¸ë¦¬ê¸° í•¨ìˆ˜ =====

    function wrapText(text, x, y, maxWidth, lineHeight, color = '#1e293b') {
        ctx.fillStyle = color;
        ctx.font = '18px Inter, sans-serif';
        let words = text.split(' ');
        let line = '';
        let testY = y;

        for (let n = 0; n < words.length; n++) {
            let testLine = line + words[n] + ' ';
            let metrics = ctx.measureText(testLine);
            let testWidth = metrics.width;
            if (testWidth > maxWidth && n > 0) {
                ctx.fillText(line, x, testY);
                line = words[n] + ' ';
                testY += lineHeight;
            } else {
                line = testLine;
            }
        }
        ctx.fillText(line, x, testY);
    }

    function drawMultiLineText(text, x, y, lineHeight) {
        ctx.fillStyle = '#1e293b'; // slate-800
        ctx.font = '18px Inter, sans-serif';
        const lines = text.split('\n');
        lines.forEach((line, index) => {
            ctx.fillText(line, x, y + (index * lineHeight));
        });
    }

    function drawCard(x, y, w, h, title, subtitle = '', emoji = '', selected = false) {
        ctx.beginPath();
        ctx.fillStyle = '#ffffff';
        ctx.roundRect(x, y, w, h, 12);
        ctx.fill();

        ctx.strokeStyle = selected ? '#2563eb' : '#cbd5e1'; // blue-600 or slate-300
        ctx.lineWidth = selected ? 2 : 1;
        ctx.stroke();

        // ë‚´ìš©
        let textX = x + 16;
        if (emoji) {
            ctx.font = '24px Inter, sans-serif';
            ctx.fillText(emoji, x + 16, y + 36);
            textX += 36;
        }

        ctx.fillStyle = '#1e293b'; // slate-800
        ctx.font = 'bold 16px Inter, sans-serif';
        // í…ìŠ¤íŠ¸ê°€ ì¹´ë“œ ë„˜ì¹˜ì§€ ì•Šê²Œ
        const titleWidth = ctx.measureText(title).width;
        if (titleWidth > (w - (textX - x) - 16)) {
            ctx.font = 'bold 14px Inter, sans-serif';
        }

        ctx.fillText(title, textX, y + 32);

        if (subtitle) {
            ctx.fillStyle = '#64748b'; // slate-500
            ctx.font = '14px Inter, sans-serif';
            ctx.fillText(subtitle, textX, y + 54);
        }
    }

    function drawButton(x, y, w, h, text, disabled = false) {
        ctx.beginPath();
        ctx.fillStyle = disabled ? '#e2e8f0' : '#2563eb'; // slate-200 or blue-600
        ctx.roundRect(x, y, w, h, 12);
        ctx.fill();

        ctx.fillStyle = disabled ? '#94a3b8' : '#ffffff'; // slate-400 or white
        ctx.font = 'bold 16px Inter, sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(text, x + w / 2, y + h / 2);
        ctx.textAlign = 'left';
        ctx.textBaseline = 'alphabetic';
    }

    function drawTitle(text) {
        ctx.fillStyle = '#334155'; // slate-700
        ctx.font = 'bold 20px Inter, sans-serif';
        ctx.fillText(text, 20, 40);
    }

    function drawError() {
        if (!errorMessage) return;

        let color = '#dc2626'; // rose-600 (ê¸°ë³¸ê°’: ì—ëŸ¬)
        let text = errorMessage;

        if (errorMessage === "copied") {
            color = '#16a34a'; // green-600
            text = "ê¸€ì´ ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤! ìƒˆ íƒ­ì— ë¶™ì—¬ë„£ìœ¼ì„¸ìš”.";
        } else if (errorMessage === "copyFailed") {
            text = "ë³µì‚¬ì— ì‹¤íŒ¨í–ˆì–´ìš”. ë‹¤ì‹œ ì‹œë„í•´ ì£¼ì„¸ìš”.";
        }

        ctx.fillStyle = color;
        ctx.font = 'bold 16px Inter, sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText(text, canvas.width / 2, canvas.height - 20);
        ctx.textAlign = 'left';
    }

    // ===== íŒŒíŠ¸ë³„ ê·¸ë¦¬ê¸° =====

    function drawStart() {
        drawTitle('[ì²˜ìŒ] ì‚¬ë¬¼í•¨ì„ ì •ë¦¬í•˜ë©´ ì¢‹ì€ ì ì„ ê³¨ë¼ë´…ì‹œë‹¤. (2ê°œ ì´ìƒ)');

        clickables = [];
        const cardW = (canvas.width - 80) / 3;
        const cardH = 100;

        LOCKER_STATEMENTS.forEach((card, i) => {
            const x = 20 + (i % 3) * (cardW + 20);
            const y = 80 + Math.floor(i / 3) * (cardH + 20);
            const selected = selectedLockerIds.includes(card.id);
            drawCard(x, y, cardW, cardH, card.text, '', '', selected);
            clickables.push({ id: card.id, type: card.type, bounds: [x, y, cardW, cardH], action: 'selectLocker' });
        });

        const isDisabled = selectedLockerIds.length < 2;
        const btnW = 250;
        const btnX = (canvas.width - btnW) / 2;
        drawButton(btnX, 320, btnW, 50, "'ì²˜ìŒ' ë¶€ë¶„ ë¬¸ì¥ ë§Œë“¤ê¸°", isDisabled);
        clickables.push({ bounds: [btnX, 320, btnW, 50], action: 'completeStart', disabled: isDisabled });
    }

    function drawMiddle() {
        const currentMiddleRound = acceptedSentences.length; // 1, 2, or 3
        drawTitle(`[ì¤‘ê°„ ${currentMiddleRound}/3] ì‚¬ë¬¼ê³¼ ë°©ë²•ì„ ì§ì§€ì–´ ë´…ì‹œë‹¤.`);

        clickables = [];
        const col1X = 20;
        const col2X = canvas.width / 2 + 10;
        const cardW = (canvas.width / 2) - 30;
        const cardH = 70; // ì¹´ë“œê°€ ë§ì•„ì ¸ì„œ ë†’ì´ ì‚´ì§ ì¤„ì„

        // 'ì¤‘ê°„' íŒŒíŠ¸ì—ì„œ ìƒì„±ëœ ë¬¸ì¥ì´ ìˆë‹¤ë©´, ê·¸ê²ƒë§Œ ë³´ì—¬ì¤Œ
        if (generatedSentence) {
            drawTitle("ë¬¸ì¥ì´ ì™„ì„±ë˜ì—ˆì–´ìš”!");
            wrapText(generatedSentence, 20, 100, canvas.width - 40, 28);

            const btnW = 150;
            const btnX = (canvas.width - btnW) / 2;
            drawButton(btnX, 250, btnW, 50, "ë‹¤ìŒ ë‹¨ê³„ë¡œ");
            clickables.push({ bounds: [btnX, 250, btnW, 50], action: 'completeMiddle' });
            return;
        }

        // 1) ì‚¬ë¬¼ ê³ ë¥´ê¸°
        ctx.fillStyle = '#475569'; // slate-600
        ctx.font = 'bold 16px Inter, sans-serif';
        ctx.fillText("1) ì •ë¦¬í•  ì‚¬ë¬¼", col1X, 90);

        const remainingItems = ITEMS.filter(x => !usedItemIds.includes(x.id));
        const itemsToDraw = remainingItems.length ? remainingItems : ITEMS;

        itemsToDraw.forEach((item, i) => {
            const x = col1X;
            const y = 110 + i * (cardH + 10);
            if (y > 550) return; // ìº”ë²„ìŠ¤ ë„˜ì–´ê°€ì§€ ì•Šê²Œ
            const selected = selectedItem?.id === item.id;
            drawCard(x, y, cardW, cardH, item.name, '', item.emoji, selected);
            clickables.push({ ...item, bounds: [x, y, cardW, cardH], action: 'selectItem' });
        });

        // 2) ë°©ë²• ê³ ë¥´ê¸°
        ctx.fillStyle = '#475569';
        ctx.font = 'bold 16px Inter, sans-serif';
        ctx.fillText("2) ì •ë¦¬í•  ë°©ë²•", col2X, 90);

        METHODS.forEach((method, i) => {
            const x = col2X;
            const y = 110 + i * (cardH + 10);
            const selected = selectedMethod?.id === method.id;
            drawCard(x, y, cardW, cardH, method.name, method.hint, '', selected);
            clickables.push({ ...method, bounds: [x, y, cardW, cardH], action: 'selectMethod' });
        });

        // 3) ë¬¸ì¥ ë§Œë“¤ê¸° ë²„íŠ¼
        const canGenerate = selectedItem && selectedMethod && VALID[selectedItem.id]?.includes(selectedMethod.id);
        const isDisabled = !canGenerate;

        if (selectedItem && selectedMethod && !canGenerate) {
            errorMessage = "ì´ ì¡°í•©ì€ ì–´ìƒ‰í•´ìš”. ë‹¤ë¥¸ ë°©ë²•ì„ ê³¨ë¼ë³´ì„¸ìš”.";
        }

        const btnW = 200;
        const btnX = (canvas.width - btnW) / 2;
        const btnY = 600; // ë²„íŠ¼ ìœ„ì¹˜ í•˜ë‹¨ ê³ ì •

        drawButton(btnX, btnY, btnW, 50, "ë¬¸ì¥ ë§Œë“¤ê¸°", isDisabled);
        clickables.push({ bounds: [btnX, btnY, btnW, 50], action: 'generateMiddle', disabled: isDisabled });
    }

    function drawFinished() {
        drawTitle("ğŸ‰ ì™„ì„±! ë‚˜ì˜ ì‚¬ë¬¼í•¨ ì •ë¦¬ ê¸€");

        const composition = buildComposition();

        // ì™„ì„±ëœ ê¸€ ê·¸ë¦¬ê¸°
        ctx.save();
        ctx.fillStyle = '#f8fafc'; // slate-50
        ctx.strokeStyle = '#e2e8f0'; // slate-200
        ctx.lineWidth = 1;
        ctx.roundRect(20, 80, canvas.width - 40, canvas.height - 200, 12);
        ctx.fill();
        ctx.stroke();
        ctx.restore();

        drawMultiLineText(composition, 40, 120, 32);

        // ë²„íŠ¼ ê·¸ë¦¬ê¸°
        const btnW = 220; // ë²„íŠ¼ í…ìŠ¤íŠ¸ ê¸¸ì–´ì§
        const btnH = 50;
        const btnY = canvas.height - 100;
        const btn1X = (canvas.width / 2) - btnW - 10;
        const btn2X = (canvas.width / 2) + 10;

        drawButton(btn1X, btnY, btnW, btnH, "ê¸€ ë³µì‚¬í•˜ê¸°");
        drawButton(btn2X, btnY, btnW, btnH, "íŒ¨ë“¤ë ›ì— ë‚´ë³´ë‚´ê¸°");

        clickables = [
            { bounds: [btn1X, btnY, btnW, btnH], action: 'copyText' },
            { bounds: [btn2X, btnY, btnW, btnH], action: 'exportToPadlet' }
        ];
    }

    // ===== ë©”ì¸ ê·¸ë¦¬ê¸° í•¨ìˆ˜ =====
    function draw() {
        // ìº”ë²„ìŠ¤ ì§€ìš°ê¸° (ì—ëŸ¬ ë©”ì‹œì§€ ì˜ì—­ ì œì™¸)
        ctx.clearRect(0, 0, canvas.width, canvas.height - 40);

        // ì—ëŸ¬ ë©”ì‹œì§€ ì´ˆê¸°í™” (ê·¸ë¦¬ê¸° ì „ì—)
        let lastErrorMessage = errorMessage;
        errorMessage = "";

        if (phase === 'start') {
            drawStart();
        } else if (phase === 'middle') {
            drawMiddle();
        } else if (phase === 'finished') {
            // finished ë‹¨ê³„ì—ì„œëŠ” ë³µì‚¬ ë©”ì‹œì§€ë¥¼ ìœ ì§€í•´ì•¼ í•¨
            if (lastErrorMessage === "copied") errorMessage = "copied";
            drawFinished();
        }

        // ì—ëŸ¬ ë©”ì‹œì§€ ì˜ì—­ ì§€ìš°ê³  ìƒˆë¡œ ê·¸ë¦¬ê¸°
        ctx.clearRect(0, canvas.height - 40, canvas.width, 40);
        drawError();
        updateProgressUI(); // HTML ì§„í–‰ë„ ì—…ë°ì´íŠ¸
    }

    // ===== ì§„í–‰ë„ UI ì—…ë°ì´íŠ¸ =====
    function updateProgressUI() {
        const currentRound = acceptedSentences.length + 1;
        const isFinished = phase === 'finished';

        const displayRound = isFinished ? TOTAL_ROUNDS : currentRound;
        const pct = isFinished ? 100 : Math.round(((currentRound - 1) / TOTAL_ROUNDS) * 100);

        progressTextEl.innerText = `ë‹¨ê³„ ${displayRound} / ${TOTAL_ROUNDS}`;
        progressPctEl.innerText = `${pct}%`;
        progressBarEl.style.width = `${pct}%`;
    }

    // ===== í´ë¦­ í•¸ë“¤ëŸ¬ =====
    function handleClick(event) {
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        const x = (event.clientX - rect.left) * scaleX;
        const y = (event.clientY - rect.top) * scaleY;

        let needsRedraw = false;
        let asyncAction = false; // ë³µì‚¬/ë‚´ë³´ë‚´ê¸° ê°™ì€ ë¹„ë™ê¸° ì•¡ì…˜ í”Œë˜ê·¸

        for (const item of clickables) {
            const [bx, by, bw, bh] = item.bounds;
            if (x >= bx && x <= bx + bw && y >= by && y <= by + bh) {
                if (item.disabled) continue;

                if (item.action === 'selectLocker') {
                    if (item.type === 'bad') {
                        errorMessage = "ì´ê±´ ì •ë¦¬ì˜ ì¢‹ì€ ì ì´ ì•„ë‹Œ ê²ƒ ê°™ì•„ìš”. ë‹¤ì‹œ ê³¨ë¼ë³´ì„¸ìš”!";
                    } else {
                        if (selectedLockerIds.includes(item.id)) {
                            selectedLockerIds = selectedLockerIds.filter(id => id !== item.id);
                        } else {
                            selectedLockerIds.push(item.id);
                        }
                    }
                    needsRedraw = true;
                }

                else if (item.action === 'completeStart') {
                    const sentence = makeStartSentence();
                    acceptedSentences.push(sentence);
                    phase = 'middle';
                    needsRedraw = true;
                }

                else if (item.action === 'selectItem') {
                    selectedItem = item;
                    needsRedraw = true;
                }

                else if (item.action === 'selectMethod') {
                    selectedMethod = item;
                    needsRedraw = true;
                }

                else if (item.action === 'generateMiddle') {
                    generatedSentence = makeMiddleSentence(selectedItem, selectedMethod);
                    needsRedraw = true;
                }

                else if (item.action === 'completeMiddle') {
                    acceptedSentences.push(generatedSentence);
                    usedItemIds.push(selectedItem.id);

                    selectedItem = null;
                    selectedMethod = null;
                    generatedSentence = "";

                    if (acceptedSentences.length >= TOTAL_ROUNDS) {
                        phase = 'finished';
                    }
                    needsRedraw = true;
                }

                // --- 'ë' íŒŒíŠ¸ ì•¡ì…˜ ---
                else if (item.action === 'copyText') {
                    asyncAction = true;
                    const composition = buildComposition();
                    navigator.clipboard.writeText(composition).then(() => {
                        errorMessage = "copied";
                        draw(); // í”„ë¼ë¯¸ìŠ¤ ì•ˆì—ì„œ ë‹¤ì‹œ ê·¸ë¦¬ê¸°
                    }).catch(err => {
                        console.error("ë³µì‚¬ ì‹¤íŒ¨:", err);
                        errorMessage = "copyFailed";
                        draw();
                    });
                }

                else if (item.action === 'exportToPadlet') {
                    asyncAction = true;
                    const composition = buildComposition();
                    navigator.clipboard.writeText(composition).then(() => {
                        errorMessage = "copied";
                        window.open(PADLET_URL, '_blank'); // íŒ¨ë“¤ë › ì—´ê¸°
                        draw(); // í”„ë¼ë¯¸ìŠ¤ ì•ˆì—ì„œ ë‹¤ì‹œ ê·¸ë¦¬ê¸°
                    }).catch(err => {
                        console.error("ë³µì‚¬ ì‹¤íŒ¨:", err);
                        errorMessage = "copyFailed";
                        draw();
                    });
                }

                break;
            }
        }

        if (needsRedraw && !asyncAction) {
            draw();
        }
    }

    // ===== ê²Œì„ ì‹œì‘ ë° ë¦¬ì…‹ =====
    function restartGame() {
        phase = 'start';
        acceptedSentences = [];
        usedItemIds = [];
        selectedLockerIds = [];
        selectedItem = null;
        selectedMethod = null;
        generatedSentence = "";
        errorMessage = "";
        clickables = [];
        draw();
    }

    // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì—°ê²°
    canvas.addEventListener('click', handleClick);
    restartButton.addEventListener('click', restartGame);

    // ê²Œì„ ì‹œì‘
    draw();
</script>
</body>
</html>

