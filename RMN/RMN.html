<script>
    // --- 1. DOM 요소 ---
    const gameContainer = document.getElementById('game-container');
    const promptArea = document.getElementById('prompt-area');
    const playArea = document.getElementById('play-area');
    const judgmentLine = document.getElementById('judgment-line');
    const feedbackArea = document.getElementById('feedback-area');
    const stageDisplay = document.getElementById('stage-display');

    const keyQ = document.getElementById('key-q');
    const keyW = document.getElementById('key-w');
    const keyEWrapper = document.getElementById('key-e-wrapper');

    const scoreDisplay = document.getElementById('score-display');
    const comboDisplay = document.getElementById('combo-display');

    const memoryModeCheck = document.getElementById('memory-mode-check');

    const startScreen = document.getElementById('start-screen');
    const resultsScreen = document.getElementById('results-screen');

    // --- 2. 오디오 설정 ---
    let audioCtx;

    function playSound(noteTypeKey, durationMs) {
        if (!audioCtx) return;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();

        let freq = 261.63;
        if (noteTypeKey === 'w') freq = 329.63;
        if (noteTypeKey === 'e') freq = 392.0;

        osc.type = 'sine';
        osc.frequency.setValueAtTime(freq, audioCtx.currentTime);

        gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + durationMs / 1000);

        osc.connect(gain);
        gain.connect(audioCtx.destination);

        osc.start();
        osc.stop(audioCtx.currentTime + durationMs / 1000);
    }

    // 입력 피드백용 (soft / loud)
    function playHitSound(noteTypeKey, soft = false) {
        if (!audioCtx) return;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        let freq = 261.63;
        if (noteTypeKey === 'w') freq = 329.63;
        if (noteTypeKey === 'e') freq = 392.0;

        osc.type = 'triangle';
        const now = audioCtx.currentTime;
        const startGain = soft ? 0.15 : 0.4;
        const dur = 0.15;

        gain.gain.setValueAtTime(startGain, now);
        gain.gain.exponentialRampToValueAtTime(0.001, now + dur);

        osc.frequency.setValueAtTime(freq, now);
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start(now);
        osc.stop(now + dur);
    }

    // --- 3. 게임 상수 ---
    const BPM = 100;
    const BEAT_DURATION = 60000 / BPM; // 4분음표 = 600ms

    const ASSET_PATH = 'https://unluckyidiot16.github.io/assets-common/RMN/';

    const NOTE_TYPES = {
        q: { duration: BEAT_DURATION * 2, img: ASSET_PATH + 'note2.png', key: 'q', name: '2분음표' },
        w: { duration: BEAT_DURATION, img: ASSET_PATH + 'note4.png', key: 'w', name: '4분음표' },
        e: { duration: BEAT_DURATION / 2, img: ASSET_PATH + 'note8.png', key: 'e', name: '8분음표' }
    };

    // ★ 리듬 히어로식 비대칭 창
    const JUDGMENT_WINDOWS = {
        PERFECT_EARLY: 120,  // 0.12초 일찍
        PERFECT_LATE: 150,   // 0.15초 늦게
        GOOD_EARLY: 250,     // 0.25초 일찍
        GOOD_LATE: 300       // 0.30초 늦게
    };

    const STAGES = [
        ['q', 'q'],
        ['w', 'w', 'w', 'w'],
        ['q', 'w', 'q', 'w'],
        ['w', 'w', 'q', 'w', 'w', 'q'],
        ['e', 'e', 'e', 'e', 'w', 'w'],
        ['w', 'e', 'e', 'w', 'e', 'e'],
        ['q', 'w', 'e', 'e', 'q', 'w', 'e', 'e']
    ];

    const SCROLL_DURATION_MS = 3000;

    // --- 4. 상태 ---
    let gameState = 'MENU';
    let currentStage = 0;
    let currentLevelPattern = [];
    let activeNotes = [];
    let gameStartTime = 0;
    let animationFrameId = null;

    let score = 0;
    let combo = 0;
    let maxCombo = 0;
    let perfectCount = 0;
    let goodCount = 0;
    let missCount = 0;
    let totalNotes = 0;
    let noteStats = { q: { late: 0, early: 0 }, w: { late: 0, early: 0 }, e: { late: 0, early: 0 } };


    // --- 5. 게임 흐름 ---
    function startGame() {
        if (!audioCtx) {
            try {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            } catch (e) {
                alert('오디오를 지원하지 않는 브라우저입니다.');
                return;
            }
        }
        if (audioCtx.state === 'suspended') {
            audioCtx.resume();
        }

        startScreen.classList.add('hidden');
        resultsScreen.classList.add('hidden');
        resetGameStats();
        currentStage = 0;
        loadStage(0);
    }

    function updateKeyUI(stageIndex) {
        const pattern = STAGES[stageIndex];
        if (pattern.includes('e')) keyEWrapper.classList.remove('hidden');
        else keyEWrapper.classList.add('hidden');
    }

    function loadStage(stageIndex) {
        if (stageIndex >= STAGES.length) {
            showFinalResults();
            return;
        }
        gameState = 'READY';
        currentStage = stageIndex;
        currentLevelPattern = STAGES[stageIndex];

        stageDisplay.textContent = `Stage ${currentStage + 1}`;
        updateKeyUI(stageIndex);
        resetStage();

        showJudgmentFeedback(`Stage ${currentStage + 1}`, 1500);
        setTimeout(startPrompt, 1500);
    }

    function resetGameStats() {
        score = 0;
        combo = 0;
        maxCombo = 0;
        perfectCount = 0;
        goodCount = 0;
        missCount = 0;
        totalNotes = 0;
        noteStats = { q: { late: 0, early: 0 }, w: { late: 0, early: 0 }, e: { late: 0, early: 0 } };
        scoreDisplay.textContent = '0';
        comboDisplay.textContent = '0';
    }

    function resetStage() {
        activeNotes = [];
        playArea.querySelectorAll('.scrolling-note').forEach(n => n.remove());
    }

    async function startPrompt() {
        gameState = 'PROMPT';
        promptArea.innerHTML = '';

        const noteIcons = currentLevelPattern.map(noteKey => {
            const noteType = NOTE_TYPES[noteKey];
            const el = document.createElement('div');
            el.className = 'prompt-note';
            const img = document.createElement('img');
            img.src = noteType.img;
            el.appendChild(img);
            promptArea.appendChild(el);
            return el;
        });

        await new Promise(r => setTimeout(r, 1000));

        for (let i = 0; i < currentLevelPattern.length; i++) {
            const key = currentLevelPattern[i];
            const type = NOTE_TYPES[key];
            noteIcons[i].classList.add('active');
            playSound(key, type.duration);
            await new Promise(r => setTimeout(r, type.duration));
            noteIcons[i].classList.remove('active');
            noteIcons[i].style.opacity = '0.6';
        }

        showReady();
    }

    function showReady() {
        gameState = 'READY';
        showJudgmentFeedback('따라해보세요!', 1200);
        setTimeout(startPlay, 1200);
    }

    function startPlay() {
        gameState = 'PLAY';
        gameStartTime = performance.now();
        let cum = 0;
        const isMemoryMode = memoryModeCheck.checked;

        totalNotes += currentLevelPattern.length;

        currentLevelPattern.forEach((noteKey, idx) => {
            const def = NOTE_TYPES[noteKey];
            const hitTime = gameStartTime + cum + SCROLL_DURATION_MS;

            const el = document.createElement('div');
            el.className = 'scrolling-note';
            el.style.left = '100%';
            const img = document.createElement('img');
            img.src = def.img;
            el.appendChild(img);

            if (isMemoryMode) el.style.opacity = '0';

            // ★ 여기서 히어로식 입력창을 미리 박아둠
            const windowStart = hitTime - JUDGMENT_WINDOWS.GOOD_EARLY;
            const windowEnd = hitTime + JUDGMENT_WINDOWS.GOOD_LATE;

            el.dataset.hitTime = hitTime;
            el.dataset.key = noteKey;
            el.dataset.duration = def.duration;
            el.dataset.id = idx;
            el.dataset.judgedTime = 'false';
            el.dataset.windowStart = windowStart;
            el.dataset.windowEnd = windowEnd;

            playArea.appendChild(el);
            activeNotes.push(el);

            cum += def.duration;
        });

        if (animationFrameId) cancelAnimationFrame(animationFrameId);
        animationFrameId = requestAnimationFrame(gameLoop);
    }

    // --- 6. 루프 & MISS ---
    function gameLoop(now) {
        if (gameState !== 'PLAY') return;

        activeNotes.forEach(note => {
            if (note.dataset.judgedTime !== 'false') return;
            const hitTime = parseFloat(note.dataset.hitTime);
            const timeToHit = hitTime - now;

            const percent = 1 - (timeToHit / SCROLL_DURATION_MS);
            const currentLeftPercent = 100 - percent * 80;
            note.style.left = `${currentLeftPercent}%`;

            // 창이 완전히 지나갔으면 MISS
            const windowEnd = parseFloat(note.dataset.windowEnd);
            if (now > windowEnd && note.dataset.judgedTime === 'false') {
                judge(note, 'MISS');
            }
        });

        if (activeNotes.length === 0 && gameState === 'PLAY') {
            gameState = 'READY';
            setTimeout(advanceToNextStage, 1000);
            return;
        }

        animationFrameId = requestAnimationFrame(gameLoop);
    }

    function advanceToNextStage() {
        showJudgmentFeedback(`Stage ${currentStage + 1} Clear!`, 1600);
        setTimeout(() => loadStage(currentStage + 1), 1600);
    }

    // --- 7. 판정 ---
    function judge(note, judgmentType) {
        if (!note || note.dataset.judgedTime !== 'false') return;
        note.dataset.judgedTime = 'true';

        if (judgmentType === 'MISS') {
            showJudgmentFeedback('Miss');
            combo = 0;
            missCount++;
            note.classList.add('note-miss');
            removeNoteFromScreen(note, 400);
        } else {
            const tag = judgmentType.split('_')[0]; // PERFECT or GOOD
            showJudgmentFeedback(tag);
            if (tag === 'PERFECT') {
                perfectCount++;
                score += 100;
            } else {
                goodCount++;
                score += 80;
            }
            combo++;
            if (combo > maxCombo) maxCombo = combo;
            note.classList.add('note-pop');
            removeNoteFromScreen(note, 150);
        }

        scoreDisplay.textContent = score;
        comboDisplay.textContent = combo;
    }

    function showJudgmentFeedback(text, duration = 600) {
        const fb = document.createElement('div');
        fb.className = 'feedback-popup';
        fb.textContent = text;

        if (text.includes('Stage')) fb.style.color = '#00ffff';
        else if (text === 'PERFECT') fb.style.color = '#4ade80';
        else if (text === 'GOOD') fb.style.color = '#facc15';
        else if (text === 'Miss') fb.style.color = '#f87171';

        feedbackArea.appendChild(fb);
        setTimeout(() => fb.remove(), duration);
    }

    function removeNoteFromScreen(note, delay) {
        activeNotes = activeNotes.filter(n => n !== note);
        setTimeout(() => {
            if (note.parentNode) note.parentNode.removeChild(note);
        }, delay);
    }

    function showFinalResults() {
        gameState = 'RESULTS';
        if (animationFrameId) cancelAnimationFrame(animationFrameId);
        const acc = totalNotes > 0 ? ((perfectCount + goodCount) / totalNotes) * 100 : 0;

        document.getElementById('final-score').textContent = score;
        document.getElementById('accuracy').textContent = acc.toFixed(1) + '%';
        document.getElementById('max-combo').textContent = maxCombo;
        document.getElementById('perfect-count').textContent = perfectCount;
        document.getElementById('good-count').textContent = goodCount;
        document.getElementById('miss-count').textContent = missCount;

        let msg = '연습이 조금 더 필요해요!';
        if (acc > 95) msg = '완벽한 리듬감이에요!';
        else if (acc > 80) msg = '훌륭해요! 조금만 더!';

        document.getElementById('feedback-message').textContent = msg;
        resultsScreen.classList.remove('hidden');
        resultsScreen.classList.add('flex');
    }

    function restartGame() {
        resultsScreen.classList.add('hidden');
        startScreen.classList.remove('hidden');
        stageDisplay.textContent = '';
        promptArea.innerHTML = '<p class="text-gray-400">게임을 시작하세요!</p>';
        resetGameStats();
        updateKeyUI(0);
    }

    // --- 8. 입력 처리 (여기에 히어로식 핵심 있음) ---
    function handleKeyDown(e) {
        // 오디오 깨우기
        if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume();

        const key = e.key ? e.key.toLowerCase() : null;
        if (!['q', 'w', 'e'].includes(key)) return;
        if (key === 'e' && keyEWrapper.classList.contains('hidden')) return;

        // UI 눌림
        const kbd = document.getElementById(`key-${key}`);
        if (kbd) kbd.classList.add('active');

        // 아무 때나 누르면 작은 소리
        playHitSound(key, true);

        if (gameState !== 'PLAY') return;

        const now = performance.now();

        // ★ 1) 이 키이고
        // ★ 2) 아직 판정 안됐고
        // ★ 3) 지금 시간이 그 노트의 windowStart~windowEnd 안인 노트만 본다
        const candidates = activeNotes.filter(n => {
            return (
                n.dataset.key === key &&
                n.dataset.judgedTime === 'false' &&
                now >= parseFloat(n.dataset.windowStart) &&
                now <= parseFloat(n.dataset.windowEnd)
            );
        });

        if (candidates.length === 0) {
            // 창 밖이면 그냥 무시 (미스는 루프에서)
            return;
        }

        // 가장 먼저 온 노트(=가장 왼쪽/가장 앞 타이밍)만 처리
        const note = candidates[0];
        const hitTime = parseFloat(note.dataset.hitTime);
        const diff = now - hitTime; // +면 늦음, -면 빠름

        // ★ 히어로식 세분화
        if (diff >= -JUDGMENT_WINDOWS.PERFECT_EARLY && diff <= JUDGMENT_WINDOWS.PERFECT_LATE) {
            playHitSound(key, false);
            judge(note, 'PERFECT_TIME');
        } else {
            playHitSound(key, false);
            judge(note, 'GOOD_TIME');
        }

        // 오차 기록
        if (diff < 0) noteStats[key].early++;
        else noteStats[key].late++;
    }

    function handleKeyUp(e) {
        const key = e.key ? e.key.toLowerCase() : null;
        if (!['q', 'w', 'e'].includes(key)) return;
        const kbd = document.getElementById(`key-${key}`);
        if (kbd) kbd.classList.remove('active');
    }

    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);

    // 터치
    document.getElementById('key-q').addEventListener('touchstart', e => { e.preventDefault(); handleKeyDown({ key: 'q' }); });
    document.getElementById('key-q').addEventListener('touchend', e => { e.preventDefault(); handleKeyUp({ key: 'q' }); });
    document.getElementById('key-w').addEventListener('touchstart', e => { e.preventDefault(); handleKeyDown({ key: 'w' }); });
    document.getElementById('key-w').addEventListener('touchend', e => { e.preventDefault(); handleKeyUp({ key: 'w' }); });
    document.getElementById('key-e').addEventListener('touchstart', e => { e.preventDefault(); handleKeyDown({ key: 'e' }); });
    document.getElementById('key-e').addEventListener('touchend', e => { e.preventDefault(); handleKeyUp({ key: 'e' }); });

</script>
