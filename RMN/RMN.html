<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rhythm Memory Note - Easy Mode</title>

    <!-- Tailwind CSS 로드 -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Inter 폰트 로드 -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">

    <style>
        body {
            font-family: 'Inter', sans-serif;
            -webkit-user-select: none; /* Safari */
            -ms-user-select: none; /* IE 10 and IE 11 */
            user-select: none; /* Standard syntax */
            overflow: hidden; /* 스크롤바 숨김 */
        }

        /* 게임 컨테이너 */
        #game-container {
            width: 100%;
            max-width: 600px;
            height: 600px;
        }

        /* 플레이 트랙 */
        #play-area {
            position: relative;
            height: 200px;
            background-color: #1a202c; /* bg-gray-900 */
            overflow: hidden;
            border-radius: 0.5rem;
            border: 2px solid #4a5568; /* border-gray-600 */
        }

        /* 판정선 */
        #judgment-line {
            position: absolute;
            left: 20%;
            top: 0;
            bottom: 0;
            width: 4px;
            background-color: #00ffff; /* Cyan */
            box-shadow: 0 0 10px #00ffff, 0 0 20px #00ffff;
            z-index: 10;
        }

        /* 스크롤되는 음표 (막대기 -> 이미지 컨테이너로 변경) */
        .scrolling-note {
            position: absolute;
            left: 100%; /* 오른쪽 바깥에서 시작 */
            top: 50%;
            transform: translateY(-50%);
            z-index: 5;
            transition: filter 0.2s, opacity 0.2s, transform 0.2s;
        }
        .scrolling-note img {
            width: 60px; /* 음표 이미지 크기 고정 */
            height: 60px;
            object-fit: contain;
        }

        /* [수정] 성공 시 팝! 효과 */
        .note-pop {
            animation: pop-out 0.2s ease-out forwards;
        }
        @keyframes pop-out {
            from {
                transform: translateY(-50%) scale(1);
                opacity: 1;
            }
            to {
                transform: translateY(-50%) scale(1.5);
                opacity: 0;
            }
        }

        /* [수정] 실패 시 어두워지는 효과 */
        .note-miss {
            filter: grayscale(100%) brightness(0.5);
            opacity: 0.7;
        }


        /* 프롬프트 영역의 귀여운 음표 아이콘 */
        .prompt-note {
            width: 60px; /* 이미지 크기에 맞춰 조정 */
            height: 60px;
            border-radius: 0.375rem;
            display: flex;
            align-items: center;
            justify: center;
            font-weight: bold;
            color: white;
            transition: all 0.2s ease;
            border: 2px solid transparent;
        }
        .prompt-note img {
            height: 100%;
            width: auto;
            object-fit: contain;
        }

        .prompt-note.active {
            transform: scale(1.2);
            border-color: #00ffff;
            box-shadow: 0 0 10px #00ffff;
        }

        /* 키 힌트 (KBD 태그) */
        kbd {
            min-width: 60px;
            height: 60px;
            display: inline-flex;
            align-items: center;
            justify: center;
            border-radius: 0.5rem;
            background-color: #4a5568; /* bg-gray-600 */
            color: white;
            border: 2px solid #718096; /* bg-gray-500 */
            border-bottom-width: 4px;
            font-size: 1.25rem;
            font-weight: bold;
            transition: all 0.05s ease;
        }

        kbd.active {
            transform: translateY(2px);
            border-bottom-width: 2px;
            background-color: #718096; /* bg-gray-500 */
        }

        /* 판정 피드백 텍스트 */
        #feedback-area {
            position: absolute;
            left: 20%;
            top: 20%;
            transform: translateX(-50%);
            z-index: 20;
            pointer-events: none;
        }

        .feedback-popup {
            font-size: 2.5rem;
            font-weight: bold;
            color: white;
            text-shadow: 0 0 10px black;
            animation: fadeUp 0.6s ease-out forwards;
        }

        @keyframes fadeUp {
            from {
                opacity: 1;
                transform: translateY(0);
            }
            to {
                opacity: 0;
                transform: translateY(-50px);
            }
        }

        /* 모달 (시작/결과 화면) */
        .modal {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(17, 24, 39, 0.9); /* bg-gray-900/90 */
            z-index: 50;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-100 flex items-center justify-center min-h-screen">

<div id="game-container" class="bg-gray-800 p-4 md:p-6 rounded-lg shadow-2xl flex flex-col gap-4">

    <!-- 상단: 헤더 -->
    <div class="text-center">
        <h1 class="text-2xl font-bold text-white mb-1">리듬 메모리 노트</h1>
        <!-- [수정] 스테이지 표시기 -->
        <h2 id="stage-display" class="text-xl font-bold text-cyan-400"></h2>
    </div>

    <!-- 프롬프트 영역 -->
    <div id="prompt-area" class="h-20 bg-gray-700 rounded-lg p-3 flex items-center justify-center gap-2">
        <!-- 음표 아이콘이 여기에 동적으로 생성됩니다 -->
        <p class="text-gray-400">게임을 시작하세요!</p>
    </div>

    <!-- 플레이 트랙 -->
    <div id="play-area">
        <div id="judgment-line"></div>
        <div id="feedback-area"></div>
        <!-- 스크롤링 노트가 여기에 동적으로 생성됩니다 -->
    </div>

    <!-- 하단: 키 힌트 -->
    <div id="key-hints" class="flex justify-center gap-4 p-4 bg-gray-700 rounded-lg">
        <div class="text-center">
            <kbd id="key-q" class="bg-red-500">Q</kbd>
            <!-- [수정] 길이 설명 제거 -->
            <span class="block text-sm mt-1">2분음표</span>
        </div>
        <div class="text-center">
            <kbd id="key-w" class="bg-orange-500">W</kbd>
            <!-- [수정] 길이 설명 제거 -->
            <span class="block text-sm mt-1">4분음표</span>
        </div>
    </div>

    <!-- 점수판 -->
    <div class="flex justify-between text-xl font-bold">
        <div>Score: <span id="score-display">0</span></div>
        <div>Combo: <span id="combo-display">0</span></div>
    </div>

    <!-- 청음 모드 옵션 -->
    <div class="flex items-center justify-center gap-2">
        <input type="checkbox" id="memory-mode-check" class="form-checkbox h-5 w-5 text-cyan-400 bg-gray-800 border-gray-600 rounded focus:ring-cyan-500">
        <label for="memory-mode-check" class="text-white">청음(기억) 모드 (노트 숨김)</label>
    </div>
</div>

<!-- [수정] 시작 화면 모달 (스테이지 선택 -> 시작 버튼) -->
<div id="start-screen" class="modal flex flex-col items-center justify-center p-8 gap-4">
    <h2 class="text-3xl font-bold text-white mb-4">리듬 메모리 노트</h2>
    <p class="text-lg text-gray-300 mb-6 text-center">3학년 눈높이! 박자를 기억하는 게임</p>
    <button onclick="startGame()" class="w-full max-w-xs text-lg bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-6 rounded-lg transition duration-200">
        게임 시작!
    </button>
    <p class="text-gray-400 mt-6 text-center">키보드 Q (2분), W (4분) 키를 사용합니다.</p>
</div>

<!-- 결과 화면 모달 -->
<div id="results-screen" class="modal flex-col items-center justify-center p-8 gap-4 hidden">
    <h2 class="text-3xl font-bold text-white mb-4">모든 스테이지 클리어!</h2>
    <div class="text-xl text-gray-200">최종 점수: <span id="final-score" class="font-bold text-cyan-400">0</span></div>
    <div class="text-lg text-gray-300">정확도: <span id="accuracy" class="font-bold">0%</span></div>
    <div class="text-lg text-gray-300">최대 콤보: <span id="max-combo" class="font-bold">0</span></div>
    <hr class="w-full max-w-xs my-4 border-gray-600">
    <div class="flex gap-4">
        <div class="text-center">
            <div class="text-2xl font-bold text-green-400" id="perfect-count">0</div>
            <div class="text-sm">PERFECT</div>
        </div>
        <div class="text-center">
            <div class="text-2xl font-bold text-yellow-400" id="good-count">0</div>
            <div class="text-sm">GOOD</div>
        </div>
        <div class="text-center">
            <div class="text-2xl font-bold text-red-400" id="miss-count">0</div>
            <div class="text-sm">MISS</div>
        </div>
    </div>
    <div id="feedback-message" class="text-lg text-yellow-300 mt-4 text-center"></div>
    <button onclick="restartGame()" class="w-full max-w-xs text-lg bg-cyan-500 hover:bg-cyan-600 text-white font-bold py-3 px-6 rounded-lg transition duration-200 mt-6">
        처음부터 다시하기
    </button>
</div>


<script>
    // --- 1. DOM 요소 ---
    const gameContainer = document.getElementById('game-container');
    const promptArea = document.getElementById('prompt-area');
    const playArea = document.getElementById('play-area');
    const judgmentLine = document.getElementById('judgment-line');
    const feedbackArea = document.getElementById('feedback-area');
    const stageDisplay = document.getElementById('stage-display');

    const keyQ = document.getElementById('key-q');
    const keyW = document.getElementById('key-w');

    const scoreDisplay = document.getElementById('score-display');
    const comboDisplay = document.getElementById('combo-display');

    const memoryModeCheck = document.getElementById('memory-mode-check');

    const startScreen = document.getElementById('start-screen');
    const resultsScreen = document.getElementById('results-screen');

    // --- 2. 오디오 설정 ---
    let audioCtx;
    try {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    } catch (e) {
        console.error('Web Audio API is not supported in this browser');
        alert('이 브라우저에서는 오디오를 지원하지 않습니다. 게임 플레이가 불가능합니다.');
    }

    function playSound(noteTypeKey, durationMs) {
        if (!audioCtx) return;

        const oscillator = audioCtx.createOscillator();
        const gainNode = audioCtx.createGain();

        let freq = 261.63; // C4
        if (noteTypeKey === 'q') freq = 261.63; // C4 (낮은 톤)
        if (noteTypeKey === 'w') freq = 329.63; // E4 (중간 톤)

        oscillator.type = 'sine';
        oscillator.frequency.setValueAtTime(freq, audioCtx.currentTime);

        gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + (durationMs / 1000));

        oscillator.connect(gainNode);
        gainNode.connect(audioCtx.destination);

        oscillator.start(audioCtx.currentTime);
        oscillator.stop(audioCtx.currentTime + (durationMs / 1000));
    }

    // --- 3. 게임 상수 ---
    const BPM = 100;
    const BEAT_DURATION = 60000 / BPM; // 4분음표 길이 (600ms)

    const ASSET_PATH = 'https://unluckyidiot16.github.io/assets-common/RMN/';

    const NOTE_TYPES = {
        'q': { duration: BEAT_DURATION * 2, img: ASSET_PATH + 'note2.png', key: 'q', name: '2분음표' }, // 2분음표
        'w': { duration: BEAT_DURATION, img: ASSET_PATH + 'note4.png', key: 'w', name: '4분음표' }, // 4분음표
    };

    // 판정 범위 (ms) - [수정] 길이 판정 제거
    const JUDGMENT_WINDOWS = {
        PERFECT: 80,
        GOOD: 150,
    };

    // [수정] STAGES (레벨 -> 스테이지)
    const STAGES = [
        ['q', 'q'], // 1단계: 2분음표 2개
        ['w', 'w', 'w', 'w'], // 2단계: 4분음표 4개
        ['q', 'w', 'q', 'w'], // 3단계: 섞기 1
        ['w', 'w', 'q', 'w', 'w', 'q'], // 4단계: 섞기 2
        ['q', 'w', 'w', 'q', 'w', 'w', 'q', 'q'] // 5단계: 섞기 3
    ];

    const SCROLL_DURATION_MS = 3000;

    // --- 4. 게임 상태 변수 ---
    let gameState = 'MENU'; // MENU, PROMPT, READY, PLAY, RESULTS
    let currentStage = 0; // [수정]
    let currentLevelPattern = [];
    let activeNotes = [];
    // let playerInputs = {}; // [수정] 길이 판정 제거로 불필요
    let gameStartTime = 0;
    let animationFrameId = null;

    // 점수
    let score = 0;
    let combo = 0;
    let maxCombo = 0;
    let perfectCount = 0;
    let goodCount = 0;
    let missCount = 0;
    let totalNotes = 0;
    let noteStats = { q: { late: 0, early: 0 }, w: { late: 0, early: 0 }};

    // --- 5. 게임 흐름 함수 ---

    // [수정] 게임 시작 (버튼 클릭)
    function startGame() {
        if (audioCtx && audioCtx.state === 'suspended') {
            audioCtx.resume();
        }
        startScreen.classList.add('hidden');
        resultsScreen.classList.add('hidden');
        resetGameStats(); // 모든 점수 초기화
        currentStage = 0;
        loadStage(currentStage);
    }

    // [수정] 스테이지 로드
    function loadStage(stageIndex) {
        if (stageIndex >= STAGES.length) {
            showFinalResults(); // 모든 스테이지 클리어
            return;
        }

        gameState = 'READY';
        currentStage = stageIndex;
        currentLevelPattern = STAGES[stageIndex];

        stageDisplay.textContent = `Stage ${currentStage + 1}`;
        resetStage(); // 현재 스테이지 노트 초기화

        showJudgmentFeedback(`Stage ${currentStage + 1}`, 1500);
        setTimeout(startPrompt, 1500); // 1.5초 후 프롬프트 시작
    }

    // [수정] 전체 게임 통계 리셋
    function resetGameStats() {
        score = 0;
        combo = 0;
        maxCombo = 0;
        perfectCount = 0;
        goodCount = 0;
        missCount = 0;
        totalNotes = 0;
        noteStats = { q: { late: 0, early: 0 }, w: { late: 0, early: 0 } };
        scoreDisplay.textContent = '0';
        comboDisplay.textContent = '0';
    }

    // [수정] 현재 스테이지 리셋
    function resetStage() {
        activeNotes = [];
        playArea.innerHTML = '<div id="judgment-line"></div><div id="feedback-area"></div>';
    }

    // 5.3 STEP 1: 제시 (Listen)
    async function startPrompt() {
        gameState = 'PROMPT';
        promptArea.innerHTML = '';

        const noteIcons = currentLevelPattern.map(noteKey => {
            const noteType = NOTE_TYPES[noteKey];
            const icon = document.createElement('div');
            icon.className = 'prompt-note';
            const img = document.createElement('img');
            img.src = noteType.img;
            icon.appendChild(img);
            promptArea.appendChild(icon);
            return icon;
        });

        await new Promise(resolve => setTimeout(resolve, 1000));

        for (let i = 0; i < currentLevelPattern.length; i++) {
            const noteKey = currentLevelPattern[i];
            const noteType = NOTE_TYPES[noteKey];

            noteIcons[i].classList.add('active');
            playSound(noteKey, noteType.duration);

            await new Promise(resolve => setTimeout(resolve, noteType.duration));

            noteIcons[i].classList.remove('active');
            noteIcons[i].style.opacity = '0.6';
        }

        showReady();
    }

    // 5.4 STEP 2: 준비 (Ready)
    function showReady() {
        gameState = 'READY';
        showJudgmentFeedback('따라해보세요!', 1500);

        setTimeout(startPlay, 1500);
    }

    // 5.5 STEP 3: 재현 (Play)
    function startPlay() {
        gameState = 'PLAY';
        gameStartTime = performance.now();
        let cumulativeTime = 0;

        const isMemoryMode = memoryModeCheck.checked;
        totalNotes += currentLevelPattern.length; // [수정] 전체 노트 수 누적

        currentLevelPattern.forEach((noteKey, index) => {
            const noteType = NOTE_TYPES[noteKey];
            const hitTime = gameStartTime + cumulativeTime + SCROLL_DURATION_MS;

            // [수정] .scrolling-note 컨테이너 생성
            const noteEl = document.createElement('div');
            noteEl.className = `scrolling-note`;
            noteEl.style.left = '100%';

            // 이미지 추가
            const img = document.createElement('img');
            img.src = noteType.img;
            noteEl.appendChild(img);

            if (isMemoryMode) {
                noteEl.style.opacity = '0';
            }

            noteEl.dataset.hitTime = hitTime;
            noteEl.dataset.key = noteKey;
            noteEl.dataset.duration = noteType.duration;
            noteEl.dataset.id = index;
            noteEl.dataset.judgedTime = 'false';
            // [수정] judgedLength 제거

            playArea.appendChild(noteEl);
            activeNotes.push(noteEl);

            cumulativeTime += noteType.duration;
        });

        if (animationFrameId) cancelAnimationFrame(animationFrameId);
        animationFrameId = requestAnimationFrame(gameLoop);
    }

    // --- 6. 게임 루프 및 판정 ---

    function gameLoop(now) {
        if (gameState !== 'PLAY') return;

        // 1. 노트 이동
        activeNotes.forEach(note => {
            // [수정] 이미 판정된(사라지는 중인) 노트는 이동시키지 않음
            if (note.dataset.judgedTime !== 'false') return;

            const hitTime = parseFloat(note.dataset.hitTime);
            const timeToHit = hitTime - now;

            const percentProgress = 1 - (timeToHit / SCROLL_DURATION_MS);
            const currentLeftPercent = 100 - (percentProgress * 80);
            note.style.left = `${currentLeftPercent}%`;

            // 2. 자동 Miss 판정
            if (timeToHit < -JUDGMENT_WINDOWS.GOOD && note.dataset.judgedTime === 'false') {
                judge(note, 'MISS');
            }
        });

        // 3. [수정] 스테이지 종료 체크
        if (activeNotes.length === 0 && gameState === 'PLAY') {
            gameState = 'READY'; // 루프 중복 실행 방지
            setTimeout(advanceToNextStage, 1000); // 1초 후 다음 스테이지로
            return;
        }

        if (gameState === 'PLAY') {
            animationFrameId = requestAnimationFrame(gameLoop);
        }
    }

    // [수정] 다음 스테이지 진행
    function advanceToNextStage() {
        showJudgmentFeedback(`Stage ${currentStage + 1} Clear!`, 2000);
        setTimeout(() => {
            loadStage(currentStage + 1); // 다음 스테이지 로드
        }, 2000);
    }

    // [수정] 판정 로직 (길이 판정 제거)
    function judge(note, judgmentType) {
        if (!note || note.dataset.judgedTime !== 'false') return; // 이미 판정된 노트 스킵

        note.dataset.judgedTime = 'true'; // 판정됨

        if (judgmentType.includes('TIME')) { // PERFECT 또는 GOOD
            showJudgmentFeedback(judgmentType.split('_')[0]);

            if (judgmentType === 'PERFECT_TIME') {
                perfectCount++;
                score += 100;
            } else {
                goodCount++;
                score += 80;
            }

            combo++;
            if (combo > maxCombo) maxCombo = combo;

            note.classList.add('note-pop'); // [수정] 팝! 효과
            removeNoteFromScreen(note, 200); // 0.2초 후 제거

        } else if (judgmentType === 'MISS') {
            showJudgmentFeedback('Miss');
            combo = 0;
            missCount++;

            note.classList.add('note-miss'); // [수정] 어둡게
            removeNoteFromScreen(note, 500); // 0.5초 후 제거
        }

        scoreDisplay.textContent = score;
        comboDisplay.textContent = combo;
    }

    // 판정 피드백 텍스트 표시
    function showJudgmentFeedback(text, duration = 600) {
        const feedback = document.createElement('div');
        feedback.className = 'feedback-popup';
        feedback.textContent = text;

        if (text.includes('Stage')) feedback.style.color = '#00ffff'; // Cyan
        else if (text === 'PERFECT') feedback.style.color = '#4ade80'; // green-400
        else if (text === 'GOOD') feedback.style.color = '#facc15'; // yellow-400
        else if (text === 'Miss') feedback.style.color = '#f87171'; // red-400

        feedbackArea.appendChild(feedback);
        setTimeout(() => {
            feedback.remove();
        }, duration);
    }

    // [수정] 노트 제거 (애니메이션 시간 고려)
    function removeNoteFromScreen(note, delay) {
        // 즉시 activeNotes 배열에서 제거 (논리적 제거)
        activeNotes = activeNotes.filter(n => n !== note);

        // delay 밀리초 후 DOM에서 제거 (시각적 제거)
        setTimeout(() => {
            if (note.parentNode) {
                note.parentNode.removeChild(note);
            }
        }, delay);
    }

    // 6.3 [수정] 최종 결과 표시
    function showFinalResults() {
        gameState = 'RESULTS';
        if (animationFrameId) cancelAnimationFrame(animationFrameId);

        const accuracy = totalNotes > 0 ? ((perfectCount + goodCount) / totalNotes) * 100 : 0;

        document.getElementById('final-score').textContent = score;
        document.getElementById('accuracy').textContent = `${accuracy.toFixed(1)}%`;
        document.getElementById('max-combo').textContent = maxCombo;
        document.getElementById('perfect-count').textContent = perfectCount;
        document.getElementById('good-count').textContent = goodCount;
        document.getElementById('miss-count').textContent = missCount;

        let feedbackMsg = "";
        if (accuracy > 95) feedbackMsg = "완벽한 리듬감이에요!";
        else if (accuracy > 80) feedbackMsg = "훌륭해요! 조금만 더!";
        else feedbackMsg = "연습이 조금 더 필요해요!";

        document.getElementById('feedback-message').textContent = feedbackMsg;

        resultsScreen.classList.remove('hidden');
        resultsScreen.classList.add('flex');
    }

    // 6.4 [수정] 처음부터 다시하기
    function restartGame() {
        resultsScreen.classList.add('hidden');
        startScreen.classList.remove('hidden');
        stageDisplay.textContent = '';
        promptArea.innerHTML = '<p class="text-gray-400">게임을 시작하세요!</p>';
        resetGameStats(); // 모든 점수 초기화
    }


    // --- 7. 입력 처리 (길이 판정 제거) ---

    // 키 누르기 (타이밍 판정)
    function handleKeyDown(e) {
        if (gameState !== 'PLAY') return;

        const key = e.key.toLowerCase();
        if (!['q', 'w'].includes(key)) {
            return;
        }

        document.getElementById(`key-${key}`).classList.add('active');

        const now = performance.now();

        // 가장 가까운, 판정되지 않은, 올바른 키의 노트를 찾음
        let closestNote = null;
        let minDiff = Infinity;

        for (const note of activeNotes) {
            if (note.dataset.key === key && note.dataset.judgedTime === 'false') {
                // [수정] 이미 지나간 노트는 판정하지 않음 (timeToHit < 0)
                const timeToHit = parseFloat(note.dataset.hitTime) - now;
                const diff = Math.abs(timeToHit);

                if (diff < minDiff && timeToHit < JUDGMENT_WINDOWS.GOOD) { // GOOD 창(150ms) 이내로 다가온 노트만
                    minDiff = diff;
                    closestNote = note;
                }
            }
        }

        if (closestNote && minDiff <= JUDGMENT_WINDOWS.GOOD) {
            // 타이밍 판정
            if (minDiff <= JUDGMENT_WINDOWS.PERFECT) {
                judge(closestNote, 'PERFECT_TIME');
            } else {
                judge(closestNote, 'GOOD_TIME');
            }

            // 오차 기록
            const error = parseFloat(closestNote.dataset.hitTime) - now;
            if (error < 0) noteStats[key].late++; // 늦게 누름
            else noteStats[key].early++; // 일찍 누름

        } else {
            // 허공에 누름 (Miss 아님, 그냥 무시)
        }
    }

    // 키 떼기
    function handleKeyUp(e) {
        const key = e.key.toLowerCase();
        if (!['q', 'w'].includes(key)) {
            return;
        }
        document.getElementById(`key-${key}`).classList.remove('active');

        // [수정] 길이 판정 로직 모두 제거
    }

    // --- 8. 이벤트 리스너 ---
    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);

    // 모바일 터치 지원 (간단하게)
    document.getElementById('key-q').addEventListener('touchstart', (e) => { e.preventDefault(); handleKeyDown({ key: 'q' }); });
    document.getElementById('key-q').addEventListener('touchend', (e) => { e.preventDefault(); handleKeyUp({ key: 'q' }); });
    document.getElementById('key-w').addEventListener('touchstart', (e) => { e.preventDefault(); handleKeyDown({ key: 'w' }); });
    document.getElementById('key-w').addEventListener('touchend', (e) => { e.preventDefault(); handleKeyUp({ key: 'w' }); });

</script>
</body>
</html>

