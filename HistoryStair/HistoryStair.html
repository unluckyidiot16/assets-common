<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>대각선 역사 계단</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Inter 폰트 적용 */
        body {
            font-family: "Inter", sans-serif;
            overscroll-behavior: none; /* 모바일에서 바운스 스크롤 방지 */
        }
        /* 캔버스 픽셀이 흐릿해지지 않도록 설정 */
        canvas {
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-crisp-edges;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            background-color: #f0f4f8; /* 캔버스 배경색 */
        }
        /* 게임 오버레이 */
        #game-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            text-align: center;
            transition: opacity 0.3s ease;
            z-index: 10;
        }
        #game-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .skin-item {
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            /* 레이아웃이 흔들리지 않도록 투명한 테두리 추가 */
            border: 4px solid transparent;
            /* --- 추가됨: 해금 안 된 스킨 처리 --- */
            position: relative;
            background-color: #f3f4f6; /* gray-100 */
        }
        .skin-item.locked {
            filter: grayscale(80%) brightness(0.8);
            cursor: not-allowed;
        }
        .skin-item.locked::after {
            content: '🔒';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 2.5rem;
            color: white;
            text-shadow: 0 0 5px black;
        }
        .skin-item img {
            width: 100%;
            height: 6rem; /* 96px */
            object-fit: contain;
            background-color: #e5e7eb; /* gray-200 */
            border-radius: 0.25rem; /* rounded */
        }
        .skin-item:hover {
            transform: scale(1.05);
        }
        /* --- 추가됨: 스킨 선택 하이라이트 --- */
        .skin-item.selected {
            border-color: #facc15; /* yellow-400 */
            transform: scale(1.05);
            box-shadow: 0 4px 10px rgba(250, 204, 21, 0.3);
        }
    </style>
</head>
<body class="bg-gray-100 flex flex-col md:flex-row h-screen overflow-hidden">

<!-- 왼쪽 사이드바: 시대 및 운송수단 정보 -->
<aside class="w-full md:w-1/4 bg-gray-800 text-white p-6 overflow-y-auto shadow-lg">
    <h1 class="text-3xl font-bold mb-6">역사 계단</h1>

    <!-- 현재 시대 -->
    <div class="mb-8">
        <h2 class="text-xl font-semibold mb-2">현재 시대</h2>
        <p id="year-display" class="text-4xl font-bold text-teal-300">1000년</p>
        <p class="text-gray-400">(점수: <span id="score-display">0</span>)</p>
    </div>

    <!-- 해금된 운송수단 -->
    <div>
        <h2 class="text-xl font-semibold mb-3">해금된 운송수단</h2>
        <ul id="unlocked-list" class="space-y-2">
            <!-- 자바스크립트로 추가됨 -->
        </ul>
    </div>
</aside>

<!-- 오른쪽 메인 게임 영역 -->
<main class="w-full md:w-3/4 h-full bg-gray-200 relative" id="game-container">
    <canvas id="gameCanvas"></canvas>

    <!-- 게임 오버레이 (시작/재시작) -->
    <div id="game-overlay" class="flex p-4">
        <h2 id="overlay-title" class="text-4xl font-bold mb-4">대각선 역사 계단</h2>
        <p id="overlay-score" class="text-2xl mb-6 hidden"></p>

        <!-- --- 수정됨: 스킨 선택 그리드를 메뉴에 직접 삽입 --- -->
        <h3 class="text-xl font-semibold mb-4 text-white">스킨 선택 (최고 점수: <span id="highest-score-display">0</span>)</h3>
        <div id="menu-skin-grid" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-4 p-4 w-full max-w-3xl max-h-[50vh] overflow-y-auto bg-gray-900/50 rounded-lg mb-6">
            <!-- 스킨 아이템이 여기에 동적으로 추가됩니다 -->
        </div>

        <button id="start-button" class="bg-teal-500 hover:bg-teal-600 text-white font-bold py-3 px-8 rounded-lg text-xl shadow-md transition-transform transform hover:scale-105 mb-4">
            게임 시작
        </button>
    </div>

</main>

<script>
    // --- DOM 요소 ---
    const gameContainer = document.getElementById('game-container');
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const yearDisplay = document.getElementById('year-display');
    const scoreDisplay = document.getElementById('score-display');
    const unlockedList = document.getElementById('unlocked-list');
    const overlay = document.getElementById('game-overlay');
    const overlayTitle = document.getElementById('overlay-title');
    const overlayScore = document.getElementById('overlay-score');
    const startButton = document.getElementById('start-button');
    const menuSkinGrid = document.getElementById('menu-skin-grid');
    const highestScoreDisplay = document.getElementById('highest-score-display');


    // --- 게임 설정 ---
    let gameStatus = 'menu'; // 'menu', 'playing', 'over'
    let score = 0;
    let currentYear = 1000;
    let highestScore = 0; // --- 추가됨: 최고 점수 ---

    // --- 플레이어 ---
    const player = {
        width: 40, // 이미지가 잘 보이도록 크기 조절
        height: 40,
        imageElement: null, // --- 추가됨: 플레이어 이미지 ---
        stairIndex: 0, // 현재 밟고 있는 계단 인덱스
        x: 0, // 플레이어의 '화면' X 좌표
        y: 0, // 플레이어의 '화면' Y 좌표 (고정됨)
    };

    // --- 계단 ---
    let stairs = [];
    const stairWidth = 80;
    const stairHeight = 20;
    const stepX = 50; // 대각선 X 간격
    const stepY = 30; // 대각선 Y 간격 (올라가는 높이)
    const totalStairsToGenerate = 50; // 미리 생성해 둘 계단 수

    // --- 카메라 (월드 오프셋) ---
    let worldY = 0;
    let targetWorldY = 0;
    const cameraLerpRate = 0.2;

    let targetPlayerX = 0;
    const playerLerpRate = 0.25;

    // --- 타이머 ---
    const maxTime = 1500; // 1.5초
    let timeRemaining = maxTime;
    let lastTime = 0;

    // --- 운송수단 마일스톤 (200년/20점 간격 + 이미지) ---
    const imageRoot = "https://unluckyidiot16.github.io/assets-common/HistoryStair/";
    const milestones = [
        { score: 0, year: 1000, name: "걷기", image: `${imageRoot}walk.png` },
        { score: 20, year: 1200, name: "마차", image: `${imageRoot}carriage.png` },
        { score: 40, year: 1400, name: "증기기관차", image: `${imageRoot}train_0.png` },
        { score: 60, year: 1600, name: "클래식 카", image: `${imageRoot}car_1.png` },
        { score: 80, year: 1800, name: "택시", image: `${imageRoot}car_3.png` },
        { score: 100, year: 2000, name: "비행기", image: `${imageRoot}airplane.png` },
        { score: 120, year: 2200, name: "전철", image: `${imageRoot}train_1.png` },
        { score: 140, year: 2400, name: "우주선A", image: `${imageRoot}spaceship_1.png` },
        { score: 160, year: 2600, name: "우주선B", image: `${imageRoot}spaceship_2.png` },
        { score: 180, year: 2800, name: "우주고양이", image: `${imageRoot}Spacekitty.png` }
    ];
    let currentMilestoneIndex = 0;
    let selectedSkin = milestones[0];
    let preloadedImages = {}; // --- 추가됨: 이미지 프리로딩 ---

    // --- 추가됨: 이미지 프리로드 함수 ---
    function preloadImages() {
        milestones.forEach(m => {
            const img = new Image();
            img.src = m.image;
            preloadedImages[m.name] = img;
        });
        player.imageElement = preloadedImages[milestones[0].name]; // 기본 스킨 설정
    }

    // --- 캔버스 크기 조절 ---
    function resizeCanvas() {
        const mainRect = gameContainer.getBoundingClientRect();
        // --- 수정: 오버레이 크기에 맞게 조절
        const overlayRect = overlay.getBoundingClientRect();
        // 오버레이가 캔버스를 덮으므로 오버레이 기준으로 크기 설정
        canvas.width = overlayRect.width;
        canvas.height = overlayRect.height;


        player.y = canvas.height * 0.75;

        if (gameStatus !== 'playing') {
            if (stairs.length > 0) {
                player.x = (canvas.width / 2) + stairs[player.stairIndex].x;
                targetPlayerX = player.x;
            } else {
                player.x = canvas.width / 2;
                targetPlayerX = player.x;
            }
            draw(); // 크기 조절 후 다시 그리기
        }
    }

    // --- 계단 생성 ---
    function generateNewStair() {
        const lastStair = stairs[stairs.length - 1]; // (N-1)번째 계단

        let newDir = lastStair.dir;

        // --- *** 수정됨: 계단 이탈 방지 로직 *** ---
        const horizontalLimit = stepX * 8; // 좌우 8칸 (400px) 제한
        let forceTurn = false;

        if (lastStair.x > horizontalLimit && lastStair.dir === 'right') {
            newDir = 'left';
            forceTurn = true;
        } else if (lastStair.x < -horizontalLimit && lastStair.dir === 'left') {
            newDir = 'right';
            forceTurn = true;
        }

        let shouldTurn = false;
        if (forceTurn) {
            shouldTurn = true;
        } else {
            // 기존의 랜덤 턴 로직
            if (stairs.length > 3 &&
                stairs[stairs.length-1].dir === stairs[stairs.length-2].dir &&
                stairs[stairs.length-2].dir === stairs[stairs.length-3].dir &&
                Math.random() < 0.2
            ) {
                shouldTurn = true;
            } else if (stairs.length > 5 && Math.random() < 0.1) {
                shouldTurn = true;
            }
        }

        if (shouldTurn && !forceTurn) { // 강제 턴이 아닐 때만 방향을 뒤집음
            newDir = (lastStair.dir === 'right') ? 'left' : 'right';
        }

        if (shouldTurn) {
            lastStair.isTurn = true;
        }

        const newX = lastStair.x + (newDir === 'right' ? stepX : -stepX);
        const newY = lastStair.y - stepY;

        stairs.push({
            x: newX,
            y: newY,
            dir: newDir,
            isTurn: false
        });
    }

    function generateInitialStairs() {
        stairs = [];
        stairs.push({ x: 0, y: 0, dir: 'right', isTurn: false }); // 첫 번째 계단

        while (stairs.length < totalStairsToGenerate) {
            generateNewStair();
        }
    }

    // --- 게임 초기화 ---
    function initGame() {
        score = 0;
        currentYear = 1000;
        currentMilestoneIndex = 0;
        // --- 수정됨: 선택한 스킨 이미지로 설정 ---
        player.imageElement = preloadedImages[selectedSkin.name];
        player.stairIndex = 0;

        worldY = 0;
        targetWorldY = 0;

        timeRemaining = maxTime;
        lastTime = 0; // *** 중요: 타이머 루프를 위해 0으로 리셋 ***

        generateInitialStairs();

        player.x = (canvas.width / 2) + stairs[0].x;
        targetPlayerX = player.x;

        updateSidebar();
    }

    // --- 사이드바 업데이트 ---
    function updateSidebar() {
        yearDisplay.textContent = `${currentYear}년`;
        scoreDisplay.textContent = score;

        unlockedList.innerHTML = "";
        for (let i = 0; i <= currentMilestoneIndex; i++) {
            const li = document.createElement('li');
            li.className = "flex items-center";
            // --- 수정됨: 현재 선택된 스킨과 이름이 같다면 강조 표시 + 이미지 ---
            let fontWeight = (milestones[i].name === selectedSkin.name) ? 'font-bold text-yellow-300' : '';
            li.innerHTML = `<img src="${milestones[i].image}" class="inline-block w-6 h-6 rounded-full mr-3 object-contain bg-gray-700 p-0.5"> <span class="${fontWeight}">${milestones[i].year}년: ${milestones[i].name}</span>`;
            unlockedList.appendChild(li);
        }
    }

    // --- 마일스톤 확인 ---
    function checkMilestones() {
        if (currentMilestoneIndex < milestones.length - 1) {
            const nextMilestone = milestones[currentMilestoneIndex + 1];
            if (score >= nextMilestone.score) {
                currentMilestoneIndex++;
                updateSidebar();
            }
        }
    }

    // --- *** 수정됨: 게임 시작 (타이머 버그 수정) *** ---
    function startGame() {
        initGame(); // This sets lastTime = 0 and timeRemaining = maxTime
        gameStatus = 'playing';
        overlay.classList.add('hidden');
        // lastTime = performance.now(); // REMOVED: This was a bug
        // gameLoop(); // REMOVED: This was a bug
        requestAnimationFrame(gameLoop); // ADDED: This starts the loop correctly
    }

    // --- 게임 오버 ---
    function gameOver() {
        gameStatus = 'over';

        // --- 추가됨: 최고 점수 갱신 ---
        if (score > highestScore) {
            highestScore = score;
            saveHighestScore();
            populateMenuSkinGrid(); // 스킨 그리드 갱신
        }
        highestScoreDisplay.textContent = highestScore;

        overlayTitle.textContent = "게임 오버!";
        overlayScore.textContent = `최종 년도: ${currentYear}년 (점수: ${score})`;
        overlayScore.classList.remove('hidden'); // 점수 표시
        startButton.textContent = "다시 시작";
        overlay.classList.remove('hidden');
    }

    // --- 그리기 함수 ---
    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        const camOffsetY = player.y - worldY;

        // 계단 그리기
        for (let i = stairs.length - 1; i >= 0; i--) {
            const s = stairs[i];
            const drawX = s.x + (canvas.width / 2) - stairWidth / 2;
            const drawY = s.y + camOffsetY;

            if (drawX > canvas.width + stairWidth || drawX < -stairWidth || drawY < -stairHeight || drawY > canvas.height + stairHeight) {
                continue;
            }

            ctx.fillStyle = s.isTurn ? '#facc15' : '#6b7280';
            ctx.fillRect(drawX, drawY, stairWidth, stairHeight);
        }

        // --- 수정됨: 플레이어 그리기 (이미지) ---
        if (player.imageElement && player.imageElement.complete) {
            ctx.drawImage(
                player.imageElement,
                player.x - player.width / 2,
                player.y - player.height - (player.height / 2), // 이미지가 발판 위에 오도록 Y조정
                player.width,
                player.height
            );
        } else {
            // 이미지가 로드되지 않았을 경우, 사각형 (fallback)
            ctx.fillStyle = '#a8907a';
            ctx.fillRect(player.x - player.width / 2, player.y - player.height, player.width, player.height);
        }

        // 타이머 바 그리기
        if (gameStatus === 'playing') {
            const timerBarWidth = 100;
            const timerBarHeight = 10;
            const timerX = player.x - timerBarWidth / 2;
            const timerY = player.y - player.height - (player.height / 2) - 20; // 플레이어 머리 위에

            ctx.fillStyle = '#9ca3af';
            ctx.fillRect(timerX, timerY, timerBarWidth, timerBarHeight);

            const barWidth = (timeRemaining / maxTime) * timerBarWidth;
            ctx.fillStyle = timeRemaining < maxTime * 0.3 ? '#ef4444' : '#22c55e';
            ctx.fillRect(timerX, timerY, barWidth, timerBarHeight);
        }
    }

    // --- 메인 게임 루프 ---
    function gameLoop(now) {
        if (gameStatus !== 'playing') return;

        if (!lastTime) { //
            lastTime = now;
        }
        const deltaTime = now - lastTime;
        lastTime = now;

        // 1. 타이머 감소
        timeRemaining -= deltaTime;
        if (timeRemaining <= 0) {
            gameOver();
            return;
        }

        // 2. 카메라 및 플레이어 X 위치 부드럽게 이동
        worldY += (targetWorldY - worldY) * cameraLerpRate;
        player.x += (targetPlayerX - player.x) * playerLerpRate;

        draw();
        requestAnimationFrame(gameLoop);
    }

    // --- 입력 처리 (핵심 로직) ---
    function handleInput(direction) { // 'left' 또는 'right'
        if (gameStatus !== 'playing') return;

        const nextStair = stairs[player.stairIndex + 1];
        if (!nextStair) return;

        const correctDirection = nextStair.dir; // 'left' 또는 'right'

        if (direction === correctDirection) {
            // --- 성공 ---
            player.stairIndex++;
            score = player.stairIndex;
            currentYear = 1000 + score * 10;

            timeRemaining = maxTime;

            const newStair = stairs[player.stairIndex];
            if (newStair) {
                targetPlayerX = (canvas.width / 2) + newStair.x;
                targetWorldY = newStair.y;
            }

            updateSidebar();
            checkMilestones();

            if (stairs.length - player.stairIndex < totalStairsToGenerate) {
                generateNewStair();
            }

        } else {
            // --- 실패 (잘못된 방향) ---
            gameOver();
        }
    }

    // --- 이벤트 리스너 ---

    // PC 클릭 (터치와 동일하게 작동)
    gameContainer.addEventListener('click', (e) => {
        if (gameStatus !== 'playing') return;
        // --- 수정: 메뉴 그리드 클릭 무시 ---
        if (e.target.closest('#menu-skin-grid')) return;

        const clickX = e.clientX - gameContainer.getBoundingClientRect().left;
        const direction = (clickX < canvas.width / 2) ? 'left' : 'right';
        handleInput(direction);
    });

    // 모바일 터치
    gameContainer.addEventListener('touchstart', (e) => {
        if (gameStatus !== 'playing') return;
        // --- 수정: 메뉴 그리드 클릭 무시 ---
        if (e.target.closest('#menu-skin-grid')) return;
        e.preventDefault();

        const touchX = e.touches[0].clientX - gameContainer.getBoundingClientRect().left;
        const direction = (touchX < canvas.width / 2) ? 'left' : 'right';
        handleInput(direction);
    }, { passive: false });

    // 키보드 입력
    window.addEventListener('keydown', (e) => {
        if (gameStatus === 'playing') {
            if (e.key === 'ArrowLeft') {
                handleInput('left');
            } else if (e.key === 'ArrowRight') {
                handleInput('right');
            }
        } else if (gameStatus !== 'playing' && (e.key === 'Enter' || e.key === ' ')) {
            // 스페이스바나 엔터로 게임 시작/재시작
            startGame();
        }
    });

    // 시작 버튼
    startButton.addEventListener('click', (e) => {
        e.stopPropagation();
        startGame();
    });

    // --- *** 스킨 모달 관련 로직 (수정됨) *** ---

    // 스킨 선택 함수
    function selectSkin(milestone, selectedElement) {
        // --- 추가됨: 잠금 해제 확인 ---
        if (milestone.score > highestScore) {
            // 흔들기 애니메이션
            if (selectedElement) {
                selectedElement.classList.add('animate-shake');
                setTimeout(() => selectedElement.classList.remove('animate-shake'), 300);
            }
            return; // 선택 불가
        }

        selectedSkin = milestone;
        player.imageElement = preloadedImages[selectedSkin.name]; // --- 수정됨: 이미지로 설정 ---

        // --- 추가됨: 선택된 스킨 하이라이트 ---
        // 1. 모든 하이라이트 제거
        document.querySelectorAll('#menu-skin-grid .skin-item').forEach(el => {
            el.classList.remove('selected');
        });
        // 2. 클릭된 요소에 하이라이트 추가
        if (selectedElement) {
            selectedElement.classList.add('selected');
        }

        // 게임이 시작되지 않았다면(메뉴/오버 상태)
        if (gameStatus !== 'playing') {
            draw(); // 캔버스의 플레이어 색상을 즉시 업데이트
        }
        updateSidebar(); // 사이드바의 강조 표시 업데이트
    }

    // --- *** 추가됨: 셰이크 애니메이션을 위한 keyframes *** ---
    const styleSheet = document.createElement("style");
    styleSheet.type = "text/css";
    styleSheet.innerText = `
            @keyframes shake {
                0%, 100% { transform: translateX(0); }
                25% { transform: translateX(-5px); }
                50% { transform: translateX(5px); }
                75% { transform: translateX(-5px); }
            }
            .animate-shake {
                animation: shake 0.3s ease-in-out;
            }
        `;
    document.head.appendChild(styleSheet);


    // --- 수정됨: 스킨 '그리드' 채우기 (해금 로직 포함) ---
    function populateMenuSkinGrid() {
        menuSkinGrid.innerHTML = ""; // 비우기
        highestScoreDisplay.textContent = highestScore; // 최고 점수 표시

        milestones.forEach(m => {
            const item = document.createElement('div');
            const isLocked = m.score > highestScore;

            item.className = "skin-item bg-gray-100 rounded-lg p-4 text-center shadow hover:shadow-md";
            if (isLocked) {
                item.classList.add('locked');
            }

            item.innerHTML = `
                    <img src="${m.image}" alt="${m.name}" class="rounded mb-2">
                    <p class="font-semibold text-gray-800">${m.name}</p>
                    <p class="text-sm text-gray-600">${m.year}년</p>
                    ${isLocked ? `<p class="text-xs text-red-500 font-bold">점수 ${m.score} 필요</p>` : ''}
                `;
            // --- 수정됨: selectedElement(item) 전달 ---
            item.addEventListener('click', () => selectSkin(m, item));
            menuSkinGrid.appendChild(item);
        });
    }

    // --- *** 추가됨: 최고 점수 저장/불러오기 *** ---
    function saveHighestScore() {
        try {
            localStorage.setItem('historyStair_highestScore', highestScore.toString());
        } catch (e) {
            console.error("Could not save highest score to localStorage:", e);
        }
    }

    function loadHighestScore() {
        try {
            const storedScore = localStorage.getItem('historyStair_highestScore');
            if (storedScore) {
                highestScore = parseInt(storedScore, 10) || 0;
            }
        } catch (e) {
            console.error("Could not load highest score from localStorage:", e);
            highestScore = 0;
        }
    }


    // 창 크기 조절
    window.addEventListener('resize', resizeCanvas);
    window.addEventListener('orientationchange', resizeCanvas);

    // --- 초기화 ---
    loadHighestScore(); // --- 추가됨: 최고 점수 불러오기 ---
    preloadImages(); // --- 추가됨: 이미지 프리로드 ---
    initGame(); // 게임 데이터 초기화
    resizeCanvas(); // 캔버스 크기 초기 설정
    populateMenuSkinGrid(); // --- 수정됨: 메뉴 스킨 그리드 채우기 ---

    // --- 수정됨: 게임 시작 전 메뉴 상태로 설정 ---
    gameStatus = 'menu';
    overlayTitle.textContent = "대각선 역사 계단";
    overlayScore.classList.add('hidden');
    startButton.textContent = "게임 시작";
    overlay.classList.remove('hidden');

    // --- 추가됨: 기본 스킨 선택 및 하이라이트 (해금된 스킨 중 첫 번째) ---
    const firstUnlockedSkin = milestones.find(m => m.score <= highestScore) || milestones[0];
    const firstUnlockedElement = menuSkinGrid.querySelector('.skin-item:not(.locked)');
    selectSkin(firstUnlockedSkin, firstUnlockedElement);

    draw(); // 초기 화면 그리기
</script>
</body>
</html>

