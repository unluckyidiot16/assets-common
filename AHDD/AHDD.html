<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3v3 전술 카드 배틀</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Noto Sans KR', sans-serif;
            background-color: #1a202c;
            color: #e2e8f0;
        }
        .character-card, .rank-slot {
            transition: all 0.3s ease;
            border-width: 2px;
            border-style: solid;
        }
        .character-card.active {
            transform: translateY(-10px) scale(1.05);
            box-shadow: 0 0 20px rgba(255, 255, 100, 0.7);
            border-color: #f6e05e;
        }
        .character-card.valid-target, .rank-slot.valid-target {
            cursor: pointer;
            box-shadow: 0 0 20px rgba(100, 255, 100, 0.8);
            border-color: #68d391;
        }
        .character-card.valid-swap-target, .rank-slot.valid-swap-target {
            cursor: pointer;
            box-shadow: 0 0 25px rgba(250, 235, 120, 0.9);
            border-color: #f6e05e;
        }
        .character-card.dead {
            filter: grayscale(100%) brightness(0.5);
            transform: rotate(-5deg);
        }
        .hand-card {
            transition: all 0.2s ease;
            cursor: pointer;
            border-width: 2px;
            border-style: solid;
        }
        .hand-card:hover {
            transform: translateY(-15px) scale(1.08);
            z-index: 10;
        }
        .hand-card.selected {
            transform: translateY(-20px) scale(1.1);
            border-color: #f6e05e;
            box-shadow: 0 0 15px rgba(250, 235, 120, 0.8);
        }
        .hand-card.unplayable {
            filter: grayscale(80%) brightness(0.7);
            cursor: not-allowed;
        }
        .token {
            min-width: 24px;
            height: 24px;
            padding: 0 6px;
        }
        .damage-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.8rem;
            font-weight: bold;
            animation: floatUp 1.5s ease-out forwards;
            pointer-events: none;
            text-shadow: 0 0 5px black;
        }
        .damage-text.damage { color: #ef4444; }
        .damage-text.heal { color: #22c55e; }
        .damage-text.shield { color: #3b82f6; }
        @keyframes floatUp {
            0% { transform: translate(-50%, -50%); opacity: 1; }
            100% { transform: translate(-50%, -150px); opacity: 0; }
        }
        .turn-indicator {
            animation: fadeInOut 2s infinite;
        }
        @keyframes fadeInOut {
            0%, 100% { opacity: 0.7; }
            50% { opacity: 1; }
        }
        /* Rank colors */
        .rank-1-bg { background-color: rgba(127, 29, 29, 0.3); border-color: rgba(239, 68, 68, 0.4); } /* Front */
        .rank-2-bg { background-color: rgba(20, 83, 45, 0.3); border-color: rgba(34, 197, 94, 0.4); } /* Mid */
        .rank-3-bg { background-color: rgba(30, 64, 175, 0.3); border-color: rgba(59, 130, 246, 0.4); } /* Back */
    </style>
</head>
<body class="select-none">
<div id="game-container" class="min-h-screen flex flex-col p-4 relative pb-72">

    <div id="game-over-modal" class="hidden absolute inset-0 bg-black bg-opacity-75 flex-col justify-center items-center z-50">
        <h2 id="game-over-title" class="text-6xl font-bold mb-4"></h2>
        <p id="game-over-message" class="text-xl mb-8"></p>
        <button onclick="initializeGame()" class="px-8 py-4 bg-yellow-500 hover:bg-yellow-600 text-gray-900 font-bold rounded-lg text-2xl transition-transform transform hover:scale-105">새 게임 시작</button>
    </div>

    <div id="floating-text-container" class="absolute inset-0 pointer-events-none z-40"></div>

    <div id="game-info" class="absolute top-4 right-4 text-right bg-gray-900 bg-opacity-70 p-4 rounded-lg z-10">
        <h2 id="turn-indicator" class="text-2xl font-bold turn-indicator"></h2>
        <p id="round-counter" class="text-lg"></p>
    </div>

    <div class="flex-grow flex flex-col justify-center items-center space-y-8">
        <div class="flex flex-col items-center">
            <div id="ai-hand" class="flex justify-center items-start space-x-[-20px] h-32"></div>
            <div id="ai-team" class="flex justify-center items-end space-x-4"></div>
        </div>

        <div class="flex flex-col items-center">
            <div id="player-team" class="flex justify-center items-start space-x-4"></div>
        </div>
    </div>

    <div class="flex justify-between items-end fixed bottom-0 left-0 right-0 p-4 bg-gray-900 bg-opacity-50 backdrop-blur-sm h-64">
        <div class="w-1/4 h-full bg-gray-800 rounded-lg p-2 overflow-y-auto border border-gray-700">
            <div id="game-log" class="text-sm space-y-1"></div>
        </div>

        <div id="player-hand" class="flex-grow h-full flex justify-center items-center space-x-[-40px] mx-4"></div>

        <div class="w-1/4 h-full flex flex-col items-center justify-center space-y-3 bg-gray-800 rounded-lg p-2 border border-gray-700">
            <div class="text-center">
                <div id="player-ap" class="text-4xl font-bold text-yellow-400"></div>
                <div class="text-sm">행동력 (AP)</div>
            </div>
            <p class="text-sm text-center text-gray-400">인접한 아군/빈 슬롯을 클릭하여<br>위치를 교대할 수 있습니다 (1 AP).</p>
            <button id="end-turn-btn" class="w-full px-6 py-3 bg-red-600 hover:bg-red-700 rounded-lg font-bold text-xl disabled:bg-gray-600 disabled:cursor-not-allowed">턴 종료</button>
        </div>
    </div>
</div>

<script>
    // --- 게임 데이터 정의 ---
    const CLASS_DATA = {
        bruiser: { name: '기사', stats: { maxHp: 80, atk: 10, def: 5, spd: 4 }, signatureIds: ['linebreaker'], imageUrl: 'https://unluckyidiot16.github.io/assets-common/fantasy-characters/Knight/knight_NoOL_L.png' },
        hunter: { name: '로그', stats: { maxHp: 65, atk: 12, def: 2, spd: 6 }, signatureIds: ['kill_zone'], imageUrl: 'https://unluckyidiot16.github.io/assets-common/fantasy-characters/Rogue/rogue-female_NoOL_L.png' },
        cleric: { name: '공주', stats: { maxHp: 70, atk: 8, def: 3, spd: 3 }, signatureIds: ['aegis_hymn'], imageUrl: 'https://unluckyidiot16.github.io/assets-common/fantasy-characters/Princess/princess_NoOL_L.png' },
        warlock: { name: '마법사', stats: { maxHp: 68, atk: 11, def: 2, spd: 5 }, signatureIds: ['soul_brand'], imageUrl: 'https://unluckyidiot16.github.io/assets-common/fantasy-characters/Wizard/wizard_NoOL_L.png' },
        assassin: { name: '로그', stats: { maxHp: 60, atk: 13, def: 1, spd: 7 }, signatureIds: ['execution'], imageUrl: 'https://unluckyidiot16.github.io/assets-common/fantasy-characters/Rogue/rogue-male_NoOL_L.png' },
        guard: { name: '흑기사', stats: { maxHp: 90, atk: 9, def: 6, spd: 2 }, signatureIds: ['phalanx_wall'], imageUrl: 'https://unluckyidiot16.github.io/assets-common/fantasy-characters/Knight/knight-black_NoOL_L.png' }
    };

    const CARD_DATA = {
        strike: { id: 'strike', name: '강타', fromRanks: [1, 2], toRanks: [1, 2], targetSide: 'enemy', apCost: 1, text: '피해 8', effects: [{ type: 'damage', value: 8 }] },
        quick_strike: { id: 'quick_strike', name: '속공', fromRanks: [1, 2, 3], toRanks: [1, 2], targetSide: 'enemy', apCost: 1, text: '피해 6', effects: [{ type: 'damage', value: 6 }] },
        shoot: { id: 'shoot', name: '사격', fromRanks: [2, 3], toRanks: [1, 2, 3], targetSide: 'enemy', apCost: 1, text: '피해 7', effects: [{ type: 'damage', value: 7 }] },
        defend: { id: 'defend', name: '방어', fromRanks: [1, 2, 3], toRanks: [], targetSide: 'ally', selfTarget: true, apCost: 1, text: '자신에게 Block 1', effects: [{ type: 'applyToken', token: 'Block', stacks: 1 }] },
        brace: { id: 'brace', name: '진지 구축', fromRanks: [1, 2, 3], toRanks: [], targetSide: 'ally', selfTarget: true, apCost: 1, text: '자신에게 Block+ 1', effects: [{ type: 'applyToken', token: 'Block+', stacks: 1 }] },
        mark_target: { id: 'mark_target', name: '표식 지정', fromRanks: [2, 3], toRanks: [1, 2, 3], targetSide: 'enemy', apCost: 1, text: '대상에게 Marked 1', effects: [{ type: 'applyToken', token: 'Marked', stacks: 1 }] },
        weaken: { id: 'weaken', name: '약화', fromRanks: [2, 3], toRanks: [1, 2, 3], targetSide: 'enemy', apCost: 1, text: '대상에게 Weak 1', effects: [{ type: 'applyToken', token: 'Weak', stacks: 1 }] },
        first_aid: { id: 'first_aid', name: '응급 처치', fromRanks: [2, 3], toRanks: [1, 2, 3], targetSide: 'ally', apCost: 1, text: '아군 하나 치유 8', effects: [{ type: 'heal', value: 8 }] },
        push: { id: 'push', name: '밀치기', fromRanks: [1, 2], toRanks: [1, 2], targetSide: 'enemy', apCost: 1, text: '피해 4, 밀치기 1', effects: [{ type: 'damage', value: 4 }, { type: 'push', spaces: 1 }] },
        pull: { id: 'pull', name: '끌어오기', fromRanks: [2, 3], toRanks: [2, 3], targetSide: 'enemy', apCost: 1, text: '피해 4, 끌어오기 1', effects: [{ type: 'damage', value: 4 }, { type: 'pull', spaces: 1 }] },
        linebreaker: { id: 'linebreaker', name: '전선 돌파', fromRanks: [1, 2], toRanks: [1], targetSide: 'enemy', apCost: 1, text: '전진 1, 피해 12, Marked 1, 밀치기 1. 이번 턴 이동했다면 Stun 1', signature: true, effects: [{ type: 'move', self: true, spaces: -1 }, { type: 'damage', value: 12 }, { type: 'applyToken', token: 'Marked', stacks: 1 }, { type: 'push', spaces: 1 }, { type: 'conditionalStun', condition: 'movedThisTurn', stacks: 1 }] },
        phalanx_wall: { id: 'phalanx_wall', name: '방진벽', fromRanks: [1], toRanks: [], targetSide: 'ally', selfTarget: true, apCost: 1, text: '모든 아군 Block 1, 자신에게 Guard 2, Taunt 1', signature: true, effects: [{ type: 'teamEffect', effect: { type: 'applyToken', token: 'Block', stacks: 1 } }, { type: 'applyToken', token: 'Guard', stacks: 2 }, { type: 'applyToken', token: 'Taunt', stacks: 1 }] },
        execution: { id: 'execution', name: '처형', fromRanks: [1, 2], toRanks: [1, 2], targetSide: 'enemy', apCost: 1, text: '피해 10. 대상 HP 30% 이하 시 추가 고정 피해 8. 처치 시 자신 Strength 1, 이동 1', signature: true, effects: [{ type: 'damage', value: 10 }, { type: 'conditionalExecute', threshold: 0.3, damage: 8 }, { type: 'onKill', effects: [{ type: 'applyToken', token: 'Strength', stacks: 1 }, { type: 'freeMove', spaces: 1 }] }], bonusIfTargetMarked: { damagePct: 25 } },
        kill_zone: { id: 'kill_zone', name: '킬 존', fromRanks: [3], toRanks: [], targetSide: 'ally', selfTarget: true, apCost: 1, text: '라운드 동안 적 이동 시 반응 사격(피해 10) 2회', signature: true, effects: [{ type: 'applyBuff', buff: 'riposteOnMove', duration: 'round', stacks: 2, payload: { damage: 10 }}], bonusIfTargetMarked: { damagePct: 25, consume: true } },
        aegis_hymn: { id: 'aegis_hymn', name: '수호의 찬가', fromRanks: [2, 3], toRanks: [], targetSide: 'ally', apCost: 1, text: '모든 아군 Block 1, Stun Ward 1. 과잉 치유는 Shield 6으로 전환', signature: true, effects: [{ type: 'teamEffect', effect: { type: 'applyToken', token: 'Block', stacks: 1 } }, { type: 'teamEffect', effect: { type: 'applyToken', token: 'Stun Ward', stacks: 1 } }, { type: 'teamHeal', value: 0, overflowToShield: 6 }] },
        soul_brand: { id: 'soul_brand', name: '영혼 낙인', fromRanks: [2, 3], toRanks: [1, 2, 3], targetSide: 'enemy', apCost: 1, text: 'Marked 1 부여. 라운드 종료 시, 대상이 받은 피해 25%만큼 추가 피해 후 Vulnerable 1 부여', signature: true, effects: [{ type: 'applyToken', token: 'Marked', stacks: 1 }, { type: 'applyDebuff', debuff: 'soulBrand', duration: 'round' }] },
    };

    const TOKEN_DATA = {
        'Strength': { name: '힘', color: 'bg-red-500', description: '다음 공격 피해 +50%' },
        'Weak': { name: '약화', color: 'bg-purple-500', description: '다음 공격 피해 -50%' },
        'Vulnerable': { name: '취약', color: 'bg-yellow-600', description: '다음 피격 피해 +50%' },
        'Block': { name: '방어', color: 'bg-blue-500', description: '다음 피격 피해 -50%' },
        'Block+': { name: '견고한 방어', color: 'bg-blue-700', description: '다음 피격 피해 -75%' },
        'Guard': { name: '수호', color: 'bg-indigo-500', description: '대신 피격' },
        'Taunt': { name: '도발', color: 'bg-pink-500', description: '우선 공격 대상' },
        'Stun': { name: '기절', color: 'bg-yellow-400', description: '다음 턴 행동 불가' },
        'Stun Ward': { name: '기절 면역', color: 'bg-green-400', description: '기절 1회 방어' },
        'Marked': { name: '표식', color: 'bg-red-800', description: '특정 카드 효과 강화' }
    };

    let gameState = {};

    const playerTeamEl = document.getElementById('player-team');
    const aiTeamEl = document.getElementById('ai-team');
    const playerHandEl = document.getElementById('player-hand');
    const aiHandEl = document.getElementById('ai-hand');
    const playerApEl = document.getElementById('player-ap');
    const endTurnBtn = document.getElementById('end-turn-btn');
    const turnIndicatorEl = document.getElementById('turn-indicator');
    const roundCounterEl = document.getElementById('round-counter');
    const gameLogEl = document.getElementById('game-log');
    const gameOverModalEl = document.getElementById('game-over-modal');
    const gameOverTitleEl = document.getElementById('game-over-title');
    const gameOverMessageEl = document.getElementById('game-over-message');
    const floatingTextContainerEl = document.getElementById('floating-text-container');

    function initializeGame() {
        logMessage('새 게임을 시작합니다.');
        gameState = { teams: { player: [], ai: [] }, initiativeOrder: [], currentTurnIndex: -1, activeCharacterId: null, selectedCard: null, round: 1, fatigue: false, gameOver: false };
        const playerClasses = ['bruiser', 'hunter', 'cleric'];
        const aiClasses = ['guard', 'assassin', 'warlock'];
        playerClasses.forEach((c, i) => createCharacter(c, 'player', i + 1));
        aiClasses.forEach((c, i) => createCharacter(c, 'ai', i + 1));
        gameOverModalEl.classList.add('hidden');
        gameOverModalEl.classList.remove('flex');
        startCombat();
    }

    function createCharacter(className, teamId, initialRank) {
        const classInfo = CLASS_DATA[className];
        const character = { id: `${teamId}-${classInfo.name}-${initialRank}`, class: className, name: classInfo.name, teamId, ...classInfo.stats, hp: classInfo.stats.maxHp, rank: initialRank, tokens: {}, buffs: [], debuffs: [], deck: [], hand: [], discard: [], isDead: false, movedThisTurn: false, damageTakenThisRound: 0 };
        buildDeck(character);
        gameState.teams[teamId].push(character);
    }

    function buildDeck(character) {
        CLASS_DATA[character.class].signatureIds.forEach(id => character.deck.push({ ...CARD_DATA[id] }));
        let commonCards = [];
        switch (character.class) {
            case 'bruiser': commonCards = ['strike','strike','strike','strike','push','push','defend','defend','quick_strike']; break;
            case 'hunter': commonCards = ['shoot','shoot','shoot','shoot','mark_target','mark_target','quick_strike','pull','defend']; break;
            case 'cleric': commonCards = ['first_aid','first_aid','first_aid','weaken','defend','shoot','shoot','mark_target','brace']; break;
            case 'guard': commonCards = ['strike','strike','defend','defend','defend','brace','brace','push','quick_strike']; break;
            case 'assassin': commonCards = ['strike','strike','strike','quick_strike','quick_strike','quick_strike','mark_target','push','weaken']; break;
            case 'warlock': commonCards = ['shoot','shoot','weaken','weaken','mark_target','mark_target','quick_strike','pull','defend']; break;
        }
        commonCards.forEach(id => character.deck.push({ ...CARD_DATA[id] }));
        while (character.deck.length < 20) {
            character.deck.push(character.atk > 10 ? { ...CARD_DATA.strike } : { ...CARD_DATA.shoot });
        }
        shuffleDeck(character);
    }

    function startCombat() {
        logMessage('전투 시작!');
        gameState.round = 1;
        determineInitiative();
        startNextTurn();
    }

    function determineInitiative() {
        gameState.initiativeOrder = [...gameState.teams.player, ...gameState.teams.ai].filter(c => !c.isDead).sort((a, b) => b.spd - a.spd);
        logMessage(`행동 순서: ${gameState.initiativeOrder.map(c => c.name).join(', ')}`);
    }

    function startNextTurn() {
        if (gameState.gameOver) return;
        gameState.selectedCard = null;
        const prevChar = getActiveCharacter();
        if (prevChar) prevChar.movedThisTurn = false;
        gameState.currentTurnIndex++;
        if (gameState.currentTurnIndex >= gameState.initiativeOrder.length) { endRound(); return; }
        const activeCharacter = getActiveCharacter();
        gameState.activeCharacterId = activeCharacter.id;
        logMessage(`--- ${activeCharacter.name}의 턴 ---`, 'turn');
        turnIndicatorEl.textContent = `${activeCharacter.name}의 턴`;
        if (hasToken(activeCharacter, 'Stun')) {
            removeToken(activeCharacter, 'Stun', 1);
            logMessage(`${activeCharacter.name}이 기절하여 행동할 수 없습니다.`);
            setTimeout(startNextTurn, 1000);
            render();
            return;
        }
        activeCharacter.ap = 3;
        drawCards(activeCharacter, 5);
        render();
        if (activeCharacter.teamId === 'ai') setTimeout(runAITurn, 1500);
    }

    function endTurn() {
        const activeCharacter = getActiveCharacter();
        if (!activeCharacter || gameState.gameOver) return;
        logMessage(`${activeCharacter.name}이(가) 턴을 종료합니다.`);
        discardHand(activeCharacter);
        startNextTurn();
    }

    function endRound() {
        logMessage(`--- ${gameState.round} 라운드 종료 ---`, 'round');
        const allCharacters = [...gameState.teams.player, ...gameState.teams.ai];
        allCharacters.forEach(char => {
            char.debuffs = char.debuffs.filter(debuff => {
                if (debuff.debuff === 'soulBrand') {
                    const damage = Math.floor(char.damageTakenThisRound * 0.25);
                    if (damage > 0) {
                        applyDamage(char, damage, null, true);
                        logMessage(`${char.name}이 영혼 낙인으로 ${damage}의 피해를 입습니다.`);
                    }
                    applyToken(char, 'Vulnerable', 1);
                    return false;
                }
                return true;
            });
            char.damageTakenThisRound = 0;
        });
        gameState.round++;
        roundCounterEl.textContent = `라운드 ${gameState.round}`;
        if (gameState.round >= 7) {
            gameState.fatigue = true;
            logMessage('피로가 누적됩니다! 라운드 종료 시 모든 유닛이 2의 고정 피해를 입습니다.', 'warning');
            allCharacters.forEach(c => { if (!c.isDead) applyDamage(c, 2, null, true) });
        }
        if (checkGameOver()) return;
        determineInitiative();
        gameState.currentTurnIndex = -1;
        startNextTurn();
    }

    function shuffleDeck(c) { c.deck.sort(() => Math.random() - 0.5); }
    function drawCards(c, amount) {
        for (let i = 0; i < amount; i++) {
            if (c.deck.length === 0) {
                if (c.discard.length === 0) break;
                logMessage(`${c.name}이(가) 덱을 다시 섞습니다.`);
                c.deck = [...c.discard]; c.discard = []; shuffleDeck(c);
            }
            c.hand.push(c.deck.pop());
        }
    }
    function discardHand(c) { c.discard.push(...c.hand); c.hand = []; }

    function selectCard(cardIndex) {
        const player = getActiveCharacter();
        if (!player || player.teamId !== 'player') return;
        const card = player.hand[cardIndex];
        gameState.selectedCard = isCardPlayable(player, card) ? { card, index: cardIndex } : null;
        render();
    }

    function isCardPlayable(c, card) {
        return c.ap >= card.apCost && (!card.fromRanks || card.fromRanks.includes(c.rank));
    }

    function playCard(targetCharacter) {
        const player = getActiveCharacter();
        const { card, index } = gameState.selectedCard;
        if (!player || !card || !targetCharacter || !isValidTarget(player, card, targetCharacter)) return;
        let finalTarget = findFinalTarget(targetCharacter);
        player.ap -= card.apCost;
        player.hand.splice(index, 1);
        player.discard.push(card);
        logMessage(`${player.name}이(가) ${finalTarget.name}에게 ${card.name} 사용!`);
        applyCardEffects(player, finalTarget, card);
        gameState.selectedCard = null;
        if (checkGameOver()) return;
        render();
        if (player.ap <= 0) setTimeout(endTurn, 1000);
    }

    function playerSwapPosition(targetRank) {
        const player = getActiveCharacter();
        if (!player || player.ap < 1) return;
        if (Math.abs(player.rank - targetRank) !== 1) return;

        player.ap -= 1;
        player.movedThisTurn = true;
        const otherUnit = gameState.teams.player.find(c => c.rank === targetRank);
        if(otherUnit) {
            logMessage(`${player.name}이(가) ${otherUnit.name}와 위치를 교대합니다.`);
            otherUnit.rank = player.rank;
        } else {
            logMessage(`${player.name}이(가) 빈 위치로 이동합니다.`);
        }
        player.rank = targetRank;

        render();
    }

    function runAITurn() {
        const ai = getActiveCharacter();
        if (!ai || ai.teamId !== 'ai' || gameState.gameOver) return;
        const playableCards = ai.hand.map((card, index) => ({ card, index })).filter(item => isCardPlayable(ai, item.card));
        if (playableCards.length > 0 && ai.ap > 0) {
            let target = null, cardToPlay = null;
            const markedTargets = gameState.teams.player.filter(c => !c.isDead && hasToken(c, 'Marked'));
            for (const item of playableCards) { if (item.card.bonusIfTargetMarked) { for (const mt of markedTargets) { if (isValidTarget(ai, item.card, mt)) { cardToPlay = item; target = mt; break; } } } if (target) break; }
            if (!target && markedTargets.length > 0) { for (const item of playableCards) { for (const mt of markedTargets) { if (isValidTarget(ai, item.card, mt)) { cardToPlay = item; target = mt; break; } } if (target) break; } }
            if (!target) { for (const item of playableCards) { const potential = findValidTargets(ai, item.card); if (potential.length > 0) { cardToPlay = item; target = potential.sort((a,b) => a.hp - b.hp)[0]; break; } } }
            if (target && cardToPlay) {
                const { card, index } = cardToPlay;
                ai.ap -= card.apCost; ai.hand.splice(index, 1); ai.discard.push(card);
                let finalTarget = findFinalTarget(target);
                logMessage(`${ai.name}이(가) ${finalTarget.name}에게 ${card.name} 사용!`);
                applyCardEffects(ai, finalTarget, card);
                if (checkGameOver()) return;
                render();
                if (ai.ap > 0) setTimeout(runAITurn, 1500); else setTimeout(endTurn, 1000);
                return;
            }
        }
        setTimeout(endTurn, 1000);
    }

    function applyCardEffects(source, target, card) {
        if (!card.effects) return;
        card.effects.forEach(effect => {
            switch (effect.type) {
                case 'damage':
                    let damage = effect.value;
                    if (card.bonusIfTargetMarked && hasToken(target, 'Marked')) {
                        damage = Math.floor(damage * (1 + card.bonusIfTargetMarked.damagePct / 100));
                        logMessage(`표식 대상에게 추가 피해!`);
                        if (card.bonusIfTargetMarked.consume) removeToken(target, 'Marked', 1);
                    }
                    applyDamage(target, damage, source);
                    break;
                case 'heal': applyHeal(target, effect.value); break;
                case 'applyToken': applyToken(effect.self ? source : target, effect.token, effect.stacks); break;
                case 'teamEffect': gameState.teams[source.teamId].forEach(m => { if(!m.isDead) applyToken(m, effect.effect.token, effect.effect.stacks); }); break;
                case 'teamHeal': gameState.teams[source.teamId].forEach(m => { if(!m.isDead) applyHeal(m, effect.value, effect.overflowToShield); }); break;
                case 'push': moveCharacter(target, effect.spaces); break;
                case 'pull': moveCharacter(target, -effect.spaces); break;
                case 'move': if (effect.self) { moveCharacter(source, effect.spaces); source.movedThisTurn = true; } break;
                case 'conditionalStun': if (effect.condition === 'movedThisTurn' && source.movedThisTurn) applyToken(target, 'Stun', effect.stacks); break;
                case 'conditionalExecute': if ((target.hp / target.maxHp) <= effect.threshold) { logMessage(`체력이 낮아 처형 효과 발동!`); applyDamage(target, effect.damage, source, true); } break;
                case 'onKill': if (target.isDead) { logMessage(`${source.name}의 처치 효과 발동!`); effect.effects.forEach(e => applyCardEffects(source, source, {effects: [e]})); } break;
                case 'applyDebuff': target.debuffs.push({debuff: effect.debuff, duration: effect.duration}); logMessage(`${target.name}에게 ${effect.debuff} 효과 부여.`); break;
            }
        });
    }

    function applyDamage(target, baseAmount, source, isFixed = false) {
        if (target.isDead) return;
        let finalAmount = baseAmount;
        if (!isFixed) {
            let multiplier = 1.0;
            if (source) {
                if (hasToken(source, 'Strength')) { multiplier *= 1.5; removeToken(source, 'Strength', 1); }
                if (hasToken(source, 'Weak')) { multiplier *= 0.5; removeToken(source, 'Weak', 1); }
            }
            finalAmount = Math.max(1, (source ? source.atk : 0) + baseAmount - target.def);
            if (hasToken(target, 'Vulnerable')) { multiplier *= 1.5; removeToken(target, 'Vulnerable', 1); }
            if (hasToken(target, 'Block+')) { multiplier *= 0.25; removeToken(target, 'Block+', 1); }
            else if (hasToken(target, 'Block')) { multiplier *= 0.5; removeToken(target, 'Block', 1); }
            finalAmount = Math.round(finalAmount * multiplier);
        }
        target.hp -= finalAmount;
        target.damageTakenThisRound += finalAmount;
        showFloatingText(target, finalAmount, 'damage');
        logMessage(`${target.name}이(가) ${finalAmount}의 피해를 입었습니다. (남은 HP: ${Math.max(0, target.hp)})`);
        if (target.hp <= 0) { target.hp = 0; target.isDead = true; logMessage(`${target.name}이(가) 쓰러졌습니다!`, 'death'); }
    }

    function applyHeal(target, amount, overflowToShield = 0) {
        const healed = Math.min(amount, target.maxHp - target.hp), overflow = amount - healed;
        if (healed > 0) { target.hp += healed; showFloatingText(target, healed, 'heal'); logMessage(`${target.name}이(가) HP를 ${healed}만큼 회복했습니다.`); }
        if (overflow > 0 && overflowToShield > 0) {
            const shield = Math.min(overflow, overflowToShield);
            applyToken(target, 'Block', Math.ceil(shield / 3));
            logMessage(`${target.name}에게 과잉 치유로 ${shield}만큼의 보호막이 부여됩니다.`);
            showFloatingText(target, shield, 'shield');
        }
    }

    function applyToken(c, token, stacks) {
        if(token === 'Stun' && hasToken(c, 'Stun Ward')) { removeToken(c, 'Stun Ward', 1); logMessage(`${c.name}이(가) 기절 면역으로 기절을 막았습니다!`); return; }
        if (!c.tokens[token]) c.tokens[token] = 0;
        c.tokens[token] += stacks; logMessage(`${c.name}에게 ${TOKEN_DATA[token].name} ${stacks} 중첩 부여.`);
    }
    function removeToken(c, token, stacks) { if (c.tokens[token]) { c.tokens[token] -= stacks; if (c.tokens[token] <= 0) delete c.tokens[token]; } }
    function hasToken(c, token) { return c.tokens[token] && c.tokens[token] > 0; }

    function moveCharacter(character, spaces) {
        const team = gameState.teams[character.teamId];
        const newRank = character.rank + spaces;
        if (newRank < 1 || newRank > 3) return;
        const occupant = team.find(c => c.rank === newRank && !c.isDead);
        if (occupant) { occupant.rank = character.rank; logMessage(`${character.name}과(와) ${occupant.name}이(가) 위치를 교대합니다.`); }
        else { logMessage(`${character.name}이(가) ${spaces > 0 ? '뒤로' : '앞으로'} 이동합니다.`); }
        character.rank = newRank;
    }

    function findValidTargets(source, card) {
        const targetTeam = gameState.teams[card.targetSide === 'enemy' ? (source.teamId === 'player' ? 'ai' : 'player') : source.teamId];
        return card.selfTarget ? [source] : targetTeam.filter(t => !t.isDead && card.toRanks.includes(t.rank));
    }
    function isValidTarget(s, c, t) { return findValidTargets(s, c).includes(t); }
    function findFinalTarget(initialTarget) {
        const enemyTeam = gameState.teams[initialTarget.teamId];
        const taunter = enemyTeam.find(c => !c.isDead && hasToken(c, 'Taunt'));
        if (taunter) { logMessage(`${taunter.name}의 도발!`); removeToken(taunter, 'Taunt', 1); return taunter; }
        const guard = enemyTeam.find(c => !c.isDead && hasToken(c, 'Guard'));
        if (guard) { logMessage(`${guard.name}가 대신 받습니다!`); removeToken(guard, 'Guard', 1); return guard; }
        return initialTarget;
    }

    function checkGameOver() {
        const playerAlive = gameState.teams.player.some(c => !c.isDead);
        const aiAlive = gameState.teams.ai.some(c => !c.isDead);
        if (!playerAlive || !aiAlive) {
            gameState.gameOver = true;
            gameOverTitleEl.textContent = playerAlive ? "승리!" : "패배";
            gameOverMessageEl.textContent = playerAlive ? "적들을 모두 물리쳤습니다!" : "아군이 모두 쓰러졌습니다...";
            gameOverModalEl.classList.remove('hidden');
            gameOverModalEl.classList.add('flex');
            return true;
        }
        return false;
    }

    function render() {
        if(gameState.gameOver) return;
        renderTeam(playerTeamEl, 'player');
        renderTeam(aiTeamEl, 'ai');
        const activeCharacter = getActiveCharacter();
        if (activeCharacter) {
            if (activeCharacter.teamId === 'player') {
                renderHand(playerHandEl, activeCharacter);
                playerApEl.textContent = '♦'.repeat(activeCharacter.ap);
                endTurnBtn.disabled = false;
            } else {
                playerHandEl.innerHTML = '';
                playerApEl.textContent = '';
                endTurnBtn.disabled = true;
            }
            const aiOpponent = gameState.initiativeOrder.find(c => c.teamId ==='ai' && c.id === activeCharacter.id);
            if(aiOpponent) renderHand(aiHandEl, aiOpponent, true); else aiHandEl.innerHTML = '';
        }
    }

    function renderTeam(container, teamId) {
        container.innerHTML = '';
        const team = gameState.teams[teamId];
        const activeChar = getActiveCharacter();
        const isPlayerTurn = activeChar && activeChar.teamId === 'player';

        for (let rank = 1; rank <= 3; rank++) {
            const character = team.find(c => c.rank === rank && !c.isDead);
            if (character) {
                const el = createCharacterElement(character);
                if(isPlayerTurn && teamId === 'player' && Math.abs(activeChar.rank - rank) === 1 && activeChar.id !== character.id) {
                    el.classList.add('valid-swap-target');
                    el.onclick = () => playerSwapPosition(rank);
                }
                container.appendChild(el);
            } else {
                const slotEl = document.createElement('div');
                slotEl.className = `rank-slot w-48 h-64 rounded-lg flex items-center justify-center border-dashed rank-${rank}-bg`;
                slotEl.dataset.rank = rank;
                if(isPlayerTurn && teamId === 'player' && Math.abs(activeChar.rank - rank) === 1) {
                    slotEl.classList.add('valid-swap-target');
                    slotEl.onclick = () => playerSwapPosition(rank);
                }
                container.appendChild(slotEl);
            }
        }
    }

    function createCharacterElement(character) {
        const el = document.createElement('div');
        el.id = character.id;
        el.dataset.characterId = character.id;
        el.className = `character-card w-48 h-64 rounded-lg p-2 flex flex-col justify-between relative overflow-hidden rank-${character.rank}-bg`;
        if (character.isDead) el.classList.add('dead');
        if (character.id === gameState.activeCharacterId) el.classList.add('active');
        if (gameState.selectedCard && isValidTarget(getActiveCharacter(), gameState.selectedCard.card, character)) {
            el.classList.add('valid-target');
            el.onclick = (e) => {
                e.stopPropagation();
                playCard(character);
            }
        }
        const tokensHTML = Object.entries(character.tokens).map(([token, stacks]) => {
            const tokenInfo = TOKEN_DATA[token];
            return `<div title="${tokenInfo.description}" class="token ${tokenInfo.color} text-white text-xs font-bold rounded-full flex items-center justify-center shadow-lg">${tokenInfo.name[0]}${stacks > 1 ? stacks : ''}</div>`;
        }).join('');
        const hpPercentage = (character.hp / character.maxHp) * 100;
        const imageUrl = CLASS_DATA[character.class].imageUrl;
        el.innerHTML = `
                <div class="absolute top-2 right-2 flex flex-wrap-reverse gap-1 justify-end" style="width: 50%; z-index: 5;">${tokensHTML}</div>
                <img src="${imageUrl}" class="absolute inset-0 w-full h-full object-contain drop-shadow-lg" alt="${character.name}" style="z-index: 1;" onerror="this.style.display='none'">
                <div class="relative z-10 flex flex-col justify-between h-full w-full">
                    <div class="text-center">
                        <div class="font-bold text-lg text-white bg-black bg-opacity-60 rounded px-2 py-1 inline-block">${character.name}</div>
                    </div>
                    <div class="w-full">
                        <div class="text-center font-bold bg-black bg-opacity-60 rounded-md py-1">${character.hp} / ${character.maxHp}</div>
                        <div class="w-full bg-gray-600 rounded-full h-2.5 mt-1">
                            <div class="bg-red-600 h-2.5 rounded-full" style="width: ${hpPercentage}%"></div>
                        </div>
                    </div>
                </div>`;
        return el;
    }

    function renderHand(container, character, isAi = false) {
        container.innerHTML = '';
        character.hand.forEach((card, index) => {
            const cardEl = document.createElement('div');
            cardEl.className = `hand-card ${isAi ? 'w-32 h-44' : 'w-40 h-56'} bg-gray-700 rounded-lg p-3 flex flex-col justify-between border-gray-500 text-sm`;
            const playable = !isAi && isCardPlayable(character, card);
            if (!playable) cardEl.classList.add('unplayable');
            if (!isAi && gameState.selectedCard && gameState.selectedCard.index === index) cardEl.classList.add('selected');
            if (!isAi) cardEl.onclick = () => { if (playable) selectCard(index); };
            const fromRanksText = card.fromRanks ? `사용: ${card.fromRanks.join(',')}` : '';
            const toRanksText = card.toRanks.length > 0 ? `대상: ${card.toRanks.join(',')}` : '자신/전체';
            cardEl.innerHTML = `<div><div class="flex justify-between items-center"><h3 class="font-bold ${isAi ? 'text-sm' : 'text-base'}">${card.name}</h3><div class="font-bold ${isAi ? 'text-base' : 'text-lg'} text-yellow-400">${card.apCost} AP</div></div><p class="text-gray-300 mt-1 text-xs">${card.text}</p></div><div class="text-xs text-gray-400 mt-1"><div>${fromRanksText}</div><div>${toRanksText}</div></div>`;
            container.appendChild(cardEl);
        });
    }

    function showFloatingText(character, text, type) {
        const charEl = document.getElementById(character.id);
        if (!charEl) return;
        const rect = charEl.getBoundingClientRect();
        const textEl = document.createElement('div');
        textEl.className = `damage-text ${type}`;
        textEl.textContent = text;
        textEl.style.left = `${rect.left + rect.width / 2}px`;
        textEl.style.top = `${rect.top + rect.height / 2}px`;
        floatingTextContainerEl.appendChild(textEl);
        setTimeout(() => { floatingTextContainerEl.removeChild(textEl); }, 1500);
    }

    function getActiveCharacter() { return gameState.initiativeOrder[gameState.currentTurnIndex]; }
    function logMessage(message, type = 'info') {
        const p = document.createElement('p');
        let typeClass = 'text-gray-300';
        if (type === 'turn') typeClass = 'text-yellow-400 font-bold';
        if (type === 'round') typeClass = 'text-blue-400 font-bold';
        if (type === 'death') typeClass = 'text-red-500 font-bold';
        if (type === 'warning') typeClass = 'text-orange-400';
        p.className = typeClass;
        p.textContent = message;
        gameLogEl.appendChild(p);
        gameLogEl.scrollTop = gameLogEl.scrollHeight;
    }

    endTurnBtn.addEventListener('click', endTurn);
    document.addEventListener('DOMContentLoaded', initializeGame);
</script>
</body>
</html>

