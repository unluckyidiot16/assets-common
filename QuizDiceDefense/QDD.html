<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>다이스 랜덤 퀴즈 디펜스 (v2.4)</title>
    <style>
        :root {
            --canvas-bg: #dbe4ee;
            --grid-bg: #ffffff;
            --grid-border: #b0c4de;
            --path-color: #c5d3e0;
            --text-dark: #333;
            --qp-color: #2a9d8f;
            --hp-color: #e76f51;
            --wave-color: #f3a261;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen,
            Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            background-color: #f0f4f8;
            padding: 20px 10px;
            color: var(--text-dark);
            min-height: 100vh;
            box-sizing: border-box;
        }

        h1 {
            color: var(--text-dark);
            text-align: center;
            margin-bottom: 20px;
        }

        #game-container {
            display: flex;
            flex-wrap: nowrap; /* 기본은 옆으로 */
            justify-content: center;
            gap: 20px;
            width: 100%;
            max-width: 1050px; /* 최대 너비 조정 */
        }

        #left-panel {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        /* --- UI 패널 (HTML) --- */
        .panel {
            background-color: var(--grid-bg);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        #player-stats {
            display: flex;
            justify-content: space-between;
            font-size: 1.1em;
            font-weight: 500;
            margin-bottom: 15px;
        }
        #player-hp { color: var(--hp-color); font-weight: bold; }
        #wave-display { color: var(--wave-color); font-weight: bold; }

        #resource-display {
            font-size: 1.5em;
            font-weight: bold;
            color: var(--qp-color);
            margin-bottom: 10px;
        }
        #summon-dice-btn {
            width: 100%;
            padding: 15px;
            font-size: 1.2em;
            font-weight: bold;
            background-color: var(--hp-color);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        #summon-dice-btn:hover:not(:disabled) {
            background-color: #f4a261;
        }
        #summon-dice-btn:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        #summon-cost-display {
            font-size: 0.9em;
            color: #555;
            text-align: center;
            margin-top: 5px;
        }

        /* --- [수정] 강화 패널 --- */
        #upgrade-panel {
            display: grid;
            grid-template-columns: repeat(5, 1fr); /* 1줄 5칸 */
            gap: 10px;
            padding: 10px;
        }
        .upgrade-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px;
            border: 1px solid var(--grid-border);
            border-radius: 6px;
            cursor: pointer;
            transition: background-color 0.2s, box-shadow 0.2s;
        }
        .upgrade-section:hover {
            background-color: #f9f9f9;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .upgrade-section.disabled {
            background-color: #fdfdfd;
            color: #aaa;
            cursor: not-allowed;
            opacity: 0.7;
        }
        .upgrade-section.disabled:hover {
            box-shadow: none;
        }

        .dice-icon {
            width: 35px;
            height: 35px;
            border-radius: 6px;
            border: 2px solid white;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }
        .upgrade-info {
            font-size: 0.9em;
            font-weight: bold;
            text-align: center;
            color: #333;
            margin-top: 8px;
        }
        .upgrade-cost {
            font-size: 0.8em;
            color: var(--qp-color);
            font-weight: 500;
            margin-top: 4px;
        }
        .disabled .upgrade-cost {
            color: #aaa;
        }

        /* --- 캔버스 영역 --- */
        #game-canvas-container {
            border: 2px solid var(--grid-border);
            padding: 10px;
            border-radius: 8px;
            background-color: var(--canvas-bg);
            width: 510px;
            height: 430px;
            box-sizing: border-box;
        }

        #game-canvas {
            display: block;
            background-color: var(--canvas-bg);
            cursor: grab;
        }
        #game-canvas:active {
            cursor: grabbing;
        }

        /* --- 퀴즈 패널 (HTML) --- */
        #quiz-container {
            width: 400px;
            box-sizing: border-box;
        }

        #quiz-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        #quiz-timer-bar {
            height: 10px;
            flex-grow: 1;
            background-color: #eee;
            border-radius: 5px;
            overflow: hidden;
            margin-right: 15px;
        }
        #quiz-timer-progress {
            height: 100%;
            width: 100%;
            background-color: #4caf50;
            transition: width 0.1s linear;
        }
        #quiz-reward {
            font-size: 0.9em;
            font-weight: 500;
            color: var(--qp-color);
        }

        #question {
            font-size: 1.1em;
            font-weight: 500;
            margin-bottom: 15px;
            min-height: 50px;
        }

        #answer-options {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 15px;
        }

        .option-btn {
            padding: 12px;
            border: 1px solid #ddd;
            background-color: #f9f9f9;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s;
            text-align: left;
            font-size: 1em;
        }
        .option-btn:hover {
            background-color: #eef;
            border-color: #aac;
        }
        .option-btn.correct {
            background-color: #d4edda;
            border-color: #c3e6cb;
        }
        .option-btn.wrong {
            background-color: #f8d7da;
            border-color: #f5c6cb;
        }

        #skip-btn {
            padding: 10px;
            background-color: #6c757d;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9em;
            align-self: flex-end;
        }
        #skip-btn:hover {
            background-color: #5a6268;
        }
        #quiz-feedback {
            margin-top: 15px;
            font-weight: bold;
            text-align: center;
        }

        /* --- 게임 오버 모달 --- */
        #game-over-modal {
            display: none; /* 숨김 */
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            justify-content: center;
            align-items: center;
            z-index: 100;
        }
        #game-over-content {
            background-color: white;
            padding: 30px 40px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 5px 20px rgba(0,0,0,0.3);
        }
        #game-over-content h2 {
            font-size: 2.5em;
            color: var(--hp-color);
            margin-bottom: 20px;
        }
        #restart-btn {
            padding: 12px 25px;
            font-size: 1.2em;
            font-weight: bold;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        /* --- [수정] 모바일 반응형 --- */
        @media (max-width: 960px) { /* 태블릿/데스크탑 좁게 */
            body {
                padding: 10px 5px;
            }
            #game-container {
                flex-direction: column; /* 세로로 쌓기 */
                align-items: center;
            }
            #left-panel, #quiz-container {
                width: 98%;
                max-width: 530px; /* 캔버스 컨테이너 크기 + 여백 */
            }
            #game-canvas-container {
                width: 100%;
                height: auto;
                aspect-ratio: 510 / 430;
            }
            #game-canvas {
                width: 100%;
                height: 100%;
            }
            h1 {
                font-size: 1.5em;
            }
            /* 강화 패널 3열 */
            #upgrade-panel {
                grid-template-columns: repeat(3, 1fr);
            }
        }
        @media (max-width: 600px) {
            /* 강화 패널 2열 */
            #upgrade-panel {
                grid-template-columns: repeat(2, 1fr);
            }
        }
        @media (max-width: 450px) {
            /* 강화 패널 1열 (세로 모드) */
            #upgrade-panel {
                grid-template-columns: 1fr;
            }
        }

    </style>
</head>
<body>

<h1>다이스 랜덤 퀴즈 디펜스</h1>

<div id="game-container">
    <!-- 왼쪽: 게임 보드 및 UI -->
    <div id="left-panel">
        <div id="ui-panel" class="panel">
            <div id="player-stats">
                <span>HP: <span id="player-hp">20</span> / 20</span>
                <span>Wave: <span id="wave-display">0</span></span>
            </div>
            <div id="resource-display">QP: 100</div>
            <button id="summon-dice-btn">다이스 소환</button>
            <div id="summon-cost-display">비용: 50 QP</div>
        </div>

        <!-- [수정] 강화 패널 UI -->
        <div id="upgrade-panel" class="panel">
            <!-- Fire -->
            <div class="upgrade-section" id="upgrade-fire">
                <div class="dice-icon" style="background-color: #e74c3c;"></div>
                <div class="upgrade-info" id="fire-lvl">Lvl 1</div>
                <div class="upgrade-cost" id="fire-cost">100 QP</div>
            </div>
            <!-- Ice -->
            <div class="upgrade-section" id="upgrade-ice">
                <div class="dice-icon" style="background-color: #3498db;"></div>
                <div class="upgrade-info" id="ice-lvl">Lvl 1</div>
                <div class="upgrade-cost" id="ice-cost">100 QP</div>
            </div>
            <!-- Wind -->
            <div class="upgrade-section" id="upgrade-wind">
                <div class="dice-icon" style="background-color: #2ecc71;"></div>
                <div class="upgrade-info" id="wind-lvl">Lvl 1</div>
                <div class="upgrade-cost" id="wind-cost">100 QP</div>
            </div>
            <!-- Earth -->
            <div class="upgrade-section" id="upgrade-earth">
                <div class="dice-icon" style="background-color: #f39c12;"></div>
                <div class="upgrade-info" id="earth-lvl">Lvl 1</div>
                <div class="upgrade-cost" id="earth-cost">100 QP</div>
            </div>
            <!-- Light -->
            <div class="upgrade-section" id="upgrade-light">
                <div class="dice-icon" style="background-color: #f1c40f;"></div>
                <div class="upgrade-info" id="light-lvl">Lvl 1</div>
                <div class="upgrade-cost" id="light-cost">100 QP</div>
            </div>
        </div>

        <!-- 캔버스 영역 -->
        <div id="game-canvas-container">
            <canvas id="game-canvas"></canvas>
        </div>
    </div>

    <!-- 오른쪽: 퀴즈 패널 -->
    <div id="quiz-container" class="panel">
        <div id="quiz-header">
            <div id="quiz-timer-bar">
                <div id="quiz-timer-progress"></div>
            </div>
            <div id="quiz-reward">QP: 100</div>
        </div>
        <div id="question">퀴즈가 로드 중입니다...</div>
        <div id="answer-options"></div>
        <button id="skip-btn">스킵</button>
        <div id="quiz-feedback"></div>
    </div>
</div>

<!-- 게임 오버 모달 -->
<div id="game-over-modal">
    <div id="game-over-content">
        <h2>게임 오버</h2>
        <p>최종 웨이브: <span id="final-wave">0</span></p>
        <button id="restart-btn">다시 시작</button>
    </div>
</div>


<script>
    // --- 1. [수정] 퀴즈 데이터 (6학년 사회 - 지리, 문화 중심 100+) ---
    const quizData = [
        // 지리: 5대양 6대주
        { question: "세계에서 가장 큰 대륙은 어디인가요?", options: ["아프리카", "아시아", "북아메리카", "유럽"], answer: 1, difficulty: 'easy', reward: 50, time: 10 },
        { question: "세계에서 가장 큰 바다는 어디인가요?", options: ["대서양", "인도양", "북극해", "태평양"], answer: 3, difficulty: 'easy', reward: 50, time: 10 },
        { question: "6대주에 속하지 *않는* 것은 무엇인가요?", options: ["아시아", "유럽", "남극", "오세아니아"], answer: 2, difficulty: 'easy', reward: 50, time: 10 },
        { question: "아시아 대륙에 대한 설명으로 *틀린* 것은?", options: ["세계에서 가장 넓은 대륙이다", "세계에서 인구가 가장 많은 대륙이다", "세계에서 가장 긴 강(나일강)이 있다", "우리나라가 속해 있는 대륙이다"], answer: 2, difficulty: 'medium', reward: 100, time: 20 },
        { question: "오세아니아 대륙을 대표하는 나라는?", options: ["이집트", "브라질", "오스트레일리아", "캐나다"], answer: 2, difficulty: 'easy', reward: 50, time: 10 },
        { question: "아마존 열대 우림이 주로 위치한 대륙은?", options: ["아시아", "아프리카", "남아메리카", "북아메리카"], answer: 2, difficulty: 'medium', reward: 100, time: 15 },
        { question: "캥거루와 코알라의 고향으로 유명한 대륙은?", options: ["아프리카", "오세아니아", "남아메리카", "유럽"], answer: 1, difficulty: 'easy', reward: 50, time: 10 },
        { question: "이집트의 피라미드와 스핑크스가 있는 대륙은?", options: ["아시아", "유럽", "아프리카", "북아메리카"], answer: 2, difficulty: 'easy', reward: 50, time: 10 },
        { question: "세계에서 가장 작은 대륙은 어디인가요?", options: ["유럽", "오세아니아", "남아메리카", "북아메리카"], answer: 1, difficulty: 'easy', reward: 50, time: 10 },
        { question: "1년 내내 눈과 얼음으로 덮여있고 펭귄이 사는 추운 땅은?", options: ["북극", "시베리아", "남극 대륙", "그린란드"], answer: 2, difficulty: 'easy', reward: 50, time: 15 },
        { question: "세계에서 가장 인구가 적은 대륙은?", options: ["오세아니아", "남아메리카", "유럽", "북아메리카"], answer: 0, difficulty: 'medium', reward: 100, time: 15 },
        { question: "지구의 육지를 크게 나눈 6개의 큰 땅덩어리를 무엇이라고 하나요?", options: ["6대륙", "5대양", "6대주", "5대주"], answer: 2, difficulty: 'easy', reward: 50, time: 10 },
        { question: "지구의 바다를 크게 나눈 5개의 큰 바다를 무엇이라고 하나요?", options: ["6대륙", "5대양", "6대주", "5대주"], answer: 1, difficulty: 'easy', reward: 50, time: 10 },
        { question: "세계에서 가장 작은 바다는?", options: ["남극해", "북극해", "인도양", "대서양"], answer: 1, difficulty: 'medium', reward: 100, time: 15 },
        { question: "다음 중 5대양에 속하지 않는 바다는?", options: ["태평양", "대서양", "지중해", "인도양"], answer: 2, difficulty: 'easy', reward: 50, time: 10 },
        { question: "다음 중 6대주에 속하지 않는 대륙은?", options: ["아시아", "아프리카", "그린란드", "유럽"], answer: 2, difficulty: 'easy', reward: 50, time: 10 },

        // 지리: 지도, 지구본
        { question: "지구본의 장점이 *아닌* 것은 무엇인가요?", options: ["실제 지구의 모습을 축소함", "대륙과 바다의 크기 비교가 쉬움", "한눈에 전 세계를 볼 수 있음", "위치와 거리를 비교적 정확하게 표시함"], answer: 2, difficulty: 'medium', reward: 100, time: 20 },
        { question: "디지털 영상 지도의 특징으로 *틀린* 것은?", options: ["정보를 쉽게 수정하고 추가할 수 있다", "원하는 장소를 확대/축소하기 어렵다", "위성 사진을 통해 실제 모습을 볼 수 있다", "길 찾기, 거리 측정 등 다양한 기능이 있다"], answer: 1, difficulty: 'medium', reward: 100, time: 20 },
        { question: "지도에서 땅의 높낮이를 같은 지점끼리 연결한 선은?", options: ["등고선", "위선", "경선", "해안선"], answer: 0, difficulty: 'medium', reward: 100, time: 15 },
        { question: "지도에서 실제 거리를 줄인 비율을 무엇이라고 하나요?", options: ["축척", "범례", "방위", "등고선"], answer: 0, difficulty: 'medium', reward: 100, time: 15 },
        { question: "지도에서 기호를 설명해 놓은 부분은?", options: ["축척", "범례", "방위", "등고선"], answer: 1, difficulty: 'easy', reward: 50, time: 10 },
        { question: "지도의 위쪽이 항상 가리키는 방향은?", options: ["동", "서", "남", "북"], answer: 3, difficulty: 'easy', reward: 50, time: 10 },
        { question: "지구본에서 가로로 그어진 선을 무엇이라고 하나요?", options: ["위선", "경선", "적도", "본초 자오선"], answer: 0, difficulty: 'medium', reward: 100, time: 15 },
        { question: "지구본에서 세로로 그어진 선을 무엇이라고 하나요?", options: ["위선", "경선", "적도", "날짜 변경선"], answer: 1, difficulty: 'medium', reward: 100, time: 15 },
        { question: "위선의 기준이 되며 위도 0도인 선은?", options: ["북회귀선", "남회귀선", "본초 자오선", "적도"], answer: 3, difficulty: 'easy', reward: 50, time: 10 },
        { question: "경선의 기준이 되며 경도 0도인 선(영국 그리니치 천문대)은?", options: ["적도", "본초 자오선", "날짜 변경선", "남회귀선"], answer: 1, difficulty: 'medium', reward: 100, time: 20 },
        { question: "우리나라는 적도를 기준으로 어느 쪽에 위치하나요?", options: ["북쪽 (북반구)", "남쪽 (남반구)", "적도 위", "알 수 없음"], answer: 0, difficulty: 'easy', reward: 50, time: 10 },

        // 지리: 기후
        { question: "1년 내내 덥고 비가 많이 내리는 기후는?", options: ["열대 기후", "온대 기후", "한대 기후", "건조 기후"], answer: 0, difficulty: 'easy', reward: 50, time: 10 },
        { question: "사계절이 뚜렷하게 나타나는 기후는?", options: ["열대 기후", "온대 기후", "한대 기후", "고산 기후"], answer: 1, difficulty: 'easy', reward: 50, time: 10 },
        { question: "1년 내내 춥고, 사람들이 순록을 기르며 사는 기후는?", options: ["열대 기후", "건조 기후", "한대 기후", "온대 기후"], answer: 2, difficulty: 'medium', reward: 100, time: 20 },
        { question: "춥고 건조하며, 풀이 거의 자라지 않는 '툰드라'가 나타나는 기후는?", options: ["온대 기후", "건조 기후", "한대 기후", "열대 기후"], answer: 2, difficulty: 'medium', reward: 100, time: 15 },
        { question: "밀, 옥수수 등 농사를 짓기에 가장 적합하고 사계절이 뚜렷한 기후는?", options: ["온대 기후", "열대 기후", "한대 기후", "건조 기후"], answer: 0, difficulty: 'medium', reward: 100, time: 15 },
        { question: "사막이 넓게 나타나고, 강수량이 매우 적은 기후는?", options: ["열대 기후", "고산 기후", "냉대 기후", "건조 기후"], answer: 3, difficulty: 'easy', reward: 50, time: 10 },
        { question: "지중해 연안에서 주로 나타나며, 여름이 덥고 건조한 기후는?", options: ["열대 우림 기후", "지중해성 기후", "툰드라 기후", "사막 기후"], answer: 1, difficulty: 'medium', reward: 100, time: 20 },
        { question: "포도, 올리브 등을 많이 재배하는 기후는?", options: ["열대 기후", "한대 기후", "지중해성 기후", "냉대 기후"], answer: 2, difficulty: 'medium', reward: 100, time: 15 },
        { question: "북극곰이 사는 곳으로 매우 추운 기후 지역은?", options: ["한대 기후", "냉대 기후", "고산 기후", "온대 기후"], answer: 0, difficulty: 'easy', reward: 50, time: 10 },
        { question: "우리나라처럼 뚜렷한 사계절이 나타나는 기후는?", options: ["열대 기후", "냉대 기후", "온대 기후", "건조 기후"], answer: 2, difficulty: 'easy', reward: 50, time: 10 },
        { question: "1년 내내 기온이 높고, 비가 오는 계절과 오지 않는 계절이 뚜렷한 기후는?", options: ["사바나 기후", "지중해성 기후", "사막 기후", "툰드라 기후"], answer: 0, difficulty: 'medium', reward: 100, time: 20 },
        { question: "동남아시아나 인도처럼 계절에 따라 바람의 방향이 바뀌는 '계절풍'의 영향을 받는 기후는?", options: ["열대 몬순 기후", "서안 해양성 기후", "냉대 기후", "고산 기후"], answer: 0, difficulty: 'medium', reward: 100, time: 20 },
        { question: "해발 고도가 높아 1년 내내 봄처럼 선선한 기후는?", options: ["고산 기후", "냉대 기후", "한대 기후", "사막 기후"], answer: 0, difficulty: 'medium', reward: 100, time: 15 },

        // 지리: 환경 (자연/인문)
        { question: "산, 강, 바다, 날씨처럼 자연 그대로의 환경을 무엇이라고 하나요?", options: ["자연 환경", "인문 환경", "사회 환경", "도시 환경"], answer: 0, difficulty: 'easy', reward: 50, time: 15 },
        { question: "사람들이 만든 도시, 건물, 도로, 다리 등을 무엇이라고 하나요?", options: ["자연 환경", "인문 환경", "문화 환경", "지리 환경"], answer: 1, difficulty: 'easy', reward: 50, time: 15 },
        { question: "인문 환경에 해당하는 것을 고르세요.", options: ["사막", "높은 산", "논과 밭", "계절풍"], answer: 2, difficulty: 'medium', reward: 100, time: 15 },
        { question: "자연 환경에 해당하는 것을 고르세요.", options: ["공장", "아파트", "계절풍", "다리"], answer: 2, difficulty: 'medium', reward: 100, time: 15 },
        { question: "열대 기후 지역의 전통 가옥이 개방적인 이유는?", options: ["나무가 많아서", "춥고 눈이 많이 와서", "바람이 잘 통하고 시원하게", "동물의 침입을 막기 위해"], answer: 2, difficulty: 'medium', reward: 100, time: 20 },
        { question: "한대 기후 지역의 가옥이 폐쇄적이고 창이 작은 이유는?", options: ["나무가 부족해서", "추위를 막고 열을 보존하기 위해", "비가 많이 와서", "햇빛이 너무 강해서"], answer: 1, difficulty: 'medium', reward: 100, time: 20 },
        { question: "건조 기후 지역에서 집을 흙벽돌로 짓는 이유는?", options: ["흙이 많아서", "나무가 없어서", "비가 자주 와서", "낮의 열기를 막고 밤의 추위를 막기 위해"], answer: 3, difficulty: 'hard', reward: 150, time: 25 },

        // 지리: 국가, 수도, 랜드마크
        { question: "우리나라의 이웃 나라가 *아닌* 곳은?", options: ["중국", "일본", "러시아", "베트남"], answer: 3, difficulty: 'easy', reward: 50, time: 10 },
        { question: "일본의 수도는 어디인가요?", options: ["베이징", "도쿄", "오사카", "모스크바"], answer: 1, difficulty: 'easy', reward: 50, time: 10 },
        { question: "세계에서 영토가 가장 넓은 나라는?", options: ["중국", "캐나다", "미국", "러시아"], answer: 3, difficulty: 'medium', reward: 100, time: 15 },
        { question: "우리나라(대한민국)의 수도는 어디인가요?", options: ["부산", "인천", "평양", "서울"], answer: 3, difficulty: 'easy', reward: 50, time: 10 },
        { question: "'에펠탑'이 있는 나라는 어디인가요?", options: ["영국", "이탈리아", "독일", "프랑스"], answer: 3, difficulty: 'medium', reward: 100, time: 15 },
        { question: "'자유의 여신상'이 있는 나라는 어디인가요?", options: ["미국", "캐나다", "멕시코", "브라질"], answer: 0, difficulty: 'medium', reward: 100, time: 15 },
        { question: "중국의 수도는 어디인가요?", options: ["상하이", "홍콩", "베이징", "톈진"], answer: 2, difficulty: 'easy', reward: 50, time: 10 },
        { question: "러시아의 수도는 어디인가요?", options: ["상트페테르부르크", "키이우", "블라디보스토크", "모스크바"], answer: 3, difficulty: 'easy', reward: 50, time: 10 },
        { question: "세계에서 가장 높은 산인 '에베레스트산'이 있는 산맥은?", options: ["안데스산맥", "로키산맥", "알프스산맥", "히말라야산맥"], answer: 3, difficulty: 'medium', reward: 100, time: 20 },
        { question: "세계에서 가장 긴 강은?", options: ["아마존강", "나일강", "미시시피강", "양쯔강"], answer: 1, difficulty: 'medium', reward: 100, time: 15 },
        { question: "알프스산맥과 관련이 깊은 대륙은 어디인가요?", options: ["아시아", "유럽", "북아메리카", "아프리카"], answer: 1, difficulty: 'medium', reward: 100, time: 15 },
        { question: "미국의 수도는 어디인가요?", options: ["뉴욕", "로스앤젤레스", "워싱턴 D.C.", "시카고"], answer: 2, difficulty: 'medium', reward: 100, time: 15 },
        { question: "영국의 수도는 어디인가요?", options: ["파리", "로마", "베를린", "런던"], answer: 3, difficulty: 'medium', reward: 100, time: 15 },
        { question: "프랑스의 수도는 어디인가요?", options: ["파리", "리옹", "마르세유", "니스"], answer: 0, difficulty: 'medium', reward: 100, time: 15 },
        { question: "이탈리아의 수도는 어디인가요?", options: ["밀라노", "나폴리", "로마", "피렌체"], answer: 2, difficulty: 'medium', reward: 100, time: 15 },
        { question: "캐나다의 수도는 어디인가요?", options: ["토론토", "밴쿠버", "몬트리올", "오타와"], answer: 3, difficulty: 'hard', reward: 150, time: 20 },
        { question: "오스트레일리아(호주)의 수도는 어디인가요?", options: ["시드니", "멜버른", "캔버라", "브리즈번"], answer: 2, difficulty: 'hard', reward: 150, time: 20 },
        { question: "브라질의 수도는 어디인가요?", options: ["리우데자네이루", "상파울루", "브라질리아", "사우바도르"], answer: 2, difficulty: 'hard', reward: 150, time: 20 },
        { question: "이집트의 수도는 어디인가요?", options: ["알렉산드리아", "카이로", "기자", "룩소르"], answer: 1, difficulty: 'medium', reward: 100, time: 15 },
        { question: "인도의 수도는 어디인가요?", options: ["뭄바이", "콜카타", "뉴델리", "벵갈루루"], answer: 2, difficulty: 'medium', reward: 100, time: 15 },
        { question: "우리나라가 여름일 때, 오스트레일리아(호주)는 어떤 계절인가요?", options: ["여름", "가을", "겨울", "봄"], answer: 2, difficulty: 'medium', reward: 100, time: 15 },
        { question: "석유가 많이 생산되는 지역은?", options: ["유럽", "북극", "서남아시아(중동)", "동남아시아"], answer: 2, difficulty: 'medium', reward: 100, time: 15 },
        { question: "로키산맥이 위치한 대륙은?", options: ["북아메리카", "남아메리카", "아프리카", "유럽"], answer: 0, difficulty: 'medium', reward: 100, time: 15 },
        { question: "안데스산맥이 위치한 대륙은?", options: ["북아메리카", "남아메리카", "아시아", "오세아니아"], answer: 1, difficulty: 'medium', reward: 100, time: 15 },
        { question: "세계의 지붕이라고 불리는 고원은?", options: ["티베트고원", "콜로라도고원", "이란고원", "브라질고원"], answer: 0, difficulty: 'medium', reward: 100, time: 15 },
        { question: "다음 중 섬나라는?", options: ["이탈리아", "태국", "일본", "베트남"], answer: 2, difficulty: 'easy', reward: 50, time: 10 },
        { question: "독일의 수도는 어디인가요?", options: ["뮌헨", "함부르크", "프랑크푸르트", "베를린"], answer: 3, difficulty: 'medium', reward: 100, time: 15 },
        { question: "스페인의 수도는 어디인가요?", options: ["바르셀로나", "마드리드", "세비야", "발렌시아"], answer: 1, difficulty: 'medium', reward: 100, time: 15 },
        { question: "베트남의 수도는 어디인가요?", options: ["호찌민", "다낭", "하노이", "후에"], answer: 2, difficulty: 'medium', reward: 100, time: 15 },
        { question: "태국의 수도는 어디인가요?", options: ["방콕", "치앙마이", "푸껫", "파타야"], answer: 0, difficulty: 'medium', reward: 100, time: 15 },
        { question: "아르헨티나의 수도는 어디인가요?", options: ["부에노스아이레스", "산티아고", "리마", "보고타"], answer: 0, difficulty: 'hard', reward: 150, time: 20 },
        { question: "케냐의 수도는 어디인가요?", options: ["라고스", "나이로비", "카이로", "케이프타운"], answer: 1, difficulty: 'hard', reward: 150, time: 20 },
        { question: "중국의 '만리장성'은 어느 대륙에 있나요?", options: ["유럽", "아프리카", "아시아", "북아메리카"], answer: 2, difficulty: 'easy', reward: 50, time: 10 },
        { question: "이탈리아의 '콜로세움'은 어느 대륙에 있나요?", options: ["유럽", "아프리카", "아시아", "남아메리카"], answer: 0, difficulty: 'easy', reward: 50, time: 10 },
        { question: "페루의 '마추픽추'는 어느 대륙에 있나요?", options: ["아프리카", "아시아", "북아메리카", "남아메리카"], answer: 3, difficulty: 'medium', reward: 100, time: 15 },
        { question: "인도의 '타지마할'은 어느 대륙에 있나요?", options: ["아시아", "아프리카", "유럽", "오세아니아"], answer: 0, difficulty: 'easy', reward: 50, time: 10 },
        { question: "호주의 '오페라 하우스'는 어느 대륙에 있나요?", options: ["아시아", "오세아니아", "유럽", "북아메리카"], answer: 1, difficulty: 'easy', reward: 50, time: 10 },
        { question: "세계에서 가장 큰 사막인 '사하라 사막'은 어느 대륙에 있나요?", options: ["아시아", "오세아니아", "아프리카", "북아메리카"], answer: 2, difficulty: 'medium', reward: 100, time: 15 },
        { question: "아시아에 있는 '고비 사막'은 주로 어느 나라들에 걸쳐 있나요?", options: ["중국과 몽골", "인도와 파키스탄", "사우디아라비아", "카자흐스탄"], answer: 0, difficulty: 'hard', reward: 150, time: 25 },
        { question: "적도 부근에 위치한 나라들의 기후는?", options: ["열대 기후", "한대 기후", "온대 기후", "건조 기후"], answer: 0, difficulty: 'easy', reward: 50, time: 10 },
        { question: "북극이나 남극에 가까운 나라들의 기후는?", options: ["열대 기후", "한대 기후", "온대 기후", "건조 기후"], answer: 1, difficulty: 'easy', reward: 50, time: 10 },

        // 문화: 의식주, 전통
        { question: "세계 여러 나라의 전통 의상이 *아닌* 것은?", options: ["한복(한국)", "기모노(일본)", "치파오(중국)", "청바지(미국)"], answer: 3, difficulty: 'easy', reward: 50, time: 10 },
        { question: "인도의 여성들이 입는 전통 의상은?", options: ["사리", "아오자이", "한푸", "하카마"], answer: 0, difficulty: 'medium', reward: 100, time: 15 },
        { question: "베트남의 여성이 입는 긴 전통 의상은?", options: ["사리", "아오자이", "치파오", "기모노"], answer: 1, difficulty: 'medium', reward: 100, time: 15 },
        { question: "스코틀랜드 남성들이 입는 체크무늬 치마는?", options: ["킬트", "판초", "로인클로스", "토가"], answer: 0, difficulty: 'medium', reward: 100, time: 15 },
        { question: "밀을 주식으로 하는 지역에서 주로 먹는 음식은?", options: ["빵", "쌀밥", "감자", "옥수수"], answer: 0, difficulty: 'easy', reward: 50, time: 10 },
        { question: "쌀을 주식으로 하는 지역은 주로 어디인가요?", options: ["유럽", "아시아", "북아메리카", "오세아니아"], answer: 1, difficulty: 'easy', reward: 50, time: 10 },
        { question: "이탈리아의 대표적인 음식으로 *틀린* 것은?", options: ["피자", "파스타", "스시", "라자냐"], answer: 2, difficulty: 'easy', reward: 50, time: 10 },
        { question: "일본의 대표적인 음식으로, 식초로 간을 한 밥에 생선 등을 얹은 것은?", options: ["라멘", "스시", "카레", "돈카츠"], answer: 1, difficulty: 'easy', reward: 50, time: 10 },
        { question: "멕시코의 대표적인 음식으로, 토르티야에 고기, 채소 등을 싸 먹는 것은?", options: ["타코", "파에야", "부리토", "나초"], answer: 0, difficulty: 'medium', reward: 100, time: 15 },
        { question: "우리나라의 대표적인 발효 음식은?", options: ["피자", "김치", "스시", "빵"], answer: 1, difficulty: 'easy', reward: 50, time: 10 },
        { question: "더운 기후 지역의 전통 의상 특징은?", options: ["털가죽 옷", "몸에 붙는 옷", "얇고 헐렁한 옷", "검은색 옷"], answer: 2, difficulty: 'easy', reward: 50, time: 15 },
        { question: "추운 기후 지역의 전통 의상 특징은?", options: ["털가죽 옷", "얇은 면 옷", "반팔, 반바지", "헐렁한 옷"], answer: 0, difficulty: 'easy', reward: 50, time: 15 },
        { question: "건조 기후 지역에서 온몸을 감싸는 옷을 입는 이유는?", options: ["멋을 내기 위해", "강한 햇빛과 모래바람을 막기 위해", "종교적인 이유로", "추위를 막기 위해"], answer: 1, difficulty: 'medium', reward: 100, time: 20 },
        { question: "세계 여러 나라가 모여 평화와 안전을 논의하는 국제기구는?", options: ["NATO (나토)", "UN (국제 연합)", "WHO (세계 보건 기구)", "APEC (아시아 태평양 경제 협력체)"], answer: 1, difficulty: 'medium', reward: 100, time: 20 },
        { question: "4년마다 열리는 세계적인 스포츠 축제는?", options: ["월드컵", "동계 올림픽", "하계 올림픽", "아시안 게임"], answer: 2, difficulty: 'easy', reward: 50, time: 10 },
    ];


    // --- 2. 다이스 설정 ---
    const DICE_TYPES = ['fire', 'ice', 'wind', 'earth', 'light'];
    const DICE_CONFIG = {
        'fire': { name: '불', color: '#e74c3c' }, // 화상 DoT
        'ice': { name: '얼음', color: '#3498db' }, // 슬로우
        'wind': { name: '바람', color: '#2ecc71' }, // 중독 DoT
        'earth': { name: '대지', color: '#f39c12' }, // 스턴
        'light': { name: '빛', color: '#f1c40f' }, // 방어력 감소
    };
    const GRID_ROWS = 4;
    const GRID_COLS = 5;
    const GRID_SIZE = GRID_ROWS * GRID_COLS; // 20

    // --- 3. 캔버스 & 길(Path) 설정 ---
    const canvas = document.getElementById('game-canvas');
    const ctx = canvas.getContext('2d');

    const computedStyles = getComputedStyle(document.documentElement);
    const PATH_COLOR = computedStyles.getPropertyValue('--path-color').trim();
    const GRID_BG_COLOR = computedStyles.getPropertyValue('--grid-bg').trim();
    const GRID_BORDER_COLOR = computedStyles.getPropertyValue('--grid-border').trim();

    const CELL_SIZE = 70;
    const GAP = 10;
    const PATH_WIDTH = 50;

    const GRID_OFFSET_X = PATH_WIDTH;
    const GRID_OFFSET_Y = PATH_WIDTH;
    const GRID_WIDTH = (CELL_SIZE * GRID_COLS) + (GAP * (GRID_COLS - 1)); // (70*5)+(10*4) = 390
    const GRID_HEIGHT = (CELL_SIZE * GRID_ROWS) + (GAP * (GRID_ROWS - 1)); // (70*4)+(10*3) = 310

    canvas.width = GRID_WIDTH + PATH_WIDTH * 2; // 390 + 100 = 490
    canvas.height = GRID_HEIGHT + PATH_WIDTH * 2; // 310 + 100 = 410

    const pathCenter = PATH_WIDTH / 2; // 25
    const enemyPath = [
        { x: 0, y: pathCenter }, // Start (좌측 중앙)
        { x: pathCenter, y: pathCenter }, // 1. 좌측 상단 코너
        { x: canvas.width - pathCenter, y: pathCenter }, // 2. 우측 상단 코너
        { x: canvas.width - pathCenter, y: canvas.height - pathCenter }, // 3. 우측 하단 코너
        { x: pathCenter, y: canvas.height - pathCenter }, // 4. 좌측 하단 코너
        { x: pathCenter, y: pathCenter + 20 } // 5. End (베이스, 좌측 상단 코너 근처)
    ];

    // --- 4. 게임 상태 변수 ---
    let resources = 100;
    let summonCost = 50;
    let playerHP = 20;
    const MAX_HP = 20;
    let wave = 0;
    let enemiesToSpawn = 0;
    let spawnInterval;
    let gameRunning = false;

    let diceGrid = new Array(GRID_SIZE).fill(null);
    let enemies = [];
    let projectiles = [];
    let damageNumbers = [];

    // [수정] 다이스 강화 상태
    let diceUpgrades = {};
    const UPGRADE_COST_SCALING = 1.5; // 업그레이드 비용 증가 배율 (1.5배)
    const UPGRADE_COST_START = 100; // 초기 업그레이드 비용

    let currentQuiz = null;
    let quizTimerInterval;
    let timeLeft = 0;

    let dragState = {
        isDragging: false,
        die: null,
        startIndex: -1,
        x: 0,
        y: 0
    };
    let animationFrameId;

    // --- 5. DOM 요소 (HTML UI) ---
    const resourceDisplay = document.getElementById('resource-display');
    const summonBtn = document.getElementById('summon-dice-btn');
    const summonCostDisplay = document.getElementById('summon-cost-display');
    const hpDisplay = document.getElementById('player-hp');
    const waveDisplay = document.getElementById('wave-display');

    const questionEl = document.getElementById('question');
    const answerOptionsEl = document.getElementById('answer-options');
    const quizRewardDisplay = document.getElementById('quiz-reward');
    const timerBarProgress = document.getElementById('quiz-timer-progress');
    const skipBtn = document.getElementById('skip-btn');
    const quizFeedback = document.getElementById('quiz-feedback');

    const gameOverModal = document.getElementById('game-over-modal');
    const finalWaveDisplay = document.getElementById('final-wave');
    const restartBtn = document.getElementById('restart-btn');

    // [수정] 강화 패널 DOM 요소
    const upgradeDOMElements = {};
    DICE_TYPES.forEach(type => {
        upgradeDOMElements[type] = {
            section: document.getElementById(`upgrade-${type}`),
            lvl: document.getElementById(`${type}-lvl`),
            cost: document.getElementById(`${type}-cost`),
        };
    });


    // --- 6. 퀴즈 로직 (HTML UI 제어) ---
    function loadQuiz() {
        quizFeedback.textContent = '';
        answerOptionsEl.innerHTML = '';

        clearInterval(quizTimerInterval);
        currentQuiz = quizData[Math.floor(Math.random() * quizData.length)];

        questionEl.textContent = currentQuiz.question;
        quizRewardDisplay.textContent = `획득 QP: ${currentQuiz.reward}`;

        currentQuiz.options.forEach((option, index) => {
            const btn = document.createElement('button');
            btn.className = 'option-btn';
            btn.textContent = `${index + 1}. ${option}`;
            btn.onclick = () => checkAnswer(index, btn);
            answerOptionsEl.appendChild(btn);
        });

        timeLeft = currentQuiz.time;
        timerBarProgress.style.transition = 'none';
        timerBarProgress.style.width = '100%';

        setTimeout(() => {
            timerBarProgress.style.transition = `width ${timeLeft}s linear`;
            timerBarProgress.style.width = '0%';
        }, 50);

        quizTimerInterval = setInterval(() => {
            timeLeft -= 0.1;
            if (timeLeft <= 0) {
                skipQuiz();
            }
        }, 100);
    }

    function checkAnswer(userAnswerIndex, btnElement) {
        clearInterval(quizTimerInterval);
        Array.from(answerOptionsEl.children).forEach(btn => btn.disabled = true);

        const currentWidth = timerBarProgress.style.width;
        timerBarProgress.style.transition = 'none';
        timerBarProgress.style.width = currentWidth;

        const isCorrect = (userAnswerIndex === currentQuiz.answer);

        if (isCorrect) {
            quizFeedback.textContent = `정답! +${currentQuiz.reward} QP`;
            quizFeedback.style.color = 'green';
            btnElement.classList.add('correct');
            addResources(currentQuiz.reward);
        } else {
            quizFeedback.textContent = `오답... (정답: ${currentQuiz.options[currentQuiz.answer]})`;
            quizFeedback.style.color = 'red';
            btnElement.classList.add('wrong');
            answerOptionsEl.children[currentQuiz.answer].classList.add('correct');
        }

        setTimeout(loadQuiz, 1500);
    }

    function skipQuiz() {
        clearInterval(quizTimerInterval);
        quizFeedback.textContent = '스킵했습니다.';
        quizFeedback.style.color = 'gray';
        setTimeout(loadQuiz, 500);
    }
    skipBtn.onclick = skipQuiz;

    // --- 7. 게임 UI 로직 (HTML UI 제어) ---
    function addResources(amount) {
        resources += amount;
        updateUI();
    }

    function updateUI() {
        // 플레이어 스탯
        resourceDisplay.textContent = `QP: ${resources}`;
        summonCostDisplay.textContent = `비용: ${summonCost} QP`;
        summonBtn.disabled = resources < summonCost;
        hpDisplay.textContent = `${playerHP}`;
        waveDisplay.textContent = `${wave}`;

        // [수정] 강화 패널 UI 업데이트
        DICE_TYPES.forEach(type => {
            const upgrade = diceUpgrades[type];
            const els = upgradeDOMElements[type];

            els.lvl.textContent = `Lvl ${upgrade.level}`;
            els.cost.textContent = `${upgrade.cost} QP`;

            if (resources < upgrade.cost) {
                els.section.classList.add('disabled');
            } else {
                els.section.classList.remove('disabled');
            }
        });
    }

    // --- 7.5 [수정] 강화 로직 ---
    function initUpgrades() {
        diceUpgrades = {};
        DICE_TYPES.forEach(type => {
            diceUpgrades[type] = {
                level: 1,
                cost: UPGRADE_COST_START
            };

            // 이벤트 리스너 연결
            const els = upgradeDOMElements[type];
            els.section.onclick = () => handleUpgrade(type);
        });
    }

    function handleUpgrade(type) {
        const upgrade = diceUpgrades[type];

        if (resources >= upgrade.cost) {
            resources -= upgrade.cost;
            upgrade.level++;
            upgrade.cost = Math.floor(upgrade.cost * UPGRADE_COST_SCALING);
            updateUI(); // 변경된 내용 즉시 반영
        }
    }

    // --- 8. 다이스 소환 로직 (diceGrid 데이터 변경) ---
    function summonDice() {
        if (resources < summonCost) return;

        const emptyIndex = diceGrid.findIndex(cell => cell === null);
        if (emptyIndex === -1) {
            quizFeedback.textContent = '그리드가 꽉 찼습니다!';
            quizFeedback.style.color = 'orange';
            return;
        }

        resources -= summonCost;
        summonCost += 10;

        const randomType = DICE_TYPES[Math.floor(Math.random() * DICE_TYPES.length)];
        diceGrid[emptyIndex] = {
            type: randomType,
            pips: 1,
            cooldown: 0
        };

        updateUI();
    }
    summonBtn.onclick = summonDice;

    // --- 9. 캔버스 렌더링 로직 ---

    function gameLoop() {
        if (!gameRunning) return;

        clearCanvas();
        drawPath();
        drawGrid();
        drawDice();

        updateEnemies();
        drawEnemies();

        updateDiceAttacks();
        updateProjectiles();
        drawProjectiles();

        updateDamageNumbers();
        drawDamageNumbers();

        drawDraggingDice();

        animationFrameId = requestAnimationFrame(gameLoop);
    }

    function clearCanvas() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
    }

    function drawPath() {
        ctx.fillStyle = PATH_COLOR;
        ctx.fillRect(0, 0, canvas.width, PATH_WIDTH);
        ctx.fillRect(0, canvas.height - PATH_WIDTH, canvas.width, PATH_WIDTH);
        ctx.fillRect(0, PATH_WIDTH, PATH_WIDTH, GRID_HEIGHT);
        ctx.fillRect(canvas.width - PATH_WIDTH, PATH_WIDTH, PATH_WIDTH, GRID_HEIGHT);

        // '베이스' 표시 (삼각형)
        const basePos = enemyPath[enemyPath.length-1];
        const baseSize = 30;
        ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
        ctx.beginPath();
        ctx.moveTo(basePos.x, basePos.y - baseSize / 2);
        ctx.lineTo(basePos.x - baseSize / 2, basePos.y + baseSize / 2);
        ctx.lineTo(basePos.x + baseSize / 2, basePos.y + baseSize / 2);
        ctx.closePath();
        ctx.fill();
    }

    function drawGrid() {
        ctx.strokeStyle = GRID_BORDER_COLOR;
        ctx.fillStyle = GRID_BG_COLOR;

        for (let i = 0; i < GRID_SIZE; i++) {
            const { x, y } = getGridCoords(i);

            ctx.beginPath();
            ctx.roundRect(x, y, CELL_SIZE, CELL_SIZE, 6);
            ctx.fill();
            ctx.stroke();
        }
    }

    function drawDice() {
        for (let i = 0; i < GRID_SIZE; i++) {
            const die = diceGrid[i];
            if (die && !(dragState.isDragging && dragState.startIndex === i)) {
                const { x, y } = getGridCoords(i);
                drawDie(x, y, die);
            }
        }
    }

    function drawDraggingDice() {
        if (dragState.isDragging && dragState.die) {
            const x = dragState.x - CELL_SIZE / 2;
            const y = dragState.y - CELL_SIZE / 2;
            ctx.save();
            ctx.globalAlpha = 0.7;
            ctx.shadowColor = 'rgba(0,0,0,0.3)';
            ctx.shadowBlur = 10;
            drawDie(x, y, dragState.die);
            ctx.restore();
        }
    }

    function drawDie(x, y, die) {
        ctx.fillStyle = DICE_CONFIG[die.type].color;
        ctx.beginPath();
        ctx.roundRect(x, y, CELL_SIZE, CELL_SIZE, 10);
        ctx.fill();
        drawPips(x, y, die.pips);
    }

    function drawPips(x, y, pips) {
        const pipSize = 5;
        const padding = 12;
        const center = CELL_SIZE / 2;
        const left = padding, right = CELL_SIZE - padding;
        const top = padding, bottom = CELL_SIZE - padding;

        const positions = {
            1: [[center, center]],
            2: [[left, top], [right, bottom]],
            3: [[left, top], [center, center], [right, bottom]],
            4: [[left, top], [right, top], [left, bottom], [right, bottom]],
            5: [[left, top], [right, top], [center, center], [left, bottom], [right, bottom]],
            6: [[left, top], [right, top], [left, center], [right, center], [left, bottom], [right, bottom]],
            7: [[left, top], [right, top], [left, center], [center, center], [right, center], [left, bottom], [right, bottom]]
        };

        const pipsToDraw = positions[pips] || positions[7];

        ctx.fillStyle = 'white';
        ctx.shadowColor = 'rgba(0,0,0,0.5)';
        ctx.shadowBlur = 2;

        pipsToDraw.forEach(([px, py]) => {
            ctx.beginPath();
            ctx.arc(x + px, y + py, pipSize, 0, Math.PI * 2);
            ctx.fill();
        });

        ctx.shadowColor = 'transparent';
        ctx.shadowBlur = 0;
    }

    // --- 10. 적 (Enemy) 로직 ---

    class Enemy {
        constructor(isBoss = false) {
            this.isBoss = isBoss;
            this.pathIndex = 1;
            this.statusEffects = {};

            // [수정] 계단형 난이도 계산
            const chapter = Math.max(0, Math.floor((wave - 1) / 10)); // wave 1~10 = chap 0

            if (isBoss) {
                this.x = enemyPath[0].x;
                this.y = enemyPath[0].y;
                this.originalSpeed = 0.5 + (chapter * 0.15); // [수정] 챕터별 속도
                this.speed = this.originalSpeed;
                this.maxHp = (500 + (wave * 100)) * Math.pow(2.2, chapter); // [수정] 챕터별 HP
                this.hp = this.maxHp;
                this.radius = 20;
                this.color = '#8e44ad';
            } else {
                this.x = enemyPath[0].x;
                this.y = enemyPath[0].y;
                this.originalSpeed = 1 + (chapter * 0.3) + (wave * 0.01); // [수정] 챕터별/웨이브별 속도
                this.speed = this.originalSpeed;
                this.maxHp = (50 + (wave * 15)) * Math.pow(2.2, chapter); // [수정] 챕터별/웨이브별 HP
                this.hp = this.maxHp;
                this.radius = 10;
                this.color = '#c0392b';
            }
        }

        applyStatus(type, pips) {
            switch(type) {
                case 'ice':
                    this.statusEffects.slow = { duration: 120 }; // 2초
                    this.speed = this.originalSpeed * 0.5;
                    break;
                case 'fire':
                    this.statusEffects.burn = { duration: 180, damage: pips * 2, tick: 60 };
                    break;
                case 'wind':
                    this.statusEffects.poison = { duration: 300, damage: pips * 1, tick: 60 };
                    break;
                case 'earth':
                    this.statusEffects.stun = { duration: 15 }; // 0.25초
                    break;
                case 'light':
                    this.statusEffects.armorBreak = { duration: 240 }; // 4초
                    break;
            }
        }

        updateStatusEffects() {
            for (const key in this.statusEffects) {
                const effect = this.statusEffects[key];
                effect.duration--;

                if (key === 'burn' || key === 'poison') {
                    effect.tick--;
                    if (effect.tick <= 0) {
                        const upgrade = diceUpgrades[key === 'burn' ? 'fire' : 'wind'];
                        const dotDamage = Math.round(effect.damage * (1 + (upgrade.level - 1) * 0.1));
                        this.hp -= dotDamage;
                        createDamageNumber(this.x, this.y - this.radius, dotDamage, (key === 'burn' ? '#e74c3c' : '#2ecc71'));
                        effect.tick = 60;
                    }
                }

                if (effect.duration <= 0) {
                    if (key === 'slow') {
                        this.speed = this.originalSpeed;
                    }
                    delete this.statusEffects[key];
                }
            }
        }

        move() {
            this.updateStatusEffects();

            if (this.statusEffects.stun) return;
            if (this.pathIndex >= enemyPath.length) return;

            const target = enemyPath[this.pathIndex];
            const dx = target.x - this.x;
            const dy = target.y - this.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            if (dist < this.speed) {
                this.x = target.x;
                this.y = target.y;
                this.pathIndex++;
            } else {
                this.x += (dx / dist) * this.speed;
                this.y += (dy / dist) * this.speed;
            }
        }

        draw() {
            ctx.fillStyle = this.color;
            if (this.statusEffects.slow) ctx.fillStyle = '#3498db';
            if (this.statusEffects.poison) ctx.fillStyle = '#2ecc71';
            if (this.statusEffects.armorBreak) ctx.fillStyle = '#f1c40f';

            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            ctx.fill();

            if(this.statusEffects.burn) {
                ctx.strokeStyle = '#e74c3c';
                ctx.lineWidth = 3;
                ctx.stroke();
            }
            if(this.statusEffects.stun) {
                ctx.fillStyle = 'white';
                ctx.font = 'bold 12px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Stun!', this.x, this.y - this.radius - 15);
            }

            const hpBarWidth = this.isBoss ? 40 : 20;
            const hpBarHeight = 4;
            const hpPercent = this.hp / this.maxHp;
            ctx.fillStyle = '#e74c3c';
            ctx.fillRect(this.x - hpBarWidth / 2, this.y - this.radius - 10, hpBarWidth, hpBarHeight);
            ctx.fillStyle = '#2ecc71';
            ctx.fillRect(this.x - hpBarWidth / 2, this.y - this.radius - 10, hpBarWidth * hpPercent, hpBarHeight);
        }
    }

    function startNextWave() {
        wave++;
        waveDisplay.textContent = wave;

        // [수정] 계단형 난이도 계산
        const chapter = Math.max(0, Math.floor((wave - 1) / 10));

        if (wave % 5 === 0) {
            enemies.push(new Enemy(true));
            enemiesToSpawn = 0;
            clearInterval(spawnInterval);
        } else {
            enemiesToSpawn = 10 + (wave * 2) + (chapter * 10); // [수정] 챕터별 스폰 수
            spawnInterval = setInterval(() => {
                if (enemiesToSpawn > 0) {
                    enemies.push(new Enemy(false));
                    enemiesToSpawn--;
                } else {
                    clearInterval(spawnInterval);
                }
            }, Math.max(200, 1000 - (wave * 20) - (chapter * 50))); // [수정] 스폰 속도도 챕터별로 빨라짐
        }
    }

    function updateEnemies() {
        let waveOver = (enemiesToSpawn === 0 && enemies.length === 0);

        for (let i = enemies.length - 1; i >= 0; i--) {
            const enemy = enemies[i];
            enemy.move();

            if (enemy.pathIndex >= enemyPath.length) {
                enemies.splice(i, 1);
                playerHP--;
                if (playerHP <= 0) {
                    playerHP = 0;
                    gameOver();
                }
                updateUI();
            } else if (enemy.hp <= 0) {
                const reward = enemy.isBoss ? (100 + wave * 10) : (5 + wave);
                addResources(reward);
                enemies.splice(i, 1);
            }
        }

        if (waveOver && gameRunning) {
            startNextWave();
        }
    }

    function drawEnemies() {
        enemies.forEach(enemy => enemy.draw());
    }

    // --- 11. 다이스 공격 & 발사체 로직 ---

    class Projectile {
        constructor(x, y, target, die) {
            this.x = x;
            this.y = y;
            this.target = target;
            this.speed = 5;
            this.pips = die.pips;
            this.type = die.type;
            this.color = DICE_CONFIG[die.type].color;
            this.radius = 4;

            // [수정] 데미지 계산에 강화 레벨 적용
            const upgrade = diceUpgrades[this.type];
            const baseDamage = die.pips * 10 + (die.pips - 1) * 5;
            this.damage = Math.round(baseDamage * (1 + (upgrade.level - 1) * 0.1)); // 레벨당 10%
        }

        move() {
            if (!this.target || this.target.hp <= 0) return false;

            const dx = this.target.x - this.x;
            const dy = this.target.y - this.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            if (dist < this.speed) {
                let damageDealt = this.damage;
                if (this.target.statusEffects.armorBreak) {
                    damageDealt *= 1.3;
                }
                damageDealt = Math.round(damageDealt);

                this.target.hp -= damageDealt;
                createDamageNumber(this.target.x, this.target.y - this.target.radius, damageDealt, this.color);
                this.target.applyStatus(this.type, this.pips);

                return false;
            } else {
                this.x += (dx / dist) * this.speed;
                this.y += (dy / dist) * this.speed;
                return true;
            }
        }

        draw() {
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            ctx.fill();
        }
    }

    function findTarget(dieX, dieY, range) {
        let closestEnemy = null;
        let minRange = range;
        for (const enemy of enemies) {
            const dx = enemy.x - dieX;
            const dy = enemy.y - dieY;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < minRange) {
                minRange = dist;
                closestEnemy = enemy;
            }
        }
        return closestEnemy;
    }

    function updateDiceAttacks() {
        for (let i = 0; i < diceGrid.length; i++) {
            const die = diceGrid[i];
            if (!die) continue;

            if (die.cooldown > 0) {
                die.cooldown--;
                continue;
            }

            const { x, y } = getGridCoords(i);
            const dieCenterX = x + CELL_SIZE / 2;
            const dieCenterY = y + CELL_SIZE / 2;
            const range = 100 + die.pips * 15;

            let target = findTarget(dieCenterX, dieCenterY, range);
            if (target) {
                projectiles.push(new Projectile(dieCenterX, dieCenterY, target, die));
                // [수정] 쿨다운 계산에 강화 레벨 적용
                const upgrade = diceUpgrades[die.type];
                const baseCooldown = 60 - die.pips * 5;
                die.cooldown = Math.max(10, Math.round(baseCooldown * Math.pow(0.95, upgrade.level - 1))); // 레벨당 5% 감소, 최소 10프레임
            }
        }
    }

    function updateProjectiles() {
        for (let i = projectiles.length - 1; i >= 0; i--) {
            if (!projectiles[i].move()) {
                projectiles.splice(i, 1);
            }
        }
    }

    function drawProjectiles() {
        projectiles.forEach(p => p.draw());
    }

    // --- 11.5 데미지 숫자 로직 ---
    function createDamageNumber(x, y, text, color) {
        damageNumbers.push({
            x,
            y,
            text: Math.round(text),
            color,
            alpha: 1.0,
            duration: 60 // 1초
        });
    }

    function updateDamageNumbers() {
        for (let i = damageNumbers.length - 1; i >= 0; i--) {
            const dn = damageNumbers[i];
            dn.y -= 0.5;
            dn.duration--;
            dn.alpha = dn.duration / 60;

            if (dn.duration <= 0) {
                damageNumbers.splice(i, 1);
            }
        }
    }

    function drawDamageNumbers() {
        ctx.save();
        ctx.font = 'bold 14px sans-serif';
        ctx.textAlign = 'center';
        for (const dn of damageNumbers) {
            ctx.globalAlpha = dn.alpha;
            ctx.fillStyle = dn.color;
            ctx.fillText(dn.text, dn.x, dn.y);
        }
        ctx.restore();
    }


    // --- 12. 캔버스 이벤트 핸들링 (드래그 앤 드롭) ---
    function getMousePos(e) {
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        let x, y;

        if (e.changedTouches) {
            x = (e.changedTouches[0].clientX - rect.left) * scaleX;
            y = (e.changedTouches[0].clientY - rect.top) * scaleY;
        } else {
            x = (e.clientX - rect.left) * scaleX;
            y = (e.clientY - rect.top) * scaleY;
        }
        return { x, y };
    }

    function getGridIndexFromPos(x, y) {
        const gridX = x - GRID_OFFSET_X;
        const gridY = y - GRID_OFFSET_Y;

        for (let i = 0; i < GRID_SIZE; i++) {
            const col = i % GRID_COLS;
            const row = Math.floor(i / GRID_COLS);
            const cellX = col * (CELL_SIZE + GAP);
            const cellY = row * (CELL_SIZE + GAP);

            if (gridX >= cellX && gridX <= cellX + CELL_SIZE &&
                gridY >= cellY && gridY <= cellY + CELL_SIZE) {
                return i;
            }
        }
        return -1;
    }

    function getGridCoords(index) {
        const row = Math.floor(index / GRID_COLS);
        const col = index % GRID_COLS;
        const x = GRID_OFFSET_X + col * (CELL_SIZE + GAP);
        const y = GRID_OFFSET_Y + row * (CELL_SIZE + GAP);
        return { x, y };
    }

    function handleDragStart(e) {
        e.preventDefault();
        const { x, y } = getMousePos(e);
        const index = getGridIndexFromPos(x, y);

        if (index !== -1 && diceGrid[index]) {
            dragState.isDragging = true;
            dragState.startIndex = index;
            dragState.die = { ...diceGrid[index] };
            dragState.x = x;
            dragState.y = y;
            diceGrid[index] = null;
        }
    }

    function handleDragMove(e) {
        if (!dragState.isDragging) return;
        e.preventDefault();
        const { x, y } = getMousePos(e);
        dragState.x = x;
        dragState.y = y;
    }

    function handleDragEnd(e) {
        if (!dragState.isDragging) return;
        e.preventDefault();

        const { x, y } = getMousePos(e);
        const dropIndex = getGridIndexFromPos(x, y);
        const dragDice = dragState.die;
        const startIndex = dragState.startIndex;

        if (dropIndex === -1) {
            diceGrid[startIndex] = dragDice;
        } else {
            const dropDice = diceGrid[dropIndex];

            if (dropDice === null) {
                diceGrid[dropIndex] = dragDice;
            } else {
                if (dragDice.type === dropDice.type && dragDice.pips === dropDice.pips) {
                    diceGrid[dropIndex].pips += 1;
                    diceGrid[dropIndex].cooldown = 0;
                } else {
                    diceGrid[startIndex] = dropDice;
                    diceGrid[dropIndex] = dragDice;
                }
            }
        }

        dragState.isDragging = false;
        dragState.die = null;
        dragState.startIndex = -1;
    }

    canvas.addEventListener('mousedown', handleDragStart);
    canvas.addEventListener('mousemove', handleDragMove);
    canvas.addEventListener('mouseup', handleDragEnd);
    canvas.addEventListener('mouseleave', handleDragEnd);
    canvas.addEventListener('touchstart', handleDragStart, { passive: false });
    canvas.addEventListener('touchmove', handleDragMove, { passive: false });
    canvas.addEventListener('touchend', handleDragEnd, { passive: false });


    // --- 13. 게임 시작/종료 로직 ---

    function gameOver() {
        gameRunning = false;
        cancelAnimationFrame(animationFrameId);
        clearInterval(spawnInterval);
        clearInterval(quizTimerInterval);

        finalWaveDisplay.textContent = wave;
        gameOverModal.style.display = 'flex';
    }

    function resetGame() {
        gameRunning = false;
        cancelAnimationFrame(animationFrameId);
        clearInterval(spawnInterval);
        clearInterval(quizTimerInterval);

        resources = 100;
        summonCost = 50;
        playerHP = MAX_HP;
        wave = 0;
        enemiesToSpawn = 0;

        diceGrid = new Array(GRID_SIZE).fill(null);
        enemies = [];
        projectiles = [];
        damageNumbers = [];

        initUpgrades(); // 강화 상태 리셋

        updateUI();
        gameOverModal.style.display = 'none';

        gameRunning = true;
        loadQuiz();
        startNextWave();
        animationFrameId = requestAnimationFrame(gameLoop);
    }

    restartBtn.onclick = resetGame;

    function initGame() {
        gameRunning = true;
        initUpgrades(); // 강화 시스템 초기화
        loadQuiz();
        updateUI();
        startNextWave();
        animationFrameId = requestAnimationFrame(gameLoop);
    }

    initGame();

</script>
</body>
</html>