<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>다이스 랜덤 퀴즈 디펜스 (v2.2)</title>
    <style>
        :root {
            --canvas-bg: #dbe4ee;
            --grid-bg: #ffffff;
            --grid-border: #b0c4de;
            --path-color: #c5d3e0;
            --text-dark: #333;
            --qp-color: #2a9d8f;
            --hp-color: #e76f51;
            --wave-color: #f3a261;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen,
            Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            background-color: #f0f4f8;
            padding: 20px 10px;
            color: var(--text-dark);
            min-height: 100vh;
            box-sizing: border-box;
        }

        h1 {
            color: var(--text-dark);
            text-align: center;
        }

        #game-container {
            display: flex;
            flex-wrap: nowrap; /* 기본은 옆으로 */
            justify-content: center;
            gap: 20px;
            width: 100%;
            max-width: 1050px; /* 최대 너비 조정 */
        }

        #left-panel {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        /* --- UI 패널 (HTML) --- */
        #ui-panel {
            background-color: var(--grid-bg);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        #player-stats {
            display: flex;
            justify-content: space-between;
            font-size: 1.1em;
            font-weight: 500;
            margin-bottom: 15px;
        }
        #player-hp { color: var(--hp-color); font-weight: bold; }
        #wave-display { color: var(--wave-color); font-weight: bold; }

        #resource-display {
            font-size: 1.5em;
            font-weight: bold;
            color: var(--qp-color);
            margin-bottom: 10px;
        }
        #summon-dice-btn {
            width: 100%;
            padding: 15px;
            font-size: 1.2em;
            font-weight: bold;
            background-color: var(--hp-color);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        #summon-dice-btn:hover:not(:disabled) {
            background-color: #f4a261;
        }
        #summon-dice-btn:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        #summon-cost-display {
            font-size: 0.9em;
            color: #555;
            text-align: center;
            margin-top: 5px;
        }

        /* --- 캔버스 영역 --- */
        #game-canvas-container {
            border: 2px solid var(--grid-border);
            padding: 10px;
            border-radius: 8px;
            background-color: var(--canvas-bg);
            /* 캔버스 크기(490x410) + 패딩(10*2) */
            width: 510px;
            height: 430px;
            box-sizing: border-box; /* 패딩 포함 크기 */
        }

        #game-canvas {
            display: block;
            background-color: var(--canvas-bg);
            cursor: grab;
        }
        #game-canvas:active {
            cursor: grabbing;
        }

        /* --- 퀴즈 패널 (HTML) --- */
        #quiz-container {
            width: 400px;
            background-color: var(--grid-bg);
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            box-sizing: border-box;
        }

        #quiz-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        #quiz-timer-bar {
            height: 10px;
            flex-grow: 1;
            background-color: #eee;
            border-radius: 5px;
            overflow: hidden;
            margin-right: 15px;
        }
        #quiz-timer-progress {
            height: 100%;
            width: 100%;
            background-color: #4caf50;
            transition: width 0.1s linear;
        }
        #quiz-reward {
            font-size: 0.9em;
            font-weight: 500;
            color: var(--qp-color);
        }

        #question {
            font-size: 1.1em;
            font-weight: 500;
            margin-bottom: 15px;
            min-height: 50px;
        }

        #answer-options {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 15px;
        }

        .option-btn {
            padding: 12px;
            border: 1px solid #ddd;
            background-color: #f9f9f9;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s;
            text-align: left;
            font-size: 1em;
        }
        .option-btn:hover {
            background-color: #eef;
            border-color: #aac;
        }
        .option-btn.correct {
            background-color: #d4edda;
            border-color: #c3e6cb;
        }
        .option-btn.wrong {
            background-color: #f8d7da;
            border-color: #f5c6cb;
        }

        #skip-btn {
            padding: 10px;
            background-color: #6c757d;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9em;
            align-self: flex-end;
        }
        #skip-btn:hover {
            background-color: #5a6268;
        }
        #quiz-feedback {
            margin-top: 15px;
            font-weight: bold;
            text-align: center;
        }

        /* --- 게임 오버 모달 --- */
        #game-over-modal {
            display: none; /* 숨김 */
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            justify-content: center;
            align-items: center;
            z-index: 100;
        }
        #game-over-content {
            background-color: white;
            padding: 30px 40px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 5px 20px rgba(0,0,0,0.3);
        }
        #game-over-content h2 {
            font-size: 2.5em;
            color: var(--hp-color);
            margin-bottom: 20px;
        }
        #restart-btn {
            padding: 12px 25px;
            font-size: 1.2em;
            font-weight: bold;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        /* --- 모바일 반응형 --- */
        @media (max-width: 960px) { /* 너비 기준 변경 */
            body {
                padding: 10px 5px;
            }
            #game-container {
                flex-direction: column; /* 세로로 쌓기 */
                align-items: center;
            }
            #left-panel, #quiz-container {
                width: 98%;
                max-width: 530px; /* 캔버스 컨테이너 크기 + 여백 */
            }
            #game-canvas-container {
                width: 100%;
                /* 캔버스 비율 유지를 위해 510:430 */
                height: auto;
                aspect-ratio: 510 / 430;
            }
            #game-canvas {
                width: 100%;
                height: 100%;
            }
            h1 {
                font-size: 1.5em;
            }
        }

    </style>
</head>
<body>

<h1>다이스 랜덤 퀴즈 디펜스</h1>

<div id="game-container">
    <!-- 왼쪽: 게임 보드 및 UI -->
    <div id="left-panel">
        <div id="ui-panel">
            <div id="player-stats">
                <span>HP: <span id="player-hp">20</span> / 20</span>
                <span>Wave: <span id="wave-display">0</span></span>
            </div>
            <div id="resource-display">QP: 100</div>
            <button id="summon-dice-btn">다이스 소환</button>
            <div id="summon-cost-display">비용: 50 QP</div>
        </div>
        <!-- 캔버스 영역 -->
        <div id="game-canvas-container">
            <canvas id="game-canvas"></canvas>
        </div>
    </div>

    <!-- 오른쪽: 퀴즈 패널 -->
    <div id="quiz-container">
        <div id="quiz-header">
            <div id="quiz-timer-bar">
                <div id="quiz-timer-progress"></div>
            </div>
            <div id="quiz-reward">QP: 100</div>
        </div>
        <div id="question">퀴즈가 로드 중입니다...</div>
        <div id="answer-options"></div>
        <button id="skip-btn">스킵</button>
        <div id="quiz-feedback"></div>
    </div>
</div>

<!-- 게임 오버 모달 -->
<div id="game-over-modal">
    <div id="game-over-content">
        <h2>게임 오버</h2>
        <p>최종 웨이브: <span id="final-wave">0</span></p>
        <button id="restart-btn">다시 시작</button>
    </div>
</div>


<script>
    // --- 1. 퀴즈 데이터 (6학년 사회, 4지선다) ---
    const quizData = [
        // 세계지도, 지구본
        { question: "세계에서 가장 큰 대륙은 어디인가요?", options: ["아프리카", "아시아", "북아메리카", "유럽"], answer: 1, difficulty: 'easy', reward: 50, time: 10 },
        { question: "지구본의 장점이 *아닌* 것은 무엇인가요?", options: ["실제 지구의 모습을 축소함", "대륙과 바다의 크기 비교가 쉬움", "한눈에 전 세계를 볼 수 있음", "위치와 거리를 비교적 정확하게 표시함"], answer: 2, difficulty: 'medium', reward: 100, time: 20 },
        { question: "디지털 영상 지도의 특징으로 *틀린* 것은?", options: ["정보를 쉽게 수정하고 추가할 수 있다", "원하는 장소를 확대/축소하기 어렵다", "위성 사진을 통해 실제 모습을 볼 수 있다", "길 찾기, 거리 측정 등 다양한 기능이 있다"], answer: 1, difficulty: 'medium', reward: 100, time: 20 },

        // 5대양 6대주
        { question: "세계에서 가장 큰 바다는 어디인가요?", options: ["대서양", "인도양", "북극해", "태평양"], answer: 3, difficulty: 'easy', reward: 50, time: 10 },
        { question: "6대주에 속하지 *않는* 것은 무엇인가요?", options: ["아시아", "유럽", "남극", "오세아니아"], answer: 2, difficulty: 'easy', reward: 50, time: 10 },
        { question: "아시아 대륙에 대한 설명으로 *틀린* 것은?", options: ["세계에서 가장 넓은 대륙이다", "세계에서 인구가 가장 많은 대륙이다", "세계에서 가장 긴 강(나일강)이 있다", "우리나라가 속해 있는 대륙이다"], answer: 2, difficulty: 'medium', reward: 100, time: 20 },
        { question: "오세아니아 대륙을 대표하는 나라는?", options: ["이집트", "브라질", "오스트레일리아", "캐나다"], answer: 2, difficulty: 'easy', reward: 50, time: 10 },

        // 기후
        { question: "1년 내내 덥고 비가 많이 내리는 기후는?", options: ["열대 기후", "온대 기후", "한대 기후", "건조 기후"], answer: 0, difficulty: 'easy', reward: 50, time: 10 },
        { question: "사계절이 뚜렷하게 나타나는 기후는?", options: ["열대 기후", "온대 기후", "한대 기후", "고산 기후"], answer: 1, difficulty: 'easy', reward: 50, time: 10 },
        { question: "1년 내내 춥고, 사람들이 순록을 기르며 사는 기후는?", options: ["열대 기후", "건조 기후", "한대 기후", "온대 기후"], answer: 2, difficulty: 'medium', reward: 100, time: 20 },
        { question: "아마존 열대 우림이 주로 위치한 대륙은?", options: ["아시아", "아프리카", "남아메리카", "북아메리카"], answer: 2, difficulty: 'medium', reward: 100, time: 15 },

        // 환경 (자연/인문)
        { question: "산, 강, 바다, 날씨처럼 자연 그대로의 환경을 무엇이라고 하나요?", options: ["자연 환경", "인문 환경", "사회 환경", "도시 환경"], answer: 0, difficulty: 'easy', reward: 50, time: 15 },
        { question: "사람들이 만든 도시, 건물, 도로, 다리 등을 무엇이라고 하나요?", options: ["자연 환경", "인문 환경", "문화 환경", "지리 환경"], answer: 1, difficulty: 'easy', reward: 50, time: 15 },
        { question: "인문 환경에 해당하는 것을 고르세요.", options: ["사막", "높은 산", "논과 밭", "계절풍"], answer: 2, difficulty: 'medium', reward: 100, time: 15 },

        // 이웃 나라
        { question: "우리나라의 이웃 나라가 *아닌* 곳은?", options: ["중국", "일본", "러시아", "베트남"], answer: 3, difficulty: 'easy', reward: 50, time: 10 },
        { question: "세계에서 인구가 가장 많은 나라는? (2024년 기준 1위)", options: ["중국", "미국", "인도", "러시아"], answer: 2, difficulty: 'hard', reward: 150, time: 25 },
        { question: "일본의 수도는 어디인가요?", options: ["베이징", "도쿄", "오사카", "모스크바"], answer: 1, difficulty: 'easy', reward: 50, time: 10 },
        { question: "세계에서 영토가 가장 넓은 나라는?", options: ["중국", "캐나다", "미국", "러시아"], answer: 3, difficulty: 'medium', reward: 100, time: 15 },

        // [신규] 추가 문제
        { question: "캥거루와 코알라의 고향으로 유명한 대륙은?", options: ["아프리카", "오세아니아", "남아메리카", "유럽"], answer: 1, difficulty: 'easy', reward: 50, time: 10 },
        { question: "이집트의 피라미드와 스핑크스가 있는 대륙은?", options: ["아시아", "유럽", "아프리카", "북아메리카"], answer: 2, difficulty: 'easy', reward: 50, time: 10 },
        { question: "우리나라(대한민국)의 수도는 어디인가요?", options: ["부산", "인천", "평양", "서울"], answer: 3, difficulty: 'easy', reward: 50, time: 10 },
        { question: "춥고 건조하며, 풀이 거의 자라지 않는 '툰드라'가 나타나는 기후는?", options: ["온대 기후", "건조 기후", "한대 기후", "열대 기후"], answer: 2, difficulty: 'medium', reward: 100, time: 15 },
        { question: "밀, 옥수수 등 농사를 짓기에 가장 적합하고 사계절이 뚜렷한 기후는?", options: ["온대 기후", "열대 기후", "한대 기후", "건조 기후"], answer: 0, difficulty: 'medium', reward: 100, time: 15 },
        { question: "사막이 넓게 나타나고, 강수량이 매우 적은 기후는?", options: ["열대 기후", "고산 기후", "냉대 기후", "건조 기후"], answer: 3, difficulty: 'easy', reward: 50, time: 10 },
        { question: "'에펠탑'이 있는 나라는 어디인가요?", options: ["영국", "이탈리아", "독일", "프랑스"], answer: 3, difficulty: 'medium', reward: 100, time: 15 },
        { question: "'자유의 여신상'이 있는 나라는 어디인가요?", options: ["미국", "캐나다", "멕시코", "브라질"], answer: 0, difficulty: 'medium', reward: 100, time: 15 },
        { question: "세계에서 가장 작은 대륙은 어디인가요?", options: ["유럽", "오세아니아", "남아메리카", "북아메리카"], answer: 1, difficulty: 'easy', reward: 50, time: 10 },
        { question: "1년 내내 눈과 얼음으로 덮여있고 펭귄이 사는 추운 땅은?", options: ["북극", "시베리아", "남극 대륙", "그린란드"], answer: 2, difficulty: 'easy', reward: 50, time: 15 },
    ];

    // --- 2. 다이스 설정 ---
    const DICE_TYPES = ['fire', 'ice', 'wind', 'earth', 'light'];
    const DICE_CONFIG = {
        'fire': { name: '불', color: '#e74c3c' }, // 화상 DoT
        'ice': { name: '얼음', color: '#3498db' }, // 슬로우
        'wind': { name: '바람', color: '#2ecc71' }, // 중독 DoT
        'earth': { name: '대지', color: '#f39c12' }, // 스턴
        'light': { name: '빛', color: '#f1c40f' }, // 방어력 감소
    };
    const GRID_ROWS = 4;
    const GRID_COLS = 5;
    const GRID_SIZE = GRID_ROWS * GRID_COLS; // 20

    // --- 3. 캔버스 & 길(Path) 설정 ---
    const canvas = document.getElementById('game-canvas');
    const ctx = canvas.getContext('2d');

    const computedStyles = getComputedStyle(document.documentElement);
    const PATH_COLOR = computedStyles.getPropertyValue('--path-color').trim();
    const GRID_BG_COLOR = computedStyles.getPropertyValue('--grid-bg').trim();
    const GRID_BORDER_COLOR = computedStyles.getPropertyValue('--grid-border').trim();

    const CELL_SIZE = 70;
    const GAP = 10;
    const PATH_WIDTH = 50;

    const GRID_OFFSET_X = PATH_WIDTH;
    const GRID_OFFSET_Y = PATH_WIDTH;
    const GRID_WIDTH = (CELL_SIZE * GRID_COLS) + (GAP * (GRID_COLS - 1)); // (70*5)+(10*4) = 390
    const GRID_HEIGHT = (CELL_SIZE * GRID_ROWS) + (GAP * (GRID_ROWS - 1)); // (70*4)+(10*3) = 310

    canvas.width = GRID_WIDTH + PATH_WIDTH * 2; // 390 + 100 = 490
    canvas.height = GRID_HEIGHT + PATH_WIDTH * 2; // 310 + 100 = 410

    const pathCenter = PATH_WIDTH / 2; // 25
    const enemyPath = [
        { x: 0, y: pathCenter }, // Start (좌측 중앙)
        { x: pathCenter, y: pathCenter }, // 1. 좌측 상단 코너
        { x: canvas.width - pathCenter, y: pathCenter }, // 2. 우측 상단 코너
        { x: canvas.width - pathCenter, y: canvas.height - pathCenter }, // 3. 우측 하단 코너
        { x: pathCenter, y: canvas.height - pathCenter }, // 4. 좌측 하단 코너
        { x: pathCenter, y: pathCenter + 20 } // 5. End (베이스, 좌측 상단 코너 근처)
    ];

    // --- 4. 게임 상태 변수 ---
    let resources = 100;
    let summonCost = 50;
    let playerHP = 20;
    const MAX_HP = 20;
    let wave = 0;
    let enemiesToSpawn = 0;
    let spawnInterval;
    let gameRunning = false;

    let diceGrid = new Array(GRID_SIZE).fill(null);
    let enemies = [];
    let projectiles = [];
    let damageNumbers = []; // [신규] 데미지 숫자 배열

    let currentQuiz = null;
    let quizTimerInterval;
    let timeLeft = 0;

    let dragState = {
        isDragging: false,
        die: null,
        startIndex: -1,
        x: 0,
        y: 0
    };
    let animationFrameId;

    // --- 5. DOM 요소 (HTML UI) ---
    const resourceDisplay = document.getElementById('resource-display');
    const summonBtn = document.getElementById('summon-dice-btn');
    const summonCostDisplay = document.getElementById('summon-cost-display');
    const hpDisplay = document.getElementById('player-hp');
    const waveDisplay = document.getElementById('wave-display');

    const questionEl = document.getElementById('question');
    const answerOptionsEl = document.getElementById('answer-options');
    const quizRewardDisplay = document.getElementById('quiz-reward');
    const timerBarProgress = document.getElementById('quiz-timer-progress');
    const skipBtn = document.getElementById('skip-btn');
    const quizFeedback = document.getElementById('quiz-feedback');

    const gameOverModal = document.getElementById('game-over-modal');
    const finalWaveDisplay = document.getElementById('final-wave');
    const restartBtn = document.getElementById('restart-btn');


    // --- 6. 퀴즈 로직 (HTML UI 제어) ---
    function loadQuiz() {
        quizFeedback.textContent = '';
        answerOptionsEl.innerHTML = '';

        clearInterval(quizTimerInterval);
        currentQuiz = quizData[Math.floor(Math.random() * quizData.length)];

        questionEl.textContent = currentQuiz.question;
        quizRewardDisplay.textContent = `획득 QP: ${currentQuiz.reward}`;

        currentQuiz.options.forEach((option, index) => {
            const btn = document.createElement('button');
            btn.className = 'option-btn';
            btn.textContent = `${index + 1}. ${option}`;
            btn.onclick = () => checkAnswer(index, btn);
            answerOptionsEl.appendChild(btn);
        });

        // 타이머 시작
        timeLeft = currentQuiz.time;
        timerBarProgress.style.transition = 'none';
        timerBarProgress.style.width = '100%';

        setTimeout(() => {
            timerBarProgress.style.transition = `width ${timeLeft}s linear`;
            timerBarProgress.style.width = '0%';
        }, 50);

        quizTimerInterval = setInterval(() => {
            timeLeft -= 0.1; // 100ms
            if (timeLeft <= 0) {
                skipQuiz();
            }
        }, 100);
    }

    function checkAnswer(userAnswerIndex, btnElement) {
        clearInterval(quizTimerInterval);
        Array.from(answerOptionsEl.children).forEach(btn => btn.disabled = true);

        const currentWidth = timerBarProgress.style.width;
        timerBarProgress.style.transition = 'none';
        timerBarProgress.style.width = currentWidth;

        const isCorrect = (userAnswerIndex === currentQuiz.answer);

        if (isCorrect) {
            quizFeedback.textContent = `정답! +${currentQuiz.reward} QP`;
            quizFeedback.style.color = 'green';
            btnElement.classList.add('correct');
            addResources(currentQuiz.reward);
        } else {
            quizFeedback.textContent = `오답... (정답: ${currentQuiz.options[currentQuiz.answer]})`;
            quizFeedback.style.color = 'red';
            btnElement.classList.add('wrong');
            answerOptionsEl.children[currentQuiz.answer].classList.add('correct');
        }

        setTimeout(loadQuiz, 1500);
    }

    function skipQuiz() {
        clearInterval(quizTimerInterval);
        quizFeedback.textContent = '스킵했습니다.';
        quizFeedback.style.color = 'gray';
        setTimeout(loadQuiz, 500);
    }
    skipBtn.onclick = skipQuiz;

    // --- 7. 게임 UI 로직 (HTML UI 제어) ---
    function addResources(amount) {
        resources += amount;
        updateUI();
    }

    function updateUI() {
        resourceDisplay.textContent = `QP: ${resources}`;
        summonCostDisplay.textContent = `비용: ${summonCost} QP`;
        summonBtn.disabled = resources < summonCost;
        hpDisplay.textContent = `${playerHP}`;
        waveDisplay.textContent = `${wave}`;
    }

    // --- 8. 다이스 소환 로직 (diceGrid 데이터 변경) ---
    function summonDice() {
        if (resources < summonCost) return;

        const emptyIndex = diceGrid.findIndex(cell => cell === null);
        if (emptyIndex === -1) {
            quizFeedback.textContent = '그리드가 꽉 찼습니다!';
            quizFeedback.style.color = 'orange';
            return;
        }

        resources -= summonCost;
        summonCost += 10; // 증가 비용 10

        const randomType = DICE_TYPES[Math.floor(Math.random() * DICE_TYPES.length)];
        diceGrid[emptyIndex] = {
            type: randomType,
            pips: 1,
            cooldown: 0,
            attackSpeed: 60,
            range: 120,
            damage: 10
        };

        updateUI();
    }
    summonBtn.onclick = summonDice;

    // --- 9. 캔버스 렌더링 로직 ---

    function gameLoop() {
        if (!gameRunning) return;

        clearCanvas();
        drawPath();
        drawGrid();
        drawDice();

        updateEnemies(); // 상태이상 업데이트 포함
        drawEnemies();

        updateDiceAttacks();
        updateProjectiles();
        drawProjectiles();

        updateDamageNumbers(); // [신규] 데미지 숫자 업데이트
        drawDamageNumbers(); // [신규] 데미지 숫자 그리기

        drawDraggingDice();

        animationFrameId = requestAnimationFrame(gameLoop);
    }

    function clearCanvas() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
    }

    function drawPath() {
        ctx.fillStyle = PATH_COLOR;
        ctx.fillRect(0, 0, canvas.width, PATH_WIDTH);
        ctx.fillRect(0, canvas.height - PATH_WIDTH, canvas.width, PATH_WIDTH);
        ctx.fillRect(0, PATH_WIDTH, PATH_WIDTH, GRID_HEIGHT);
        ctx.fillRect(canvas.width - PATH_WIDTH, PATH_WIDTH, PATH_WIDTH, GRID_HEIGHT);

        // '베이스' 표시 (삼각형)
        const basePos = enemyPath[enemyPath.length-1];
        const baseSize = 30;
        ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
        ctx.beginPath();
        ctx.moveTo(basePos.x, basePos.y - baseSize / 2); // 위
        ctx.lineTo(basePos.x - baseSize / 2, basePos.y + baseSize / 2); // 좌하
        ctx.lineTo(basePos.x + baseSize / 2, basePos.y + baseSize / 2); // 우하
        ctx.closePath();
        ctx.fill();
    }

    function drawGrid() {
        ctx.strokeStyle = GRID_BORDER_COLOR;
        ctx.fillStyle = GRID_BG_COLOR;

        for (let i = 0; i < GRID_SIZE; i++) {
            const { x, y } = getGridCoords(i);

            ctx.beginPath();
            ctx.roundRect(x, y, CELL_SIZE, CELL_SIZE, 6);
            ctx.fill();
            ctx.stroke();
        }
    }

    function drawDice() {
        for (let i = 0; i < GRID_SIZE; i++) {
            const die = diceGrid[i];
            if (die && !(dragState.isDragging && dragState.startIndex === i)) {
                const { x, y } = getGridCoords(i);
                drawDie(x, y, die);
            }
        }
    }

    function drawDraggingDice() {
        if (dragState.isDragging && dragState.die) {
            const x = dragState.x - CELL_SIZE / 2;
            const y = dragState.y - CELL_SIZE / 2;
            ctx.save();
            ctx.globalAlpha = 0.7;
            ctx.shadowColor = 'rgba(0,0,0,0.3)';
            ctx.shadowBlur = 10;
            drawDie(x, y, dragState.die);
            ctx.restore();
        }
    }

    function drawDie(x, y, die) {
        ctx.fillStyle = DICE_CONFIG[die.type].color;
        ctx.beginPath();
        ctx.roundRect(x, y, CELL_SIZE, CELL_SIZE, 10);
        ctx.fill();
        drawPips(x, y, die.pips);
    }

    function drawPips(x, y, pips) {
        const pipSize = 5;
        const padding = 12;
        const center = CELL_SIZE / 2;
        const left = padding, right = CELL_SIZE - padding;
        const top = padding, bottom = CELL_SIZE - padding;

        const positions = {
            1: [[center, center]],
            2: [[left, top], [right, bottom]],
            3: [[left, top], [center, center], [right, bottom]],
            4: [[left, top], [right, top], [left, bottom], [right, bottom]],
            5: [[left, top], [right, top], [center, center], [left, bottom], [right, bottom]],
            6: [[left, top], [right, top], [left, center], [right, center], [left, bottom], [right, bottom]],
            7: [[left, top], [right, top], [left, center], [center, center], [right, center], [left, bottom], [right, bottom]]
        };

        const pipsToDraw = positions[pips] || positions[7];

        ctx.fillStyle = 'white';
        ctx.shadowColor = 'rgba(0,0,0,0.5)';
        ctx.shadowBlur = 2;

        pipsToDraw.forEach(([px, py]) => {
            ctx.beginPath();
            ctx.arc(x + px, y + py, pipSize, 0, Math.PI * 2);
            ctx.fill();
        });

        ctx.shadowColor = 'transparent';
        ctx.shadowBlur = 0;
    }

    // --- 10. 적 (Enemy) 로직 ---

    class Enemy {
        constructor(isBoss = false) {
            this.isBoss = isBoss;
            this.pathIndex = 1;
            this.statusEffects = {}; // [신규] 상태이상

            if (isBoss) {
                this.x = enemyPath[0].x;
                this.y = enemyPath[0].y;
                this.originalSpeed = 0.5 + (wave * 0.05); // [신규]
                this.speed = this.originalSpeed;
                this.maxHp = 500 + (wave * 100);
                this.hp = this.maxHp;
                this.radius = 20;
                this.color = '#8e44ad';
            } else {
                this.x = enemyPath[0].x;
                this.y = enemyPath[0].y;
                this.originalSpeed = 1 + (wave * 0.1); // [신규]
                this.speed = this.originalSpeed;
                this.maxHp = 50 + (wave * 15);
                this.hp = this.maxHp;
                this.radius = 10;
                this.color = '#c0392b';
            }
        }

        // [신규] 상태이상 적용 함수
        applyStatus(type, pips) {
            switch(type) {
                case 'ice': // 슬로우
                    this.statusEffects.slow = { duration: 120 }; // 2초
                    this.speed = this.originalSpeed * 0.5; // 50% 감속
                    break;
                case 'fire': // 화상 DoT
                    this.statusEffects.burn = { duration: 180, damage: pips * 2, tick: 60 }; // 3초, 1초마다, pips*2 데미지
                    break;
                case 'wind': // 중독 DoT (바람=초록=독)
                    this.statusEffects.poison = { duration: 300, damage: pips * 1, tick: 60 }; // 5초, 1초마다, pips*1 데미지
                    break;
                case 'earth': // 스턴
                    this.statusEffects.stun = { duration: 15 }; // 0.25초
                    break;
                case 'light': // 방깎
                    this.statusEffects.armorBreak = { duration: 240 }; // 4초
                    break;
            }
        }

        // [신규] 상태이상 업데이트
        updateStatusEffects() {
            for (const key in this.statusEffects) {
                const effect = this.statusEffects[key];
                effect.duration--;

                // DoT 처리 (화상, 중독)
                if (key === 'burn' || key === 'poison') {
                    effect.tick--;
                    if (effect.tick <= 0) {
                        this.hp -= effect.damage;
                        createDamageNumber(this.x, this.y - this.radius, effect.damage, (key === 'burn' ? '#e74c3c' : '#2ecc71'));
                        effect.tick = 60; // 1초 틱 리셋
                    }
                }

                // 만료 처리
                if (effect.duration <= 0) {
                    if (key === 'slow') {
                        this.speed = this.originalSpeed; // 스피드 원상복구
                    }
                    delete this.statusEffects[key];
                }
            }
        }

        move() {
            this.updateStatusEffects(); // [신규] 매 프레임 상태이상 업데이트

            if (this.statusEffects.stun) return; // [신규] 스턴이면 이동 안 함
            if (this.pathIndex >= enemyPath.length) return;

            const target = enemyPath[this.pathIndex];
            const dx = target.x - this.x;
            const dy = target.y - this.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            if (dist < this.speed) {
                this.x = target.x;
                this.y = target.y;
                this.pathIndex++;
            } else {
                this.x += (dx / dist) * this.speed;
                this.y += (dy / dist) * this.speed;
            }
        }

        draw() {
            // 몸체
            ctx.fillStyle = this.color;
            // [신규] 상태이상 시각효과
            if (this.statusEffects.slow) ctx.fillStyle = '#3498db'; // 얼음색
            if (this.statusEffects.poison) ctx.fillStyle = '#2ecc71'; // 독색
            if (this.statusEffects.armorBreak) ctx.fillStyle = '#f1c40f'; // 빛색

            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            ctx.fill();

            // [신규] 화상/스턴 효과
            if(this.statusEffects.burn) {
                ctx.strokeStyle = '#e74c3c';
                ctx.lineWidth = 3;
                ctx.stroke();
            }
            if(this.statusEffects.stun) {
                ctx.fillStyle = 'white';
                ctx.font = 'bold 12px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Stun!', this.x, this.y - this.radius - 15);
            }


            // HP 바
            const hpBarWidth = this.isBoss ? 40 : 20;
            const hpBarHeight = 4;
            const hpPercent = this.hp / this.maxHp;
            ctx.fillStyle = '#e74c3c';
            ctx.fillRect(this.x - hpBarWidth / 2, this.y - this.radius - 10, hpBarWidth, hpBarHeight);
            ctx.fillStyle = '#2ecc71';
            ctx.fillRect(this.x - hpBarWidth / 2, this.y - this.radius - 10, hpBarWidth * hpPercent, hpBarHeight);
        }
    }

    function startNextWave() {
        wave++;
        waveDisplay.textContent = wave;

        if (wave % 5 === 0) { // [수정] 10 -> 5 (5스테이지마다 보스)
            enemies.push(new Enemy(true));
            enemiesToSpawn = 0;
            clearInterval(spawnInterval);
        } else {
            enemiesToSpawn = 10 + wave * 2;
            spawnInterval = setInterval(() => {
                if (enemiesToSpawn > 0) {
                    enemies.push(new Enemy(false));
                    enemiesToSpawn--;
                } else {
                    clearInterval(spawnInterval);
                }
            }, 1000 - (wave * 20));
        }
    }

    function updateEnemies() {
        let waveOver = (enemiesToSpawn === 0 && enemies.length === 0);

        for (let i = enemies.length - 1; i >= 0; i--) {
            const enemy = enemies[i];
            enemy.move();

            if (enemy.pathIndex >= enemyPath.length) {
                enemies.splice(i, 1);
                playerHP--;
                if (playerHP <= 0) {
                    playerHP = 0;
                    gameOver();
                }
                updateUI();
            } else if (enemy.hp <= 0) {
                const reward = enemy.isBoss ? (100 + wave * 10) : (5 + wave);
                addResources(reward);
                enemies.splice(i, 1);
            }
        }

        if (waveOver && gameRunning) {
            startNextWave();
        }
    }

    function drawEnemies() {
        enemies.forEach(enemy => enemy.draw());
    }

    // --- 11. 다이스 공격 & 발사체 로직 ---

    class Projectile {
        constructor(x, y, target, die) {
            this.x = x;
            this.y = y;
            this.target = target;
            this.speed = 5;
            this.damage = die.pips * 10 + (die.pips - 1) * 5;
            this.pips = die.pips; // [신규] 상태이상 계산용 pips
            this.type = die.type; // [신규] 상태이상 적용용
            this.color = DICE_CONFIG[die.type].color;
            this.radius = 4;
        }

        move() {
            if (!this.target || this.target.hp <= 0) return false;

            const dx = this.target.x - this.x;
            const dy = this.target.y - this.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            if (dist < this.speed) {
                // Hit!
                // [수정] 방깎 적용
                let damageDealt = this.damage;
                if (this.target.statusEffects.armorBreak) {
                    damageDealt *= 1.3; // 30% 추가 데미지
                }
                damageDealt = Math.round(damageDealt); // 반올림

                this.target.hp -= damageDealt;
                createDamageNumber(this.target.x, this.target.y - this.target.radius, damageDealt, this.color); // [수정] 데미지 숫자 생성
                this.target.applyStatus(this.type, this.pips); // [신규] 상태이상 적용

                return false; // 맞았으므로 제거
            } else {
                this.x += (dx / dist) * this.speed;
                this.y += (dy / dist) * this.speed;
                return true; // 계속 이동
            }
        }

        draw() {
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            ctx.fill();
        }
    }

    function findTarget(dieX, dieY, range) {
        let closestEnemy = null;
        let minRange = range;
        for (const enemy of enemies) {
            const dx = enemy.x - dieX;
            const dy = enemy.y - dieY;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < minRange) {
                minRange = dist;
                closestEnemy = enemy;
            }
        }
        return closestEnemy;
    }

    function updateDiceAttacks() {
        for (let i = 0; i < diceGrid.length; i++) {
            const die = diceGrid[i];
            if (!die) continue;

            if (die.cooldown > 0) {
                die.cooldown--;
                continue;
            }

            const { x, y } = getGridCoords(i);
            const dieCenterX = x + CELL_SIZE / 2;
            const dieCenterY = y + CELL_SIZE / 2;
            const range = 100 + die.pips * 15;
            die.range = range;

            let target = findTarget(dieCenterX, dieCenterY, range);
            if (target) {
                projectiles.push(new Projectile(dieCenterX, dieCenterY, target, die));
                die.cooldown = 60 - die.pips * 5;
            }
        }
    }

    function updateProjectiles() {
        for (let i = projectiles.length - 1; i >= 0; i--) {
            if (!projectiles[i].move()) {
                projectiles.splice(i, 1);
            }
        }
    }

    function drawProjectiles() {
        projectiles.forEach(p => p.draw());
    }

    // --- 11.5 [신규] 데미지 숫자 로직 ---
    function createDamageNumber(x, y, text, color) {
        damageNumbers.push({
            x,
            y,
            text: Math.round(text),
            color,
            alpha: 1.0,
            duration: 60 // 60프레임 = 1초
        });
    }

    function updateDamageNumbers() {
        for (let i = damageNumbers.length - 1; i >= 0; i--) {
            const dn = damageNumbers[i];
            dn.y -= 0.5; // 위로 이동
            dn.duration--;
            dn.alpha = dn.duration / 60; // 서서히 투명하게

            if (dn.duration <= 0) {
                damageNumbers.splice(i, 1);
            }
        }
    }

    function drawDamageNumbers() {
        ctx.save();
        ctx.font = 'bold 14px sans-serif';
        ctx.textAlign = 'center';
        for (const dn of damageNumbers) {
            ctx.globalAlpha = dn.alpha;
            ctx.fillStyle = dn.color;
            ctx.fillText(dn.text, dn.x, dn.y);
        }
        ctx.restore();
    }


    // --- 12. 캔버스 이벤트 핸들링 (드래그 앤 드롭) ---
    // (변경 없음, 이전과 동일)
    function getMousePos(e) {
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        let x, y;

        if (e.changedTouches) { // 터치 이벤트
            x = (e.changedTouches[0].clientX - rect.left) * scaleX;
            y = (e.changedTouches[0].clientY - rect.top) * scaleY;
        } else { // 마우스 이벤트
            x = (e.clientX - rect.left) * scaleX;
            y = (e.clientY - rect.top) * scaleY;
        }
        return { x, y };
    }

    function getGridIndexFromPos(x, y) {
        const gridX = x - GRID_OFFSET_X;
        const gridY = y - GRID_OFFSET_Y;

        for (let i = 0; i < GRID_SIZE; i++) {
            const col = i % GRID_COLS;
            const row = Math.floor(i / GRID_COLS);
            const cellX = col * (CELL_SIZE + GAP);
            const cellY = row * (CELL_SIZE + GAP);

            if (gridX >= cellX && gridX <= cellX + CELL_SIZE &&
                gridY >= cellY && gridY <= cellY + CELL_SIZE) {
                return i;
            }
        }
        return -1;
    }

    function getGridCoords(index) {
        const row = Math.floor(index / GRID_COLS);
        const col = index % GRID_COLS;
        const x = GRID_OFFSET_X + col * (CELL_SIZE + GAP);
        const y = GRID_OFFSET_Y + row * (CELL_SIZE + GAP);
        return { x, y };
    }

    function handleDragStart(e) {
        e.preventDefault();
        const { x, y } = getMousePos(e);
        const index = getGridIndexFromPos(x, y);

        if (index !== -1 && diceGrid[index]) {
            dragState.isDragging = true;
            dragState.startIndex = index;
            dragState.die = { ...diceGrid[index] };
            dragState.x = x;
            dragState.y = y;
            diceGrid[index] = null;
        }
    }

    function handleDragMove(e) {
        if (!dragState.isDragging) return;
        e.preventDefault();
        const { x, y } = getMousePos(e);
        dragState.x = x;
        dragState.y = y;
    }

    function handleDragEnd(e) {
        if (!dragState.isDragging) return;
        e.preventDefault();

        const { x, y } = getMousePos(e);
        const dropIndex = getGridIndexFromPos(x, y);
        const dragDice = dragState.die;
        const startIndex = dragState.startIndex;

        if (dropIndex === -1) {
            diceGrid[startIndex] = dragDice;
        } else {
            const dropDice = diceGrid[dropIndex];

            if (dropDice === null) {
                diceGrid[dropIndex] = dragDice;
            } else {
                if (dragDice.type === dropDice.type && dragDice.pips === dropDice.pips) {
                    // 합성 성공
                    diceGrid[dropIndex].pips += 1;
                    diceGrid[dropIndex].damage = diceGrid[dropIndex].pips * 10 + (diceGrid[dropIndex].pips - 1) * 5;
                    diceGrid[dropIndex].range = 100 + diceGrid[dropIndex].pips * 15;
                    diceGrid[dropIndex].cooldown = 0;
                } else {
                    // 합성 실패 - 위치 교환
                    diceGrid[startIndex] = dropDice;
                    diceGrid[dropIndex] = dragDice;
                }
            }
        }

        dragState.isDragging = false;
        dragState.die = null;
        dragState.startIndex = -1;
    }

    // 이벤트 리스너
    canvas.addEventListener('mousedown', handleDragStart);
    canvas.addEventListener('mousemove', handleDragMove);
    canvas.addEventListener('mouseup', handleDragEnd);
    canvas.addEventListener('mouseleave', handleDragEnd);
    canvas.addEventListener('touchstart', handleDragStart, { passive: false });
    canvas.addEventListener('touchmove', handleDragMove, { passive: false });
    canvas.addEventListener('touchend', handleDragEnd, { passive: false });


    // --- 13. 게임 시작/종료 로직 ---

    function gameOver() {
        gameRunning = false;
        cancelAnimationFrame(animationFrameId);
        clearInterval(spawnInterval);
        clearInterval(quizTimerInterval);

        finalWaveDisplay.textContent = wave;
        gameOverModal.style.display = 'flex';
    }

    function resetGame() {
        gameRunning = false;
        cancelAnimationFrame(animationFrameId);
        clearInterval(spawnInterval);
        clearInterval(quizTimerInterval);

        resources = 100;
        summonCost = 50;
        playerHP = MAX_HP;
        wave = 0;
        enemiesToSpawn = 0;

        diceGrid = new Array(GRID_SIZE).fill(null);
        enemies = [];
        projectiles = [];
        damageNumbers = []; // [신규] 데미지 숫자 리셋

        updateUI();
        gameOverModal.style.display = 'none';

        gameRunning = true;
        loadQuiz();
        startNextWave();
        animationFrameId = requestAnimationFrame(gameLoop);
    }

    restartBtn.onclick = resetGame;

    function initGame() {
        gameRunning = true;
        loadQuiz();
        updateUI();
        startNextWave(); // 첫 번째 웨이브 시작
        animationFrameId = requestAnimationFrame(gameLoop);
    }

    initGame();

</script>
</body>
</html>