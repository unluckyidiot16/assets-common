<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ë‹¤ì´ìŠ¤ ëœë¤ í€´ì¦ˆ ë””íœìŠ¤ (v3.2)</title>
    <link rel="preload"
          href="https://unluckyidiot16.github.io/assets-common/QuizDiceDefense/QuizPack/quizpack.json?v=20251112"
          as="fetch"
          crossorigin="anonymous">
    <style>
        :root {
            --canvas-bg: #dbe4ee;
            --grid-bg: #ffffff;
            --grid-border: #b0c4de;
            --path-color: #c5d3e0;
            --text-dark: #333;
            --qp-color: #2a9d8f;
            --hp-color: #e76f51;
            --wave-color: #f3a261;
            --point-color: #8e44ad;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen,
            Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            background-color: #f0f4f8;
            padding: 20px 10px;
            color: var(--text-dark);
            min-height: 100vh;
            box-sizing: border-box;
        }

        body.modal-open {
            overflow: hidden;
        }

        h1 {
            color: var(--text-dark);
            text-align: center;
            margin-bottom: 20px;
        }

        #game-container, #quiz-container {
            display: none;
        }
        #game-container {
            flex-wrap: nowrap;
            justify-content: center;
            gap: 20px;
            width: 100%;
            max-width: 1050px;
        }

        #left-panel {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .panel {
            background-color: var(--grid-bg);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        #player-stats {
            display: flex;
            justify-content: space-between;
            font-size: 1.1em;
            font-weight: 500;
            margin-bottom: 15px;
        }
        #player-hp { color: var(--hp-color); font-weight: bold; }
        #wave-display { color: var(--wave-color); font-weight: bold; }

        #resource-display {
            font-size: 1.5em;
            font-weight: bold;
            color: var(--qp-color);
            margin-bottom: 10px;
        }
        #summon-dice-btn {
            width: 100%;
            padding: 15px;
            font-size: 1.2em;
            font-weight: bold;
            background-color: var(--hp-color);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        #summon-dice-btn:hover:not(:disabled) {
            background-color: #f4a261;
        }
        #summon-dice-btn:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        #summon-cost-display {
            font-size: 0.9em;
            color: #555;
            text-align: center;
            margin-top: 5px;
        }

        /* --- ê°•í™” íŒ¨ë„ --- */
        #upgrade-panel {
            display: grid;
            grid-template-columns: repeat(5, 1fr); /* 1ì¤„ 5ì¹¸ */
            gap: 10px;
            padding: 10px;
        }
        .upgrade-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px;
            border: 1px solid var(--grid-border);
            border-radius: 6px;
            cursor: pointer;
            transition: background-color 0.2s, box-shadow 0.2s;
        }
        .upgrade-section:hover {
            background-color: #f9f9f9;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .upgrade-section.disabled {
            background-color: #fdfdfd;
            color: #aaa;
            cursor: not-allowed;
            opacity: 0.7;
        }
        .upgrade-section.disabled:hover {
            box-shadow: none;
        }

        .dice-icon {
            width: 35px;
            height: 35px;
            border-radius: 6px;
            border: 2px solid white;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }
        .upgrade-info {
            font-size: 0.9em;
            font-weight: bold;
            text-align: center;
            color: #333;
            margin-top: 8px;
        }
        .upgrade-cost {
            font-size: 0.8em;
            color: var(--qp-color);
            font-weight: 500;
            margin-top: 4px;
        }
        .disabled .upgrade-cost {
            color: #aaa;
        }

        /* --- ìº”ë²„ìŠ¤ ì˜ì—­ --- */
        #game-canvas-container {
            border: 2px solid var(--grid-border);
            padding: 10px;
            border-radius: 8px;
            background-color: var(--canvas-bg);
            width: 510px;
            height: 430px;
            box-sizing: border-box;
        }

        #game-canvas {
            display: block;
            background-color: var(--canvas-bg);
            cursor: grab;
        }
        #game-canvas:active {
            cursor: grabbing;
        }

        /* --- í€´ì¦ˆ íŒ¨ë„ (HTML) --- */
        #quiz-container {
            width: 400px;
            box-sizing: border-box;
        }

        #quiz-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
        #quiz-timer-bar { height: 10px; flex-grow: 1; background-color: #eee; border-radius: 5px; overflow: hidden; margin-right: 15px; }
        #quiz-timer-progress { height: 100%; width: 100%; background-color: #4caf50; transition: width 0.1s linear; }
        #quiz-reward { font-size: 0.9em; font-weight: 500; color: var(--qp-color); }
        #question { font-size: 1.1em; font-weight: 500; margin-bottom: 15px; min-height: 50px; }
        #answer-options { display: flex; flex-direction: column; gap: 10px; margin-bottom: 15px; }

        /* [ìˆ˜ì •] í€´ì¦ˆ ë²„íŠ¼ ë¡¤ë°± */
        .option-btn {
            padding: 12px;
            border: 1px solid #ddd;
            background-color: #f9f9f9;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s;
            text-align: left;
            font-size: 1em;
            width: 100%; /* ë„ˆë¹„ 100% */
            box-sizing: border-box; /* íŒ¨ë”© í¬í•¨ */
        }
        .option-btn:hover { background-color: #eef; border-color: #aac; }
        .option-btn.correct { background-color: #d4edda; border-color: #c3e6cb; }
        .option-btn.wrong { background-color: #f8d7da; border-color: #f5c6cb; }
        #skip-btn { padding: 10px; background-color: #6c757d; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 0.9em; align-self: flex-end; }
        #skip-btn:hover { background-color: #5a6268; }
        #quiz-feedback { margin-top: 15px; font-weight: bold; text-align: center; }


        /* --- ëª¨ë‹¬ ê³µí†µ ìŠ¤íƒ€ì¼ --- */
        .modal-overlay {
            display: flex;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            justify-content: center;
            align-items: center;
            z-index: 100;
        }
        .modal-content {
            background-color: white;
            padding: 30px 40px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 5px 20px rgba(0,0,0,0.3);
            width: 90%;
            max-width: 500px;
            max-height: 80vh;
            overflow-y: auto;
        }
        .modal-content h2 {
            font-size: 2.2em;
            color: var(--text-dark);
            margin-bottom: 20px;
        }
        .modal-content p {
            font-size: 1.1em;
            line-height: 1.6;
        }
        .modal-close-btn {
            position: absolute;
            top: 15px;
            right: 20px;
            font-size: 2em;
            cursor: pointer;
            color: #aaa;
            background: none;
            border: none;
        }
        .modal-btn {
            padding: 12px 25px;
            font-size: 1.2em;
            font-weight: bold;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin: 10px 5px;
            transition: background-color 0.2s;
        }
        .modal-btn:hover {
            background-color: #0056b3;
        }
        .modal-btn.secondary {
            background-color: #6c757d;
        }
        .modal-btn.secondary:hover {
            background-color: #5a6268;
        }

        /* --- ì‹œì‘ í™”ë©´ --- */
        #start-screen h1 {
            font-size: 2.5em;
            color: var(--hp-color);
        }
        #start-screen .instructions {
            text-align: left;
            padding: 0 10px;
            margin-bottom: 25px;
            background-color: #f9f9f9;
            border-radius: 5px;
            border: 1px solid #eee;
        }

        /* --- ì˜êµ¬ ê°•í™” ëª¨ë‹¬ --- */
        #total-points-display {
            font-size: 1.5em;
            font-weight: bold;
            color: var(--point-color);
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #eee;
        }
        .roguelite-upgrade-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }
        .roguelite-upgrade-item {
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 8px;
            background-color: #f9f9f9;
        }
        .roguelite-upgrade-item h3 {
            margin-top: 0;
            margin-bottom: 10px;
            color: var(--text-dark);
        }
        .roguelite-upgrade-item p {
            font-size: 0.9em;
            color: #555;
            margin-bottom: 10px;
        }
        .roguelite-upgrade-btn {
            width: 100%;
            padding: 10px;
            font-size: 1em;
            font-weight: bold;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            background-color: var(--point-color);
            color: white;
            transition: background-color 0.2s;
        }
        .roguelite-upgrade-btn:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        .roguelite-upgrade-btn:hover:not(:disabled) {
            background-color: #7a3d9b;
        }
        .roguelite-cost {
            font-size: 0.9em;
            font-weight: 500;
            margin-top: 5px;
        }

        /* --- ì—…ì  ëª¨ë‹¬ --- */
        #achievement-list {
            list-style: none;
            padding: 0;
            text-align: left;
        }
        #achievement-list li {
            font-size: 1.1em;
            padding: 12px;
            border-bottom: 1px solid #eee;
        }
        #achievement-list li.unlocked {
            color: green;
            font-weight: bold;
            text-decoration: line-through;
        }
        #achievement-list li.locked {
            color: #aaa;
        }
        #achievement-list li.locked::before { content: 'ğŸ”’ '; }
        #achievement-list li.unlocked::before { content: 'ğŸ† '; }


        /* --- ê²Œì„ ì˜¤ë²„/ìŠ¹ë¦¬ ëª¨ë‹¬ --- */
        #game-over-modal, #game-victory-modal { display: none; }
        #game-over-content h2 { color: var(--hp-color); }
        #game-victory-modal h2 { color: var(--qp-color); }
        .points-display {
            font-size: 1.2em;
            margin: 15px 0;
        }
        .points-display strong {
            color: var(--point-color);
            font-size: 1.3em;
        }

        /* --- [ìˆ˜ì •] ëª¨ë°”ì¼ ë°˜ì‘í˜• --- */
        @media (max-width: 960px) { /* íƒœë¸”ë¦¿/ë°ìŠ¤í¬íƒ‘ ì¢ê²Œ */
            body {
                padding: 10px 5px;
            }
            #game-container, #quiz-container {
                flex-direction: column; /* ì„¸ë¡œë¡œ ìŒ“ê¸° */
                align-items: center;
                display: none;
            }
            #game-container.active, #quiz-container.active {
                display: flex;
            }
            #left-panel, #quiz-container {
                width: 98%;
                max-width: 530px;
            }
            #game-canvas-container {
                width: 100%;
                height: auto;
                aspect-ratio: 510 / 430;
            }
            #game-canvas {
                width: 100%;
                height: 100%;
            }
            h1 {
                font-size: 1.5em;
            }
            /* [ìˆ˜ì •] ê°•í™” íŒ¨ë„ 3ì—´ */
            #upgrade-panel {
                grid-template-columns: repeat(3, 1fr);
            }
            .roguelite-upgrade-grid {
                grid-template-columns: 1fr;
            }
        }
        @media (max-width: 600px) {
            /* [ìˆ˜ì •] ê°•í™” íŒ¨ë„ 2ì—´ */
            #upgrade-panel {
                grid-template-columns: repeat(2, 1fr);
            }
        }


        /* --- Portrait: upgrade panel 1-row 5-col, shrink contents, fix widths --- */
        @media (orientation: portrait) {
            #upgrade-panel {
                display: grid !important;
                grid-template-columns: repeat(5, minmax(0, 1fr)) !important;
                grid-auto-flow: row !important;
                gap: 6px !important;
            }
            #upgrade-panel .upgrade-section {
                min-width: 0; /* allow shrink inside grid cell */
                padding: 6px !important;
            }
            #upgrade-panel .dice-icon {
                width: 28px; height: 28px;
            }
            #upgrade-panel .upgrade-info,
            #upgrade-panel .upgrade-cost {
                width: 100%;
                text-align: center;
                line-height: 1.1;
                /* shrink-to-fit text based on viewport width with bounds */
                font-size: clamp(10px, 2.6vw, 12px);
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
            }
            /* Keep roguelite grid to single column in portrait small, but buttons full-width */
            .roguelite-upgrade-grid { grid-template-columns: 1fr !important; }
            .roguelite-upgrade-btn { width: 100%; }
        }
        /* Ensure equal-looking buttons regardless of text length */
        .option-btn,
        .modal-btn,
        .roguelite-upgrade-btn { width: 100%; box-sizing: border-box; }
        /* Prefer dynamic font sizing for long labels */
        .option-btn { font-size: clamp(14px, 3.8vw, 18px); }


        /* Strong override so active screens always show */
        #game-container.active, #quiz-container.active { display: flex !important; }
        html, body { min-height: 100dvh; }
        :root { --vh: 1vh; }


        /* === Quiz option sizing fixes === */
        :root { --opt-height: 54px; --opt-font-max: 18px; --opt-font-min: 12px; }

        #answer-options { display: flex; flex-direction: column; gap: 10px; }

        .option-btn {
            display: flex;
            align-items: center;
            justify-content: flex-start;
            height: var(--opt-height);
            width: 100%;
            box-sizing: border-box;
            padding: 8px 12px;
            border: 1px solid #ddd;
            background-color: #f9f9f9;
            border-radius: 6px;
            cursor: pointer;
            transition: background-color .2s, border-color .2s, transform .1s;
            overflow: hidden; /* prevent height growth */
        }

        .option-btn .option-label {
            display: -webkit-box;
            -webkit-box-orient: vertical;
            -webkit-line-clamp: 2; /* allow up to 2 lines */
            overflow: hidden;
            line-height: 1.15;
            width: 100%;
            /* initial responsive bound, JS will fine-tune */
            font-size: clamp(var(--opt-font-min), 3.4vw, var(--opt-font-max));
            white-space: normal;
            text-overflow: ellipsis;
        }

        @media (orientation: portrait) {
            :root { --opt-height: 50px; --opt-font-max: 16px; --opt-font-min: 11px; }
        }


        /* === PATCH: Force equal-width quiz option boxes === */
        #answer-options {
            display: grid !important;
            grid-template-columns: 1fr !important;
            align-items: stretch !important;
            gap: 10px;
        }
        #answer-options .option-btn {
            width: 100% !important;
            box-sizing: border-box !important;
            display: flex !important;
            align-items: center !important;
            justify-content: flex-start !important;
        }
        #answer-options .option-btn .option-label {
            width: 100% !important;
            box-sizing: border-box !important;
        }
        /* === END PATCH === */


        /* === PATCH v3: Quiz panel alignment & equal widths === */
        #quiz-container { display: flex; flex-direction: column; align-items: stretch; }
        #question { text-align: left !important; }
        #answer-options {
            display: grid !important;
            grid-template-columns: 1fr !important;
            justify-items: stretch !important;
            align-items: stretch !important;
            gap: 10px !important;
            width: 100% !important;
            box-sizing: border-box !important;
        }
        #answer-options .option-btn {
            display: flex !important;
            align-items: center !important;
            justify-content: flex-start !important;
            width: 100% !important;
            max-width: none !important;
            align-self: stretch !important;
            box-sizing: border-box !important;
            text-align: left !important;
            min-width: 0 !important;
        }
        #answer-options .option-btn .option-label {
            width: 100% !important;
            min-width: 0 !important;
        }
        /* === END PATCH v3 === */

    </style>
    <link rel="icon" href="data:,">
    <script src="../../ClassGame/AUTOPPT/src/utils/supaRpc.ts"></script>
</head>
<body>

<!-- ì‹œì‘ í™”ë©´ ëª¨ë‹¬ -->
<div id="start-screen" class="modal-overlay">
    <div class="modal-content">
        <h1>ë‹¤ì´ìŠ¤ í€´ì¦ˆ ë””íœìŠ¤</h1>
        <div class="instructions">
            <p><strong>ğŸ“œ ê²Œì„ ë°©ë²•</strong></p>
            <ul>
                <li>í€´ì¦ˆë¥¼ í’€ê³  <strong>QP</strong>ë¥¼ ëª¨ìœ¼ì„¸ìš”.</li>
                <li><strong>QP</strong>ë¡œ ëœë¤ ë‹¤ì´ìŠ¤ë¥¼ ì†Œí™˜í•˜ì„¸ìš”.</li>
                <li>ê°™ì€ ì¢…ë¥˜, ê°™ì€ ëˆˆê¸ˆì˜ ë‹¤ì´ìŠ¤ë¥¼ í•©ì³ ê°•í™”í•˜ì„¸ìš”.</li>
                <li>ëª°ë ¤ì˜¤ëŠ” ì ë“¤ì„ ë§‰ê³  ì›¨ì´ë¸Œë¥¼ í´ë¦¬ì–´í•˜ì„¸ìš”!</li>
                <li>ê²Œì„ ì˜¤ë²„ ì‹œ <strong>ì§€ì‹ í¬ì¸íŠ¸(KP)</strong>ë¥¼ ì–»ìŠµë‹ˆë‹¤.</li>
            </ul>
        </div>
        <button id="start-game-btn" class="modal-btn">ê²Œì„ ì‹œì‘</button>
        <button id="show-roguelite-btn" class="modal-btn secondary">ì˜êµ¬ ê°•í™”</button>
        <button id="show-achievements-btn" class="modal-btn secondary">ì—…ì </button>
    </div>
</div>

<!-- ì˜êµ¬ ê°•í™” ëª¨ë‹¬ -->
<div id="roguelite-upgrade-modal" class="modal-overlay" style="display: none;">
    <div class="modal-content">
        <button id="close-roguelite-btn" class="modal-close-btn">&times;</button>
        <h2>ì˜êµ¬ ê°•í™”</h2>
        <div id="total-points-display">ë³´ìœ : 0 KP</div>
        <div class="roguelite-upgrade-grid">
            <div class="roguelite-upgrade-item">
                <h3>ì‹œì‘ QP ì¦ê°€</h3>
                <p id="roguelite-startQP-desc">ì‹œì‘ QPê°€ 20 ì¦ê°€í•©ë‹ˆë‹¤. (í˜„ì¬ +0)</p>
                <button id="roguelite-startQP-btn" class="roguelite-upgrade-btn">ê°•í™”</button>
                <div class="roguelite-cost" id="roguelite-startQP-cost">ë¹„ìš©: 200 KP</div>
            </div>
            <div class="roguelite-upgrade-item">
                <h3>í€´ì¦ˆ ë³´ìƒ ì¦ê°€</h3>
                <p id="roguelite-quizQP-desc">í€´ì¦ˆ ì •ë‹µ QP ë³´ìƒì´ 10% ì¦ê°€í•©ë‹ˆë‹¤. (í˜„ì¬ +0%)</p>
                <button id="roguelite-quizQP-btn" class="roguelite-upgrade-btn">ê°•í™”</button>
                <div class="roguelite-cost" id="roguelite-quizQP-cost">ë¹„ìš©: 300 KP</div>
            </div>
            <div class="roguelite-upgrade-item">
                <h3>ìƒìœ„ ì†Œí™˜ í™•ë¥ </h3>
                <p id="roguelite-highSpawn-desc">ë‹¤ì´ìŠ¤ ì†Œí™˜ ì‹œ 1% í™•ë¥ ë¡œ 2ì„± ë“±ì¥. (í˜„ì¬ 0%)</p>
                <button id="roguelite-highSpawn-btn" class="roguelite-upgrade-btn">ê°•í™”</button>
                <div class="roguelite-cost" id="roguelite-highSpawn-cost">ë¹„ìš©: 400 KP</div>
            </div>
            <div class="roguelite-upgrade-item">
                <h3>2ë‹¨ í•©ì„± í™•ë¥ </h3>
                <p id="roguelite-mergeBonus-desc">í•©ì„± ì‹œ 1% í™•ë¥ ë¡œ +2ì„±(Bonus). (í˜„ì¬ 0%)</p>
                <button id="roguelite-mergeBonus-btn" class="roguelite-upgrade-btn">ê°•í™”</button>
                <div class="roguelite-cost" id="roguelite-mergeBonus-cost">ë¹„ìš©: 500 KP</div>
            </div>
        </div>
    </div>
</div>

<!-- ì—…ì  ëª¨ë‹¬ -->
<div id="achievements-modal" class="modal-overlay" style="display: none;">
    <div class="modal-content">
        <button id="close-achievements-btn" class="modal-close-btn">&times;</button>
        <h2>ì—…ì </h2>
        <ul id="achievement-list">
            <li id="ach-wave5" class="locked">ì²« ë²ˆì§¸ ë³´ìŠ¤ ì¡°ìš° (Wave 5)</li>
            <li id="ach-wave10" class="locked">Wave 10 ë‹¬ì„±</li>
            <li id="ach-wave20" class="locked">Wave 20 ë‹¬ì„±</li>
            <li id="ach-wave30" class="locked">Wave 30 ë‹¬ì„±</li>
            <li id="ach-wave50" class="locked">Wave 50 í´ë¦¬ì–´! (ìŠ¹ë¦¬)</li>
            <li id="ach-pip7" class="locked">7ì„± ë‹¤ì´ìŠ¤ ì œì‘</li>
        </ul>
    </div>
</div>


<div id="game-container">
    <!-- ì™¼ìª½: ê²Œì„ ë³´ë“œ ë° UI -->
    <div id="left-panel">
        <div id="ui-panel" class="panel">
            <div id="player-stats">
                <span>HP: <span id="player-hp">20</span> / <span id="player-hp-max">20</span></span>
                <span>Wave: <span id="wave-display">0</span></span>
            </div>
            <div id="resource-display">QP: 100</div>
            <button id="summon-dice-btn">ë‹¤ì´ìŠ¤ ì†Œí™˜</button>
            <div id="summon-cost-display">ë¹„ìš©: 50 QP</div>
        </div>

        <div id="upgrade-panel" class="panel">
            <div class="upgrade-section" id="upgrade-fire">
                <div class="dice-icon" style="background-color: #e74c3c;"></div>
                <div class="upgrade-info" id="fire-lvl">Lvl 1</div>
                <div class="upgrade-cost" id="fire-cost">100 QP</div>
            </div>
            <div class="upgrade-section" id="upgrade-ice">
                <div class="dice-icon" style="background-color: #3498db;"></div>
                <div class="upgrade-info" id="ice-lvl">Lvl 1</div>
                <div class="upgrade-cost" id="ice-cost">100 QP</div>
            </div>
            <div class="upgrade-section" id="upgrade-wind">
                <div class="dice-icon" style="background-color: #2ecc71;"></div>
                <div class="upgrade-info" id="wind-lvl">Lvl 1</div>
                <div class="upgrade-cost" id="wind-cost">100 QP</div>
            </div>
            <div class="upgrade-section" id="upgrade-earth">
                <div class="dice-icon" style="background-color: #f39c12;"></div>
                <div class="upgrade-info" id="earth-lvl">Lvl 1</div>
                <div class="upgrade-cost" id="earth-cost">100 QP</div>
            </div>
            <div class="upgrade-section" id="upgrade-light">
                <div class="dice-icon" style="background-color: #f1c40f;"></div>
                <div class="upgrade-info" id="light-lvl">Lvl 1</div>
                <div class="upgrade-cost" id="light-cost">100 QP</div>
            </div>
        </div>

        <div id="game-canvas-container">
            <canvas id="game-canvas"></canvas>
        </div>
    </div>

    <!-- ì˜¤ë¥¸ìª½: í€´ì¦ˆ íŒ¨ë„ -->
    <div id="quiz-container" class="panel">
        <div id="quiz-header">
            <div id="quiz-timer-bar">
                <div id="quiz-timer-progress"></div>
            </div>
            <div id="quiz-reward">QP: 100</div>
        </div>
        <div id="question">í€´ì¦ˆê°€ ë¡œë“œ ì¤‘ì…ë‹ˆë‹¤...</div>
        <div id="answer-options"></div>
        <button id="skip-btn">ìŠ¤í‚µ</button>
        <div id="quiz-feedback"></div>
    </div>
</div>

<!-- ê²Œì„ ì˜¤ë²„ ëª¨ë‹¬ -->
<div id="game-over-modal" class="modal-overlay">
    <div class="modal-content">
        <h2>ê²Œì„ ì˜¤ë²„</h2>
        <p>ìµœì¢… ì›¨ì´ë¸Œ: <span id="final-wave">0</span></p>
        <div class="points-display">
            íšë“í•œ ì§€ì‹ í¬ì¸íŠ¸: <strong><span id="points-earned">0</span> KP</strong>
        </div>
        <div class="points-display">
            ì´ ë³´ìœ  ì§€ì‹ í¬ì¸íŠ¸: <strong><span id="total-points">0</span> KP</strong>
        </div>
        <button id="restart-btn" class="modal-btn">íƒ€ì´í‹€ë¡œ</button>
    </div>
</div>

<!-- ê²Œì„ ìŠ¹ë¦¬ ëª¨ë‹¬ -->
<div id="game-victory-modal" class="modal-overlay" style="display: none;">
    <div class="modal-content">
        <h2 style="color: var(--qp-color);">ğŸ‰ ê²Œì„ ìŠ¹ë¦¬! ğŸ‰</h2>
        <p>ì¶•í•˜í•©ë‹ˆë‹¤! 50 ì›¨ì´ë¸Œë¥¼ ëª¨ë‘ í´ë¦¬ì–´í•˜ì…¨ìŠµë‹ˆë‹¤!</p>
        <div class="points-display">
            íšë“í•œ ì§€ì‹ í¬ì¸íŠ¸: <strong><span id="victory-points-earned">0</span> KP</strong>
        </div>
        <div class="points-display">
            ì´ ë³´ìœ  ì§€ì‹ í¬ì¸íŠ¸: <strong><span id="victory-total-points">0</span> KP</strong>
        </div>
        <button id="victory-restart-btn" class="modal-btn">íƒ€ì´í‹€ë¡œ</button>
    </div>
</div>


<script>
    window.autosizeOptionLabels = window.autosizeOptionLabels || function(){};

    // --- 1. [ìˆ˜ì •] í€´ì¦ˆ ë°ì´í„° (6í•™ë…„ ì‚¬íšŒ - ì§€ë¦¬, ë¬¸í™” ì¤‘ì‹¬ 100+) ---
    const quizData = [
        // (100+ê°œì˜ í€´ì¦ˆ ë°ì´í„°ëŠ” ì´ì „ê³¼ ë™ì¼í•˜ë¯€ë¡œ ìƒëµ)
        { question: "ì„¸ê³„ì—ì„œ ê°€ì¥ í° ëŒ€ë¥™ì€ ì–´ë””ì¸ê°€ìš”?", options: ["ì•„í”„ë¦¬ì¹´", "ì•„ì‹œì•„", "ë¶ì•„ë©”ë¦¬ì¹´", "ìœ ëŸ½"], answer: 1, difficulty: 'easy', reward: 50, time: 10 },
        { question: "ì„¸ê³„ì—ì„œ ê°€ì¥ í° ë°”ë‹¤ëŠ” ì–´ë””ì¸ê°€ìš”?", options: ["ëŒ€ì„œì–‘", "ì¸ë„ì–‘", "ë¶ê·¹í•´", "íƒœí‰ì–‘"], answer: 3, difficulty: 'easy', reward: 50, time: 10 },
        { question: "6ëŒ€ì£¼ì— ì†í•˜ì§€ *ì•ŠëŠ”* ê²ƒì€ ë¬´ì—‡ì¸ê°€ìš”?", options: ["ì•„ì‹œì•„", "ìœ ëŸ½", "ë‚¨ê·¹", "ì˜¤ì„¸ì•„ë‹ˆì•„"], answer: 2, difficulty: 'easy', reward: 50, time: 10 },
        { question: "ì•„ì‹œì•„ ëŒ€ë¥™ì— ëŒ€í•œ ì„¤ëª…ìœ¼ë¡œ *í‹€ë¦°* ê²ƒì€?", options: ["ì„¸ê³„ì—ì„œ ê°€ì¥ ë„“ì€ ëŒ€ë¥™ì´ë‹¤", "ì„¸ê³„ì—ì„œ ì¸êµ¬ê°€ ê°€ì¥ ë§ì€ ëŒ€ë¥™ì´ë‹¤", "ì„¸ê³„ì—ì„œ ê°€ì¥ ê¸´ ê°•(ë‚˜ì¼ê°•)ì´ ìˆë‹¤", "ìš°ë¦¬ë‚˜ë¼ê°€ ì†í•´ ìˆëŠ” ëŒ€ë¥™ì´ë‹¤"], answer: 2, difficulty: 'medium', reward: 100, time: 20 },
        { question: "ì˜¤ì„¸ì•„ë‹ˆì•„ ëŒ€ë¥™ì„ ëŒ€í‘œí•˜ëŠ” ë‚˜ë¼ëŠ”?", options: ["ì´ì§‘íŠ¸", "ë¸Œë¼ì§ˆ", "ì˜¤ìŠ¤íŠ¸ë ˆì¼ë¦¬ì•„", "ìºë‚˜ë‹¤"], answer: 2, difficulty: 'easy', reward: 50, time: 10 },
        { question: "ì•„ë§ˆì¡´ ì—´ëŒ€ ìš°ë¦¼ì´ ì£¼ë¡œ ìœ„ì¹˜í•œ ëŒ€ë¥™ì€?", options: ["ì•„ì‹œì•„", "ì•„í”„ë¦¬ì¹´", "ë‚¨ì•„ë©”ë¦¬ì¹´", "ë¶ì•„ë©”ë¦¬ì¹´"], answer: 2, difficulty: 'medium', reward: 100, time: 15 },
        { question: "ìº¥ê±°ë£¨ì™€ ì½”ì•Œë¼ì˜ ê³ í–¥ìœ¼ë¡œ ìœ ëª…í•œ ëŒ€ë¥™ì€?", options: ["ì•„í”„ë¦¬ì¹´", "ì˜¤ì„¸ì•„ë‹ˆì•„", "ë‚¨ì•„ë©”ë¦¬ì¹´", "ìœ ëŸ½"], answer: 1, difficulty: 'easy', reward: 50, time: 10 },
        { question: "ì´ì§‘íŠ¸ì˜ í”¼ë¼ë¯¸ë“œì™€ ìŠ¤í•‘í¬ìŠ¤ê°€ ìˆëŠ” ëŒ€ë¥™ì€?", options: ["ì•„ì‹œì•„", "ìœ ëŸ½", "ì•„í”„ë¦¬ì¹´", "ë¶ì•„ë©”ë¦¬ì¹´"], answer: 2, difficulty: 'easy', reward: 50, time: 10 },
        { question: "ì„¸ê³„ì—ì„œ ê°€ì¥ ì‘ì€ ëŒ€ë¥™ì€ ì–´ë””ì¸ê°€ìš”?", options: ["ìœ ëŸ½", "ì˜¤ì„¸ì•„ë‹ˆì•„", "ë‚¨ì•„ë©”ë¦¬ì¹´", "ë¶ì•„ë©”ë¦¬ì¹´"], answer: 1, difficulty: 'easy', reward: 50, time: 10 },
        { question: "1ë…„ ë‚´ë‚´ ëˆˆê³¼ ì–¼ìŒìœ¼ë¡œ ë®ì—¬ìˆê³  í­ê·„ì´ ì‚¬ëŠ” ì¶”ìš´ ë•…ì€?", options: ["ë¶ê·¹", "ì‹œë² ë¦¬ì•„", "ë‚¨ê·¹ ëŒ€ë¥™", "ê·¸ë¦°ë€ë“œ"], answer: 2, difficulty: 'easy', reward: 50, time: 15 },
        { question: "ì„¸ê³„ì—ì„œ ê°€ì¥ ì¸êµ¬ê°€ ì ì€ ëŒ€ë¥™ì€?", options: ["ì˜¤ì„¸ì•„ë‹ˆì•„", "ë‚¨ì•„ë©”ë¦¬ì¹´", "ìœ ëŸ½", "ë¶ì•„ë©”ë¦¬ì¹´"], answer: 0, difficulty: 'medium', reward: 100, time: 15 },
        { question: "ì§€êµ¬ì˜ ìœ¡ì§€ë¥¼ í¬ê²Œ ë‚˜ëˆˆ 6ê°œì˜ í° ë•…ë©ì–´ë¦¬ë¥¼ ë¬´ì—‡ì´ë¼ê³  í•˜ë‚˜ìš”?", options: ["6ëŒ€ë¥™", "5ëŒ€ì–‘", "6ëŒ€ì£¼", "5ëŒ€ì£¼"], answer: 2, difficulty: 'easy', reward: 50, time: 10 },
        { question: "ì§€êµ¬ì˜ ë°”ë‹¤ë¥¼ í¬ê²Œ ë‚˜ëˆˆ 5ê°œì˜ í° ë°”ë‹¤ë¥¼ ë¬´ì—‡ì´ë¼ê³  í•˜ë‚˜ìš”?", options: ["6ëŒ€ë¥™", "5ëŒ€ì–‘", "6ëŒ€ì£¼", "5ëŒ€ì£¼"], answer: 1, difficulty: 'easy', reward: 50, time: 10 },
        { question: "ì„¸ê³„ì—ì„œ ê°€ì¥ ì‘ì€ ë°”ë‹¤ëŠ”?", options: ["ë‚¨ê·¹í•´", "ë¶ê·¹í•´", "ì¸ë„ì–‘", "ëŒ€ì„œì–‘"], answer: 1, difficulty: 'medium', reward: 100, time: 15 },
        { question: "ë‹¤ìŒ ì¤‘ 5ëŒ€ì–‘ì— ì†í•˜ì§€ ì•ŠëŠ” ë°”ë‹¤ëŠ”?", options: ["íƒœí‰ì–‘", "ëŒ€ì„œì–‘", "ì§€ì¤‘í•´", "ì¸ë„ì–‘"], answer: 2, difficulty: 'easy', reward: 50, time: 10 },
        { question: "ë‹¤ìŒ ì¤‘ 6ëŒ€ì£¼ì— ì†í•˜ì§€ ì•ŠëŠ” ëŒ€ë¥™ì€?", options: ["ì•„ì‹œì•„", "ì•„í”„ë¦¬ì¹´", "ê·¸ë¦°ë€ë“œ", "ìœ ëŸ½"], answer: 2, difficulty: 'easy', reward: 50, time: 10 },
        { question: "ì§€êµ¬ë³¸ì˜ ì¥ì ì´ *ì•„ë‹Œ* ê²ƒì€ ë¬´ì—‡ì¸ê°€ìš”?", options: ["ì‹¤ì œ ì§€êµ¬ì˜ ëª¨ìŠµì„ ì¶•ì†Œí•¨", "ëŒ€ë¥™ê³¼ ë°”ë‹¤ì˜ í¬ê¸° ë¹„êµê°€ ì‰¬ì›€", "í•œëˆˆì— ì „ ì„¸ê³„ë¥¼ ë³¼ ìˆ˜ ìˆìŒ", "ìœ„ì¹˜ì™€ ê±°ë¦¬ë¥¼ ë¹„êµì  ì •í™•í•˜ê²Œ í‘œì‹œí•¨"], answer: 2, difficulty: 'medium', reward: 100, time: 20 },
        { question: "ë””ì§€í„¸ ì˜ìƒ ì§€ë„ì˜ íŠ¹ì§•ìœ¼ë¡œ *í‹€ë¦°* ê²ƒì€?", options: ["ì •ë³´ë¥¼ ì‰½ê²Œ ìˆ˜ì •í•˜ê³  ì¶”ê°€í•  ìˆ˜ ìˆë‹¤", "ì›í•˜ëŠ” ì¥ì†Œë¥¼ í™•ëŒ€/ì¶•ì†Œí•˜ê¸° ì–´ë µë‹¤", "ìœ„ì„± ì‚¬ì§„ì„ í†µí•´ ì‹¤ì œ ëª¨ìŠµì„ ë³¼ ìˆ˜ ìˆë‹¤", "ê¸¸ ì°¾ê¸°, ê±°ë¦¬ ì¸¡ì • ë“± ë‹¤ì–‘í•œ ê¸°ëŠ¥ì´ ìˆë‹¤"], answer: 1, difficulty: 'medium', reward: 100, time: 20 },
        { question: "ì§€ë„ì—ì„œ ë•…ì˜ ë†’ë‚®ì´ë¥¼ ê°™ì€ ì§€ì ë¼ë¦¬ ì—°ê²°í•œ ì„ ì€?", options: ["ë“±ê³ ì„ ", "ìœ„ì„ ", "ê²½ì„ ", "í•´ì•ˆì„ "], answer: 0, difficulty: 'medium', reward: 100, time: 15 },
        { question: "ì§€ë„ì—ì„œ ì‹¤ì œ ê±°ë¦¬ë¥¼ ì¤„ì¸ ë¹„ìœ¨ì„ ë¬´ì—‡ì´ë¼ê³  í•˜ë‚˜ìš”?", options: ["ì¶•ì²™", "ë²”ë¡€", "ë°©ìœ„", "ë“±ê³ ì„ "], answer: 0, difficulty: 'medium', reward: 100, time: 15 },
        { question: "ì§€ë„ì—ì„œ ê¸°í˜¸ë¥¼ ì„¤ëª…í•´ ë†“ì€ ë¶€ë¶„ì€?", options: ["ì¶•ì²™", "ë²”ë¡€", "ë°©ìœ„", "ë“±ê³ ì„ "], answer: 1, difficulty: 'easy', reward: 50, time: 10 },
        { question: "ì§€ë„ì˜ ìœ„ìª½ì´ í•­ìƒ ê°€ë¦¬í‚¤ëŠ” ë°©í–¥ì€?", options: ["ë™", "ì„œ", "ë‚¨", "ë¶"], answer: 3, difficulty: 'easy', reward: 50, time: 10 },
        { question: "ì§€êµ¬ë³¸ì—ì„œ ê°€ë¡œë¡œ ê·¸ì–´ì§„ ì„ ì„ ë¬´ì—‡ì´ë¼ê³  í•˜ë‚˜ìš”?", options: ["ìœ„ì„ ", "ê²½ì„ ", "ì ë„", "ë³¸ì´ˆ ìì˜¤ì„ "], answer: 0, difficulty: 'medium', reward: 100, time: 15 },
        { question: "ì§€êµ¬ë³¸ì—ì„œ ì„¸ë¡œë¡œ ê·¸ì–´ì§„ ì„ ì„ ë¬´ì—‡ì´ë¼ê³  í•˜ë‚˜ìš”?", options: ["ìœ„ì„ ", "ê²½ì„ ", "ì ë„", "ë‚ ì§œ ë³€ê²½ì„ "], answer: 1, difficulty: 'medium', reward: 100, time: 15 },
        { question: "ìœ„ì„ ì˜ ê¸°ì¤€ì´ ë˜ë©° ìœ„ë„ 0ë„ì¸ ì„ ì€?", options: ["ë¶íšŒê·€ì„ ", "ë‚¨íšŒê·€ì„ ", "ë³¸ì´ˆ ìì˜¤ì„ ", "ì ë„"], answer: 3, difficulty: 'easy', reward: 50, time: 10 },
        { question: "ê²½ì„ ì˜ ê¸°ì¤€ì´ ë˜ë©° ê²½ë„ 0ë„ì¸ ì„ (ì˜êµ­ ê·¸ë¦¬ë‹ˆì¹˜ ì²œë¬¸ëŒ€)ì€?", options: ["ì ë„", "ë³¸ì´ˆ ìì˜¤ì„ ", "ë‚ ì§œ ë³€ê²½ì„ ", "ë‚¨íšŒê·€ì„ "], answer: 1, difficulty: 'medium', reward: 100, time: 20 },
        { question: "ìš°ë¦¬ë‚˜ë¼ëŠ” ì ë„ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ì–´ëŠ ìª½ì— ìœ„ì¹˜í•˜ë‚˜ìš”?", options: ["ë¶ìª½ (ë¶ë°˜êµ¬)", "ë‚¨ìª½ (ë‚¨ë°˜êµ¬)", "ì ë„ ìœ„", "ì•Œ ìˆ˜ ì—†ìŒ"], answer: 0, difficulty: 'easy', reward: 50, time: 10 },
        { question: "1ë…„ ë‚´ë‚´ ë¥ê³  ë¹„ê°€ ë§ì´ ë‚´ë¦¬ëŠ” ê¸°í›„ëŠ”?", options: ["ì—´ëŒ€ ê¸°í›„", "ì˜¨ëŒ€ ê¸°í›„", "í•œëŒ€ ê¸°í›„", "ê±´ì¡° ê¸°í›„"], answer: 0, difficulty: 'easy', reward: 50, time: 10 },
        { question: "ì‚¬ê³„ì ˆì´ ëšœë ·í•˜ê²Œ ë‚˜íƒ€ë‚˜ëŠ” ê¸°í›„ëŠ”?", options: ["ì—´ëŒ€ ê¸°í›„", "ì˜¨ëŒ€ ê¸°í›„", "í•œëŒ€ ê¸°í›„", "ê³ ì‚° ê¸°í›„"], answer: 1, difficulty: 'easy', reward: 50, time: 10 },
        { question: "1ë…„ ë‚´ë‚´ ì¶¥ê³ , ì‚¬ëŒë“¤ì´ ìˆœë¡ì„ ê¸°ë¥´ë©° ì‚¬ëŠ” ê¸°í›„ëŠ”?", options: ["ì—´ëŒ€ ê¸°í›„", "ê±´ì¡° ê¸°í›„", "í•œëŒ€ ê¸°í›„", "ì˜¨ëŒ€ ê¸°í›„"], answer: 2, difficulty: 'medium', reward: 100, time: 20 },
        { question: "ì¶¥ê³  ê±´ì¡°í•˜ë©°, í’€ì´ ê±°ì˜ ìë¼ì§€ ì•ŠëŠ” 'íˆ°ë“œë¼'ê°€ ë‚˜íƒ€ë‚˜ëŠ” ê¸°í›„ëŠ”?", options: ["ì˜¨ëŒ€ ê¸°í›„", "ê±´ì¡° ê¸°í›„", "í•œëŒ€ ê¸°í›„", "ì—´ëŒ€ ê¸°í›„"], answer: 2, difficulty: 'medium', reward: 100, time: 15 },
        { question: "ë°€, ì˜¥ìˆ˜ìˆ˜ ë“± ë†ì‚¬ë¥¼ ì§“ê¸°ì— ê°€ì¥ ì í•©í•˜ê³  ì‚¬ê³„ì ˆì´ ëšœë ·í•œ ê¸°í›„ëŠ”?", options: ["ì˜¨ëŒ€ ê¸°í›„", "ì—´ëŒ€ ê¸°í›„", "í•œëŒ€ ê¸°í›„", "ê±´ì¡° ê¸°í›„"], answer: 0, difficulty: 'medium', reward: 100, time: 15 },
        { question: "ì‚¬ë§‰ì´ ë„“ê²Œ ë‚˜íƒ€ë‚˜ê³ , ê°•ìˆ˜ëŸ‰ì´ ë§¤ìš° ì ì€ ê¸°í›„ëŠ”?", options: ["ì—´ëŒ€ ê¸°í›„", "ê³ ì‚° ê¸°í›„", "ëƒ‰ëŒ€ ê¸°í›„", "ê±´ì¡° ê¸°í›„"], answer: 3, difficulty: 'easy', reward: 50, time: 10 },
        { question: "ì§€ì¤‘í•´ ì—°ì•ˆì—ì„œ ì£¼ë¡œ ë‚˜íƒ€ë‚˜ë©°, ì—¬ë¦„ì´ ë¥ê³  ê±´ì¡°í•œ ê¸°í›„ëŠ”?", options: ["ì—´ëŒ€ ìš°ë¦¼ ê¸°í›„", "ì§€ì¤‘í•´ì„± ê¸°í›„", "íˆ°ë“œë¼ ê¸°í›„", "ì‚¬ë§‰ ê¸°í›„"], answer: 1, difficulty: 'medium', reward: 100, time: 20 },
        { question: "í¬ë„, ì˜¬ë¦¬ë¸Œ ë“±ì„ ë§ì´ ì¬ë°°í•˜ëŠ” ê¸°í›„ëŠ”?", options: ["ì—´ëŒ€ ê¸°í›„", "í•œëŒ€ ê¸°í›„", "ì§€ì¤‘í•´ì„± ê¸°í›„", "ëƒ‰ëŒ€ ê¸°í›„"], answer: 2, difficulty: 'medium', reward: 100, time: 15 },
        { question: "ë¶ê·¹ê³°ì´ ì‚¬ëŠ” ê³³ìœ¼ë¡œ ë§¤ìš° ì¶”ìš´ ê¸°í›„ ì§€ì—­ì€?", options: ["í•œëŒ€ ê¸°í›„", "ëƒ‰ëŒ€ ê¸°í›„", "ê³ ì‚° ê¸°í›„", "ì˜¨ëŒ€ ê¸°í›„"], answer: 0, difficulty: 'easy', reward: 50, time: 10 },
        { question: "ìš°ë¦¬ë‚˜ë¼ì²˜ëŸ¼ ëšœë ·í•œ ì‚¬ê³„ì ˆì´ ë‚˜íƒ€ë‚˜ëŠ” ê¸°í›„ëŠ”?", options: ["ì—´ëŒ€ ê¸°í›„", "ëƒ‰ëŒ€ ê¸°í›„", "ì˜¨ëŒ€ ê¸°í›„", "ê±´ì¡° ê¸°í›„"], answer: 2, difficulty: 'easy', reward: 50, time: 10 },
        { question: "1ë…„ ë‚´ë‚´ ê¸°ì˜¨ì´ ë†’ê³ , ë¹„ê°€ ì˜¤ëŠ” ê³„ì ˆê³¼ ì˜¤ì§€ ì•ŠëŠ” ê³„ì ˆì´ ëšœë ·í•œ ê¸°í›„ëŠ”?", options: ["ì‚¬ë°”ë‚˜ ê¸°í›„", "ì§€ì¤‘í•´ì„± ê¸°í›„", "ì‚¬ë§‰ ê¸°í›„", "íˆ°ë“œë¼ ê¸°í›„"], answer: 0, difficulty: 'medium', reward: 100, time: 20 },
        { question: "ë™ë‚¨ì•„ì‹œì•„ë‚˜ ì¸ë„ì²˜ëŸ¼ ê³„ì ˆì— ë”°ë¼ ë°”ëŒì˜ ë°©í–¥ì´ ë°”ë€ŒëŠ” 'ê³„ì ˆí’'ì˜ ì˜í–¥ì„ ë°›ëŠ” ê¸°í›„ëŠ”?", options: ["ì—´ëŒ€ ëª¬ìˆœ ê¸°í›„", "ì„œì•ˆ í•´ì–‘ì„± ê¸°í›„", "ëƒ‰ëŒ€ ê¸°í›„", "ê³ ì‚° ê¸°í›„"], answer: 0, difficulty: 'medium', reward: 100, time: 20 },
        { question: "í•´ë°œ ê³ ë„ê°€ ë†’ì•„ 1ë…„ ë‚´ë‚´ ë´„ì²˜ëŸ¼ ì„ ì„ í•œ ê¸°í›„ëŠ”?", options: ["ê³ ì‚° ê¸°í›„", "ëƒ‰ëŒ€ ê¸°í›„", "í•œëŒ€ ê¸°í›„", "ì‚¬ë§‰ ê¸°í›„"], answer: 0, difficulty: 'medium', reward: 100, time: 15 },
        { question: "ì‚°, ê°•, ë°”ë‹¤, ë‚ ì”¨ì²˜ëŸ¼ ìì—° ê·¸ëŒ€ë¡œì˜ í™˜ê²½ì„ ë¬´ì—‡ì´ë¼ê³  í•˜ë‚˜ìš”?", options: ["ìì—° í™˜ê²½", "ì¸ë¬¸ í™˜ê²½", "ì‚¬íšŒ í™˜ê²½", "ë„ì‹œ í™˜ê²½"], answer: 0, difficulty: 'easy', reward: 50, time: 15 },
        { question: "ì‚¬ëŒë“¤ì´ ë§Œë“  ë„ì‹œ, ê±´ë¬¼, ë„ë¡œ, ë‹¤ë¦¬ ë“±ì„ ë¬´ì—‡ì´ë¼ê³  í•˜ë‚˜ìš”?", options: ["ìì—° í™˜ê²½", "ì¸ë¬¸ í™˜ê²½", "ë¬¸í™” í™˜ê²½", "ì§€ë¦¬ í™˜ê²½"], answer: 1, difficulty: 'easy', reward: 50, time: 15 },
        { question: "ì¸ë¬¸ í™˜ê²½ì— í•´ë‹¹í•˜ëŠ” ê²ƒì„ ê³ ë¥´ì„¸ìš”.", options: ["ì‚¬ë§‰", "ë†’ì€ ì‚°", "ë…¼ê³¼ ë°­", "ê³„ì ˆí’"], answer: 2, difficulty: 'medium', reward: 100, time: 15 },
        { question: "ìì—° í™˜ê²½ì— í•´ë‹¹í•˜ëŠ” ê²ƒì„ ê³ ë¥´ì„¸ìš”.", options: ["ê³µì¥", "ì•„íŒŒíŠ¸", "ê³„ì ˆí’", "ë‹¤ë¦¬"], answer: 2, difficulty: 'medium', reward: 100, time: 15 },
        { question: "ì—´ëŒ€ ê¸°í›„ ì§€ì—­ì˜ ì „í†µ ê°€ì˜¥ì´ ê°œë°©ì ì¸ ì´ìœ ëŠ”?", options: ["ë‚˜ë¬´ê°€ ë§ì•„ì„œ", "ì¶¥ê³  ëˆˆì´ ë§ì´ ì™€ì„œ", "ë°”ëŒì´ ì˜ í†µí•˜ê³  ì‹œì›í•˜ê²Œ", "ë™ë¬¼ì˜ ì¹¨ì…ì„ ë§‰ê¸° ìœ„í•´"], answer: 2, difficulty: 'medium', reward: 100, time: 20 },
        { question: "í•œëŒ€ ê¸°í›„ ì§€ì—­ì˜ ê°€ì˜¥ì´ íì‡„ì ì´ê³  ì°½ì´ ì‘ì€ ì´ìœ ëŠ”?", options: ["ë‚˜ë¬´ê°€ ë¶€ì¡±í•´ì„œ", "ì¶”ìœ„ë¥¼ ë§‰ê³  ì—´ì„ ë³´ì¡´í•˜ê¸° ìœ„í•´", "ë¹„ê°€ ë§ì´ ì™€ì„œ", "í–‡ë¹›ì´ ë„ˆë¬´ ê°•í•´ì„œ"], answer: 1, difficulty: 'medium', reward: 100, time: 20 },
        { question: "ê±´ì¡° ê¸°í›„ ì§€ì—­ì—ì„œ ì§‘ì„ í™ë²½ëŒë¡œ ì§“ëŠ” ì´ìœ ëŠ”?", options: ["í™ì´ ë§ì•„ì„œ", "ë‚˜ë¬´ê°€ ì—†ì–´ì„œ", "ë¹„ê°€ ìì£¼ ì™€ì„œ", "ë‚®ì˜ ì—´ê¸°ë¥¼ ë§‰ê³  ë°¤ì˜ ì¶”ìœ„ë¥¼ ë§‰ê¸° ìœ„í•´"], answer: 3, difficulty: 'hard', reward: 150, time: 25 },
        { question: "ìš°ë¦¬ë‚˜ë¼ì˜ ì´ì›ƒ ë‚˜ë¼ê°€ *ì•„ë‹Œ* ê³³ì€?", options: ["ì¤‘êµ­", "ì¼ë³¸", "ëŸ¬ì‹œì•„", "ë² íŠ¸ë‚¨"], answer: 3, difficulty: 'easy', reward: 50, time: 10 },
        { question: "ì¼ë³¸ì˜ ìˆ˜ë„ëŠ” ì–´ë””ì¸ê°€ìš”?", options: ["ë² ì´ì§•", "ë„ì¿„", "ì˜¤ì‚¬ì¹´", "ëª¨ìŠ¤í¬ë°”"], answer: 1, difficulty: 'easy', reward: 50, time: 10 },
        { question: "ì„¸ê³„ì—ì„œ ì˜í† ê°€ ê°€ì¥ ë„“ì€ ë‚˜ë¼ëŠ”?", options: ["ì¤‘êµ­", "ìºë‚˜ë‹¤", "ë¯¸êµ­", "ëŸ¬ì‹œì•„"], answer: 3, difficulty: 'medium', reward: 100, time: 15 },
        { question: "ìš°ë¦¬ë‚˜ë¼(ëŒ€í•œë¯¼êµ­)ì˜ ìˆ˜ë„ëŠ” ì–´ë””ì¸ê°€ìš”?", options: ["ë¶€ì‚°", "ì¸ì²œ", "í‰ì–‘", "ì„œìš¸"], answer: 3, difficulty: 'easy', reward: 50, time: 10 },
        { question: "'ì—í íƒ‘'ì´ ìˆëŠ” ë‚˜ë¼ëŠ” ì–´ë””ì¸ê°€ìš”?", options: ["ì˜êµ­", "ì´íƒˆë¦¬ì•„", "ë…ì¼", "í”„ë‘ìŠ¤"], answer: 3, difficulty: 'medium', reward: 100, time: 15 },
        { question: "'ììœ ì˜ ì—¬ì‹ ìƒ'ì´ ìˆëŠ” ë‚˜ë¼ëŠ” ì–´ë””ì¸ê°€ìš”?", options: ["ë¯¸êµ­", "ìºë‚˜ë‹¤", "ë©•ì‹œì½”", "ë¸Œë¼ì§ˆ"], answer: 0, difficulty: 'medium', reward: 100, time: 15 },
        { question: "ì¤‘êµ­ì˜ ìˆ˜ë„ëŠ” ì–´ë””ì¸ê°€ìš”?", options: ["ìƒí•˜ì´", "í™ì½©", "ë² ì´ì§•", "í†ˆì§„"], answer: 2, difficulty: 'easy', reward: 50, time: 10 },
        { question: "ëŸ¬ì‹œì•„ì˜ ìˆ˜ë„ëŠ” ì–´ë””ì¸ê°€ìš”?", options: ["ìƒíŠ¸í˜í…Œë¥´ë¶€ë¥´í¬", "í‚¤ì´ìš°", "ë¸”ë¼ë””ë³´ìŠ¤í† í¬", "ëª¨ìŠ¤í¬ë°”"], answer: 3, difficulty: 'easy', reward: 50, time: 10 },
        { question: "ì„¸ê³„ì—ì„œ ê°€ì¥ ë†’ì€ ì‚°ì¸ 'ì—ë² ë ˆìŠ¤íŠ¸ì‚°'ì´ ìˆëŠ” ì‚°ë§¥ì€?", options: ["ì•ˆë°ìŠ¤ì‚°ë§¥", "ë¡œí‚¤ì‚°ë§¥", "ì•Œí”„ìŠ¤ì‚°ë§¥", "íˆë§ë¼ì•¼ì‚°ë§¥"], answer: 3, difficulty: 'medium', reward: 100, time: 20 },
        { question: "ì„¸ê³„ì—ì„œ ê°€ì¥ ê¸´ ê°•ì€?", options: ["ì•„ë§ˆì¡´ê°•", "ë‚˜ì¼ê°•", "ë¯¸ì‹œì‹œí”¼ê°•", "ì–‘ì¯”ê°•"], answer: 1, difficulty: 'medium', reward: 100, time: 15 },
        { question: "ì•Œí”„ìŠ¤ì‚°ë§¥ê³¼ ê´€ë ¨ì´ ê¹Šì€ ëŒ€ë¥™ì€ ì–´ë””ì¸ê°€ìš”?", options: ["ì•„ì‹œì•„", "ìœ ëŸ½", "ë¶ì•„ë©”ë¦¬ì¹´", "ì•„í”„ë¦¬ì¹´"], answer: 1, difficulty: 'medium', reward: 100, time: 15 },
        { question: "ë¯¸êµ­ì˜ ìˆ˜ë„ëŠ” ì–´ë””ì¸ê°€ìš”?", options: ["ë‰´ìš•", "ë¡œìŠ¤ì•¤ì ¤ë ˆìŠ¤", "ì›Œì‹±í„´ D.C.", "ì‹œì¹´ê³ "], answer: 2, difficulty: 'medium', reward: 100, time: 15 },
        { question: "ì˜êµ­ì˜ ìˆ˜ë„ëŠ” ì–´ë””ì¸ê°€ìš”?", options: ["íŒŒë¦¬", "ë¡œë§ˆ", "ë² ë¥¼ë¦°", "ëŸ°ë˜"], answer: 3, difficulty: 'medium', reward: 100, time: 15 },
        { question: "í”„ë‘ìŠ¤ì˜ ìˆ˜ë„ëŠ” ì–´ë””ì¸ê°€ìš”?", options: ["íŒŒë¦¬", "ë¦¬ì˜¹", "ë§ˆë¥´ì„¸ìœ ", "ë‹ˆìŠ¤"], answer: 0, difficulty: 'medium', reward: 100, time: 15 },
        { question: "ì´íƒˆë¦¬ì•„ì˜ ìˆ˜ë„ëŠ” ì–´ë””ì¸ê°€ìš”?", options: ["ë°€ë¼ë…¸", "ë‚˜í´ë¦¬", "ë¡œë§ˆ", "í”¼ë Œì²´"], answer: 2, difficulty: 'medium', reward: 100, time: 15 },
        { question: "ìºë‚˜ë‹¤ì˜ ìˆ˜ë„ëŠ” ì–´ë””ì¸ê°€ìš”?", options: ["í† ë¡ í† ", "ë°´ì¿ ë²„", "ëª¬íŠ¸ë¦¬ì˜¬", "ì˜¤íƒ€ì™€"], answer: 3, difficulty: 'hard', reward: 150, time: 20 },
        { question: "ì˜¤ìŠ¤íŠ¸ë ˆì¼ë¦¬ì•„(í˜¸ì£¼)ì˜ ìˆ˜ë„ëŠ” ì–´ë””ì¸ê°€ìš”?", options: ["ì‹œë“œë‹ˆ", "ë©œë²„ë¥¸", "ìº”ë²„ë¼", "ë¸Œë¦¬ì¦ˆë²ˆ"], answer: 2, difficulty: 'hard', reward: 150, time: 20 },
        { question: "ë¸Œë¼ì§ˆì˜ ìˆ˜ë„ëŠ” ì–´ë””ì¸ê°€ìš”?", options: ["ë¦¬ìš°ë°ìë„¤ì´ë£¨", "ìƒíŒŒìš¸ë£¨", "ë¸Œë¼ì§ˆë¦¬ì•„", "ì‚¬ìš°ë°”ë„ë¥´"], answer: 2, difficulty: 'hard', reward: 150, time: 20 },
        { question: "ì´ì§‘íŠ¸ì˜ ìˆ˜ë„ëŠ” ì–´ë””ì¸ê°€ìš”?", options: ["ì•Œë ‰ì‚°ë“œë¦¬ì•„", "ì¹´ì´ë¡œ", "ê¸°ì", "ë£©ì†Œë¥´"], answer: 1, difficulty: 'medium', reward: 100, time: 15 },
        { question: "ì¸ë„ì˜ ìˆ˜ë„ëŠ” ì–´ë””ì¸ê°€ìš”?", options: ["ë­„ë°”ì´", "ì½œì¹´íƒ€", "ë‰´ë¸ë¦¬", "ë²µê°ˆë£¨ë£¨"], answer: 2, difficulty: 'medium', reward: 100, time: 15 },
        { question: "ìš°ë¦¬ë‚˜ë¼ê°€ ì—¬ë¦„ì¼ ë•Œ, ì˜¤ìŠ¤íŠ¸ë ˆì¼ë¦¬ì•„(í˜¸ì£¼)ëŠ” ì–´ë–¤ ê³„ì ˆì¸ê°€ìš”?", options: ["ì—¬ë¦„", "ê°€ì„", "ê²¨ìš¸", "ë´„"], answer: 2, difficulty: 'medium', reward: 100, time: 15 },
        { question: "ì„ìœ ê°€ ë§ì´ ìƒì‚°ë˜ëŠ” ì§€ì—­ì€?", options: ["ìœ ëŸ½", "ë¶ê·¹", "ì„œë‚¨ì•„ì‹œì•„(ì¤‘ë™)", "ë™ë‚¨ì•„ì‹œì•„"], answer: 2, difficulty: 'medium', reward: 100, time: 15 },
        { question: "ë¡œí‚¤ì‚°ë§¥ì´ ìœ„ì¹˜í•œ ëŒ€ë¥™ì€?", options: ["ë¶ì•„ë©”ë¦¬ì¹´", "ë‚¨ì•„ë©”ë¦¬ì¹´", "ì•„í”„ë¦¬ì¹´", "ìœ ëŸ½"], answer: 0, difficulty: 'medium', reward: 100, time: 15 },
        { question: "ì•ˆë°ìŠ¤ì‚°ë§¥ì´ ìœ„ì¹˜í•œ ëŒ€ë¥™ì€?", options: ["ë¶ì•„ë©”ë¦¬ì¹´", "ë‚¨ì•„ë©”ë¦¬ì¹´", "ì•„ì‹œì•„", "ì˜¤ì„¸ì•„ë‹ˆì•„"], answer: 1, difficulty: 'medium', reward: 100, time: 15 },
        { question: "ì„¸ê³„ì˜ ì§€ë¶•ì´ë¼ê³  ë¶ˆë¦¬ëŠ” ê³ ì›ì€?", options: ["í‹°ë² íŠ¸ê³ ì›", "ì½œë¡œë¼ë„ê³ ì›", "ì´ë€ê³ ì›", "ë¸Œë¼ì§ˆê³ ì›"], answer: 0, difficulty: 'medium', reward: 100, time: 15 },
        { question: "ë‹¤ìŒ ì¤‘ ì„¬ë‚˜ë¼ëŠ”?", options: ["ì´íƒˆë¦¬ì•„", "íƒœêµ­", "ì¼ë³¸", "ë² íŠ¸ë‚¨"], answer: 2, difficulty: 'easy', reward: 50, time: 10 },
        { question: "ë…ì¼ì˜ ìˆ˜ë„ëŠ” ì–´ë””ì¸ê°€ìš”?", options: ["ë®Œí—¨", "í•¨ë¶€ë¥´í¬", "í”„ë‘í¬í‘¸ë¥´íŠ¸", "ë² ë¥¼ë¦°"], answer: 3, difficulty: 'medium', reward: 100, time: 15 },
        { question: "ìŠ¤í˜ì¸ì˜ ìˆ˜ë„ëŠ” ì–´ë””ì¸ê°€ìš”?", options: ["ë°”ë¥´ì…€ë¡œë‚˜", "ë§ˆë“œë¦¬ë“œ", "ì„¸ë¹„ì•¼", "ë°œë Œì‹œì•„"], answer: 1, difficulty: 'medium', reward: 100, time: 15 },
        { question: "ë² íŠ¸ë‚¨ì˜ ìˆ˜ë„ëŠ” ì–´ë””ì¸ê°€ìš”?", options: ["í˜¸ì°Œë¯¼", "ë‹¤ë‚­", "í•˜ë…¸ì´", "í›„ì—"], answer: 2, difficulty: 'medium', reward: 100, time: 15 },
        { question: "íƒœêµ­ì˜ ìˆ˜ë„ëŠ” ì–´ë””ì¸ê°€ìš”?", options: ["ë°©ì½•", "ì¹˜ì•™ë§ˆì´", "í‘¸ê»«", "íŒŒíƒ€ì•¼"], answer: 0, difficulty: 'medium', reward: 100, time: 15 },
        { question: "ì•„ë¥´í—¨í‹°ë‚˜ì˜ ìˆ˜ë„ëŠ” ì–´ë””ì¸ê°€ìš”?", options: ["ë¶€ì—ë…¸ìŠ¤ì•„ì´ë ˆìŠ¤", "ì‚°í‹°ì•„ê³ ", "ë¦¬ë§ˆ", "ë³´ê³ íƒ€"], answer: 0, difficulty: 'hard', reward: 150, time: 20 },
        { question: "ì¼€ëƒì˜ ìˆ˜ë„ëŠ” ì–´ë””ì¸ê°€ìš”?", options: ["ë¼ê³ ìŠ¤", "ë‚˜ì´ë¡œë¹„", "ì¹´ì´ë¡œ", "ì¼€ì´í”„íƒ€ìš´"], answer: 1, difficulty: 'hard', reward: 150, time: 20 },
        { question: "ì¤‘êµ­ì˜ 'ë§Œë¦¬ì¥ì„±'ì€ ì–´ëŠ ëŒ€ë¥™ì— ìˆë‚˜ìš”?", options: ["ìœ ëŸ½", "ì•„í”„ë¦¬ì¹´", "ì•„ì‹œì•„", "ë¶ì•„ë©”ë¦¬ì¹´"], answer: 2, difficulty: 'easy', reward: 50, time: 10 },
        { question: "ì´íƒˆë¦¬ì•„ì˜ 'ì½œë¡œì„¸ì›€'ì€ ì–´ëŠ ëŒ€ë¥™ì— ìˆë‚˜ìš”?", options: ["ìœ ëŸ½", "ì•„í”„ë¦¬ì¹´", "ì•„ì‹œì•„", "ë‚¨ì•„ë©”ë¦¬ì¹´"], answer: 0, difficulty: 'easy', reward: 50, time: 10 },
        { question: "í˜ë£¨ì˜ 'ë§ˆì¶”í”½ì¶”'ëŠ” ì–´ëŠ ëŒ€ë¥™ì— ìˆë‚˜ìš”?", options: ["ì•„í”„ë¦¬ì¹´", "ì•„ì‹œì•„", "ë¶ì•„ë©”ë¦¬ì¹´", "ë‚¨ì•„ë©”ë¦¬ì¹´"], answer: 3, difficulty: 'medium', reward: 100, time: 15 },
        { question: "ì¸ë„ì˜ 'íƒ€ì§€ë§ˆí• 'ì€ ì–´ëŠ ëŒ€ë¥™ì— ìˆë‚˜ìš”?", options: ["ì•„ì‹œì•„", "ì•„í”„ë¦¬ì¹´", "ìœ ëŸ½", "ì˜¤ì„¸ì•„ë‹ˆì•„"], answer: 0, difficulty: 'easy', reward: 50, time: 10 },
        { question: "í˜¸ì£¼ì˜ 'ì˜¤í˜ë¼ í•˜ìš°ìŠ¤'ëŠ” ì–´ëŠ ëŒ€ë¥™ì— ìˆë‚˜ìš”?", options: ["ì•„ì‹œì•„", "ì˜¤ì„¸ì•„ë‹ˆì•„", "ìœ ëŸ½", "ë¶ì•„ë©”ë¦¬ì¹´"], answer: 1, difficulty: 'easy', reward: 50, time: 10 },
        { question: "ì„¸ê³„ì—ì„œ ê°€ì¥ í° ì‚¬ë§‰ì¸ 'ì‚¬í•˜ë¼ ì‚¬ë§‰'ì€ ì–´ëŠ ëŒ€ë¥™ì— ìˆë‚˜ìš”?", options: ["ì•„ì‹œì•„", "ì˜¤ì„¸ì•„ë‹ˆì•„", "ì•„í”„ë¦¬ì¹´", "ë¶ì•„ë©”ë¦¬ì¹´"], answer: 2, difficulty: 'medium', reward: 100, time: 15 },
        { question: "ì•„ì‹œì•„ì— ìˆëŠ” 'ê³ ë¹„ ì‚¬ë§‰'ì€ ì£¼ë¡œ ì–´ëŠ ë‚˜ë¼ë“¤ì— ê±¸ì³ ìˆë‚˜ìš”?", options: ["ì¤‘êµ­ê³¼ ëª½ê³¨", "ì¸ë„ì™€ íŒŒí‚¤ìŠ¤íƒ„", "ì‚¬ìš°ë””ì•„ë¼ë¹„ì•„", "ì¹´ìíìŠ¤íƒ„"], answer: 0, difficulty: 'hard', reward: 150, time: 25 },
        { question: "ì ë„ ë¶€ê·¼ì— ìœ„ì¹˜í•œ ë‚˜ë¼ë“¤ì˜ ê¸°í›„ëŠ”?", options: ["ì—´ëŒ€ ê¸°í›„", "í•œëŒ€ ê¸°í›„", "ì˜¨ëŒ€ ê¸°í›„", "ê±´ì¡° ê¸°í›„"], answer: 0, difficulty: 'easy', reward: 50, time: 10 },
        { question: "ë¶ê·¹ì´ë‚˜ ë‚¨ê·¹ì— ê°€ê¹Œìš´ ë‚˜ë¼ë“¤ì˜ ê¸°í›„ëŠ”?", options: ["ì—´ëŒ€ ê¸°í›„", "í•œëŒ€ ê¸°í›„", "ì˜¨ëŒ€ ê¸°í›„", "ê±´ì¡° ê¸°í›„"], answer: 1, difficulty: 'easy', reward: 50, time: 10 },
        // ë¬¸í™”: ì˜ì‹ì£¼, ì „í†µ
        { question: "ì„¸ê³„ ì—¬ëŸ¬ ë‚˜ë¼ì˜ ì „í†µ ì˜ìƒì´ *ì•„ë‹Œ* ê²ƒì€?", options: ["í•œë³µ(í•œêµ­)", "ê¸°ëª¨ë…¸(ì¼ë³¸)", "ì¹˜íŒŒì˜¤(ì¤‘êµ­)", "ì²­ë°”ì§€(ë¯¸êµ­)"], answer: 3, difficulty: 'easy', reward: 50, time: 10 },
        { question: "ì¸ë„ì˜ ì—¬ì„±ë“¤ì´ ì…ëŠ” ì „í†µ ì˜ìƒì€?", options: ["ì‚¬ë¦¬", "ì•„ì˜¤ìì´", "í•œí‘¸", "í•˜ì¹´ë§ˆ"], answer: 0, difficulty: 'medium', reward: 100, time: 15 },
        { question: "ë² íŠ¸ë‚¨ì˜ ì—¬ì„±ì´ ì…ëŠ” ê¸´ ì „í†µ ì˜ìƒì€?", options: ["ì‚¬ë¦¬", "ì•„ì˜¤ìì´", "ì¹˜íŒŒì˜¤", "ê¸°ëª¨ë…¸"], answer: 1, difficulty: 'medium', reward: 100, time: 15 },
        { question: "ìŠ¤ì½”í‹€ëœë“œ ë‚¨ì„±ë“¤ì´ ì…ëŠ” ì²´í¬ë¬´ëŠ¬ ì¹˜ë§ˆëŠ”?", options: ["í‚¬íŠ¸", "íŒì´ˆ", "ë¡œì¸í´ë¡œìŠ¤", "í† ê°€"], answer: 0, difficulty: 'medium', reward: 100, time: 15 },
        { question: "ë°€ì„ ì£¼ì‹ìœ¼ë¡œ í•˜ëŠ” ì§€ì—­ì—ì„œ ì£¼ë¡œ ë¨¹ëŠ” ìŒì‹ì€?", options: ["ë¹µ", "ìŒ€ë°¥", "ê°ì", "ì˜¥ìˆ˜ìˆ˜"], answer: 0, difficulty: 'easy', reward: 50, time: 10 },
        { question: "ìŒ€ì„ ì£¼ì‹ìœ¼ë¡œ í•˜ëŠ” ì§€ì—­ì€ ì£¼ë¡œ ì–´ë””ì¸ê°€ìš”?", options: ["ìœ ëŸ½", "ì•„ì‹œì•„", "ë¶ì•„ë©”ë¦¬ì¹´", "ì˜¤ì„¸ì•„ë‹ˆì•„"], answer: 1, difficulty: 'easy', reward: 50, time: 10 },
        { question: "ì´íƒˆë¦¬ì•„ì˜ ëŒ€í‘œì ì¸ ìŒì‹ìœ¼ë¡œ *í‹€ë¦°* ê²ƒì€?", options: ["í”¼ì", "íŒŒìŠ¤íƒ€", "ìŠ¤ì‹œ", "ë¼ìëƒ"], answer: 2, difficulty: 'easy', reward: 50, time: 10 },
        { question: "ì¼ë³¸ì˜ ëŒ€í‘œì ì¸ ìŒì‹ìœ¼ë¡œ, ì‹ì´ˆë¡œ ê°„ì„ í•œ ë°¥ì— ìƒì„  ë“±ì„ ì–¹ì€ ê²ƒì€?", options: ["ë¼ë©˜", "ìŠ¤ì‹œ", "ì¹´ë ˆ", "ëˆì¹´ì¸ "], answer: 1, difficulty: 'easy', reward: 50, time: 10 },
        { question: "ë©•ì‹œì½”ì˜ ëŒ€í‘œì ì¸ ìŒì‹ìœ¼ë¡œ, í† ë¥´í‹°ì•¼ì— ê³ ê¸°, ì±„ì†Œ ë“±ì„ ì‹¸ ë¨¹ëŠ” ê²ƒì€?", options: ["íƒ€ì½”", "íŒŒì—ì•¼", "ë¶€ë¦¬í† ", "ë‚˜ì´ˆ"], answer: 0, difficulty: 'medium', reward: 100, time: 15 },
        { question: "ìš°ë¦¬ë‚˜ë¼ì˜ ëŒ€í‘œì ì¸ ë°œíš¨ ìŒì‹ì€?", options: ["í”¼ì", "ê¹€ì¹˜", "ìŠ¤ì‹œ", "ë¹µ"], answer: 1, difficulty: 'easy', reward: 50, time: 10 },
        { question: "ë”ìš´ ê¸°í›„ ì§€ì—­ì˜ ì „í†µ ì˜ìƒ íŠ¹ì§•ì€?", options: ["í„¸ê°€ì£½ ì˜·", "ëª¸ì— ë¶™ëŠ” ì˜·", "ì–‡ê³  í—ë í•œ ì˜·", "ê²€ì€ìƒ‰ ì˜·"], answer: 2, difficulty: 'easy', reward: 50, time: 15 },
        { question: "ì¶”ìš´ ê¸°í›„ ì§€ì—­ì˜ ì „í†µ ì˜ìƒ íŠ¹ì§•ì€?", options: ["í„¸ê°€ì£½ ì˜·", "ì–‡ì€ ë©´ ì˜·", "ë°˜íŒ”, ë°˜ë°”ì§€", "í—ë í•œ ì˜·"], answer: 0, difficulty: 'easy', reward: 50, time: 15 },
        { question: "ê±´ì¡° ê¸°í›„ ì§€ì—­ì—ì„œ ì˜¨ëª¸ì„ ê°ì‹¸ëŠ” ì˜·ì„ ì…ëŠ” ì´ìœ ëŠ”?", options: ["ë©‹ì„ ë‚´ê¸° ìœ„í•´", "ê°•í•œ í–‡ë¹›ê³¼ ëª¨ë˜ë°”ëŒì„ ë§‰ê¸° ìœ„í•´", "ì¢…êµì ì¸ ì´ìœ ë¡œ", "ì¶”ìœ„ë¥¼ ë§‰ê¸° ìœ„í•´"], answer: 1, difficulty: 'medium', reward: 100, time: 20 },
        { question: "ì„¸ê³„ ì—¬ëŸ¬ ë‚˜ë¼ê°€ ëª¨ì—¬ í‰í™”ì™€ ì•ˆì „ì„ ë…¼ì˜í•˜ëŠ” êµ­ì œê¸°êµ¬ëŠ”?", options: ["NATO (ë‚˜í† )", "UN (êµ­ì œ ì—°í•©)", "WHO (ì„¸ê³„ ë³´ê±´ ê¸°êµ¬)", "APEC (ì•„ì‹œì•„ íƒœí‰ì–‘ ê²½ì œ í˜‘ë ¥ì²´)"], answer: 1, difficulty: 'medium', reward: 100, time: 20 },
        { question: "4ë…„ë§ˆë‹¤ ì—´ë¦¬ëŠ” ì„¸ê³„ì ì¸ ìŠ¤í¬ì¸  ì¶•ì œëŠ”?", options: ["ì›”ë“œì»µ", "ë™ê³„ ì˜¬ë¦¼í”½", "í•˜ê³„ ì˜¬ë¦¼í”½", "ì•„ì‹œì•ˆ ê²Œì„"], answer: 2, difficulty: 'easy', reward: 50, time: 10 },
    ];


    // --- 2. ë‹¤ì´ìŠ¤ ì„¤ì • ---
    const DICE_TYPES = ['fire', 'ice', 'wind', 'earth', 'light'];
    const DICE_CONFIG = {
        'fire': { name: 'ë¶ˆ', color: '#e74c3c' },
        'ice': { name: 'ì–¼ìŒ', color: '#3498db' },
        'wind': { name: 'ë°”ëŒ', color: '#2ecc71' },
        'earth': { name: 'ëŒ€ì§€', color: '#f39c12' },
        'light': { name: 'ë¹›', color: '#f1c40f' },
    };
    const GRID_ROWS = 4;
    const GRID_COLS = 5;
    const GRID_SIZE = GRID_ROWS * GRID_COLS;

    // --- 3. ìº”ë²„ìŠ¤ & ê¸¸(Path) ì„¤ì • ---
    const canvas = document.getElementById('game-canvas');
    const ctx = canvas.getContext('2d');

    const computedStyles = getComputedStyle(document.documentElement);
    const PATH_COLOR = computedStyles.getPropertyValue('--path-color').trim();
    const GRID_BG_COLOR = computedStyles.getPropertyValue('--grid-bg').trim();
    const GRID_BORDER_COLOR = computedStyles.getPropertyValue('--grid-border').trim();

    const CELL_SIZE = 70;
    const GAP = 10;
    const PATH_WIDTH = 50;

    const GRID_OFFSET_X = PATH_WIDTH;
    const GRID_OFFSET_Y = PATH_WIDTH;
    const GRID_WIDTH = (CELL_SIZE * GRID_COLS) + (GAP * (GRID_COLS - 1)); // 390
    const GRID_HEIGHT = (CELL_SIZE * GRID_ROWS) + (GAP * (GRID_ROWS - 1)); // 310

    canvas.width = GRID_WIDTH + PATH_WIDTH * 2; // 490
    canvas.height = GRID_HEIGHT + PATH_WIDTH * 2; // 410

    const pathCenter = PATH_WIDTH / 2;
    const enemyPath = [
        { x: 0, y: pathCenter },
        { x: pathCenter, y: pathCenter },
        { x: canvas.width - pathCenter, y: pathCenter },
        { x: canvas.width - pathCenter, y: canvas.height - pathCenter },
        { x: pathCenter, y: canvas.height - pathCenter },
        { x: pathCenter, y: pathCenter + 20 }
    ];

    // --- 4. ê²Œì„ ìƒíƒœ ë³€ìˆ˜ ---
    let resources = 100;
    let summonCost = 50;
    let playerHP = 20;
    const MAX_HP = 20;
    let wave = 0;
    const MAX_WAVE = 50; // [ì‹ ê·œ] ìµœëŒ€ ì›¨ì´ë¸Œ
    let enemiesToSpawn = 0;
    let spawnInterval;
    let gameRunning = false;

    let diceGrid = new Array(GRID_SIZE).fill(null);
    let enemies = [];
    let projectiles = [];
    let damageNumbers = [];

    let diceUpgrades = {};
    const UPGRADE_COST_START = 10;
    const UPGRADE_COST_STEP  = 5;

    let totalKnowledgePoints = 0;
    let rogueliteUpgrades = {};
    const KP_KEY = 'quizTowerDefense_KP';
    const ROGUELITE_KEY = 'quizTowerDefense_Roguelite';
    const ACHIEVEMENTS_KEY = 'quizTowerDefense_Achievements';

    let achievements = {};

    let currentQuiz = null;
    let quizTimerInterval;
    let timeLeft = 0;

    let dragState = {
        isDragging: false,
        die: null,
        startIndex: -1,
        x: 0,
        y: 0
    };
    let animationFrameId;

    // --- 5. DOM ìš”ì†Œ (HTML UI) ---
    const resourceDisplay = document.getElementById('resource-display');
    const summonBtn = document.getElementById('summon-dice-btn');
    const summonCostDisplay = document.getElementById('summon-cost-display');
    const hpDisplay = document.getElementById('player-hp');
    const waveDisplay = document.getElementById('wave-display');

    const questionEl = document.getElementById('question');
    const answerOptionsEl = document.getElementById('answer-options');
    const quizRewardDisplay = document.getElementById('quiz-reward');
    const timerBarProgress = document.getElementById('quiz-timer-progress');
    const skipBtn = document.getElementById('skip-btn');
    const quizFeedback = document.getElementById('quiz-feedback');

    const startScreenModal = document.getElementById('start-screen');
    const rogueliteModal = document.getElementById('roguelite-upgrade-modal');
    const achievementsModal = document.getElementById('achievements-modal');
    const gameOverModal = document.getElementById('game-over-modal');
    const gameVictoryModal = document.getElementById('game-victory-modal');

    const finalWaveDisplay = document.getElementById('final-wave');
    const pointsEarnedDisplay = document.getElementById('points-earned');
    const totalPointsDisplay = document.getElementById('total-points');
    const restartBtn = document.getElementById('restart-btn');

    const victoryPointsEarnedDisplay = document.getElementById('victory-points-earned');
    const victoryTotalPointsDisplay = document.getElementById('victory-total-points');
    const victoryRestartBtn = document.getElementById('victory-restart-btn');

    const totalPointsDisplayRoguelite = document.getElementById('total-points-display');
    const rogueliteButtons = {
        startQP: { btn: document.getElementById('roguelite-startQP-btn'), desc: document.getElementById('roguelite-startQP-desc'), cost: document.getElementById('roguelite-startQP-cost') },
        quizQP: { btn: document.getElementById('roguelite-quizQP-btn'), desc: document.getElementById('roguelite-quizQP-desc'), cost: document.getElementById('roguelite-quizQP-cost') },
        highSpawn: { btn: document.getElementById('roguelite-highSpawn-btn'), desc: document.getElementById('roguelite-highSpawn-desc'), cost: document.getElementById('roguelite-highSpawn-cost') },
        mergeBonus: { btn: document.getElementById('roguelite-mergeBonus-btn'), desc: document.getElementById('roguelite-mergeBonus-desc'), cost: document.getElementById('roguelite-mergeBonus-cost') }
    };

    const achievementList = document.getElementById('achievement-list');

    const upgradeDOMElements = {};
    DICE_TYPES.forEach(type => {
        upgradeDOMElements[type] = {
            section: document.getElementById(`upgrade-${type}`),
            lvl: document.getElementById(`${type}-lvl`),
            cost: document.getElementById(`${type}-cost`),
        };
    });

    const gameContainer = document.getElementById('game-container');
    const quizContainer = document.getElementById('quiz-container');


    // --- 6. í€´ì¦ˆ ë¡œì§ (HTML UI ì œì–´) ---
    function loadQuiz() {
        quizFeedback.textContent = '';
        answerOptionsEl.innerHTML = '';

        clearInterval(quizTimerInterval);
        currentQuiz = quizData[Math.floor(Math.random() * quizData.length)];

        questionEl.textContent = currentQuiz.question;
        const reward = Math.round(currentQuiz.reward * (1 + ((rogueliteUpgrades && rogueliteUpgrades.quizQP ? rogueliteUpgrades.quizQP.level : 1) - 1) * 0.1));
        quizRewardDisplay.textContent = `íšë“ QP: ${reward}`;

        currentQuiz.options.forEach((option, index) => {
            const btn = document.createElement('button');
            btn.className = 'option-btn';
            btn.innerHTML = `<span class="option-label">${index + 1}. ${option}</span>`;
            btn.onclick = () => checkAnswer(index, btn);
            answerOptionsEl.appendChild(btn);
        });
        if (typeof autosizeOptionLabels==='function') autosizeOptionLabels();

        timeLeft = currentQuiz.time;
        timerBarProgress.style.transition = 'none';
        timerBarProgress.style.width = '100%';

        setTimeout(() => {
            timerBarProgress.style.transition = `width ${timeLeft}s linear`;
            timerBarProgress.style.width = '0%';
        }, 50);

        quizTimerInterval = setInterval(() => {
            timeLeft -= 0.1;
            if (timeLeft <= 0) {
                skipQuiz();
            }
        }, 100);
    }

    function checkAnswer(userAnswerIndex, btnElement) {
        clearInterval(quizTimerInterval);
        Array.from(answerOptionsEl.children).forEach(btn => btn.disabled = true);

        const currentWidth = timerBarProgress.style.width;
        timerBarProgress.style.transition = 'none';
        timerBarProgress.style.width = currentWidth;

        const isCorrect = (userAnswerIndex === currentQuiz.answer);

        if (isCorrect) {
            const reward = Math.round(currentQuiz.reward * (1 + ((rogueliteUpgrades && rogueliteUpgrades.quizQP ? rogueliteUpgrades.quizQP.level : 1) - 1) * 0.1));
            quizFeedback.textContent = `ì •ë‹µ! +${reward} QP`;
            quizFeedback.style.color = 'green';
            btnElement.classList.add('correct');
            addResources(reward);
        } else {
            quizFeedback.textContent = `ì˜¤ë‹µ... (ì •ë‹µ: ${currentQuiz.options[currentQuiz.answer]})`;
            quizFeedback.style.color = 'red';
            btnElement.classList.add('wrong');
            answerOptionsEl.children[currentQuiz.answer].classList.add('correct');
        }

        setTimeout(loadQuiz, 1500);
    }

    function skipQuiz() {
        clearInterval(quizTimerInterval);
        quizFeedback.textContent = 'ìŠ¤í‚µí–ˆìŠµë‹ˆë‹¤.';
        quizFeedback.style.color = 'gray';
        setTimeout(loadQuiz, 500);
    }
    skipBtn.onclick = skipQuiz;
    if (typeof autosizeOptionLabels==='function') window.setTimeout(autosizeOptionLabels, 0);

    // --- 7. ê²Œì„ UI ë¡œì§ (HTML UI ì œì–´) ---
    function addResources(amount) {
        resources += amount;
        updateUI();
    }

    function _upgradePreview(level){
        // í˜„ì¬ ì„¤ê³„: ë°ë¯¸ì§€ (ë ˆë²¨-1)*10% ëˆ„ì , ì¿¨ë‹¤ìš´ Ã—0.95^(ë ˆë²¨-1)
        const currDmgPct = (Math.max(1, level)-1) * 10;
        const nextDmgPct = (level) * 10;
        const currCdMul  = Math.pow(0.95, Math.max(1, level)-1);
        const nextCdMul  = Math.pow(0.95, level);
        return { currDmgPct, nextDmgPct, currCdMul, nextCdMul };
    }

    function _fmtPct(x){ return (Math.round(x*10)/10).toFixed(1); }

    function showUpgradeToast(type, beforeLv, afterLv){
        const t = document.getElementById('upgrade-toast');
        if(!t) return;
        const a = _upgradePreview(afterLv);
        t.textContent = `ã€${DICE_CONFIG[type].name}ã€‘ Lv${beforeLv}â†’${afterLv}  ë°ë¯¸ì§€ +10% (ëˆ„ì  +${a.currDmgPct}%) Â· ì¿¨ë‹¤ìš´ Ã—${_fmtPct(a.currCdMul)}`;
        t.classList.add('show');
        setTimeout(()=>t.classList.remove('show'), 1300);
    }


    function updateUI() {
        resourceDisplay.textContent = `QP: ${resources}`;
        summonCostDisplay.textContent = `ë¹„ìš©: ${summonCost} QP`;
        summonBtn.disabled = resources < summonCost;
        hpDisplay.textContent = `${playerHP}`;
        waveDisplay.textContent = `${wave}`;

        DICE_TYPES.forEach(type => {
            const upgrade = diceUpgrades[type];
            const els = upgradeDOMElements[type];
            els.lvl.textContent = `Lvl ${upgrade.level}`;
            els.cost.textContent = `${upgrade.cost} QP`;
            if (resources < upgrade.cost) {
                els.section.classList.add('disabled');
            } else {
                els.section.classList.remove('disabled');
            }
        });
    }

    // --- 7.5 ì¸ê²Œì„ ê°•í™” ë¡œì§ ---
    function initInGameUpgrades() {
        diceUpgrades = {};
        DICE_TYPES.forEach(type => {
            diceUpgrades[type] = {
                level: 1,
                cost: UPGRADE_COST_START
            };
            const els = upgradeDOMElements[type];
            els.section.onclick = () => handleInGameUpgrade(type);
        });
    }

    function handleInGameUpgrade(type) {
        const upgrade = diceUpgrades[type];
        if (resources >= upgrade.cost) {
            resources -= upgrade.cost;
            upgrade.level++;
            // ê³±ì…ˆ ìŠ¤ì¼€ì¼ ëŒ€ì‹  ê³ ì • ì¦ê°€(+5)
            upgrade.cost += UPGRADE_COST_STEP;
            updateUI();
        }
    }

    // --- 8. ë‹¤ì´ìŠ¤ ì†Œí™˜ ë¡œì§ (diceGrid ë°ì´í„° ë³€ê²½) ---
    function summonDice() {
        if (resources < summonCost) return;
        const emptyIndex = diceGrid.findIndex(cell => cell === null);
        if (emptyIndex === -1) {
            quizFeedback.textContent = 'ê·¸ë¦¬ë“œê°€ ê½‰ ì°¼ìŠµë‹ˆë‹¤!';
            quizFeedback.style.color = 'orange';
            return;
        }
        resources -= summonCost;
        summonCost += 10;

        let startPips = 1;
        const highSpawnChance = ((rogueliteUpgrades && rogueliteUpgrades.highSpawn ? rogueliteUpgrades.highSpawn.level : 1) - 1) * 0.01;
        if (Math.random() < highSpawnChance) {
            startPips = 2;
        }
        const randomType = DICE_TYPES[Math.floor(Math.random() * DICE_TYPES.length)];
        diceGrid[emptyIndex] = {
            type: randomType,
            pips: startPips,
            cooldown: 0
        };
        updateUI();
    }
    summonBtn.onclick = summonDice;

    // --- 9. ìº”ë²„ìŠ¤ ë Œë”ë§ ë¡œì§ ---
    function gameLoop() {
        if (!gameRunning) return;
        clearCanvas();
        drawPath();
        drawGrid();
        drawDice();
        updateEnemies();
        drawEnemies();
        updateDiceAttacks();
        updateProjectiles();
        drawProjectiles();
        updateDamageNumbers();
        drawDamageNumbers();
        drawDraggingDice();
        animationFrameId = requestAnimationFrame(gameLoop);
    }
    function clearCanvas() { ctx.clearRect(0, 0, canvas.width, canvas.height); }
    function drawPath() {
        ctx.fillStyle = PATH_COLOR;
        ctx.fillRect(0, 0, canvas.width, PATH_WIDTH);
        ctx.fillRect(0, canvas.height - PATH_WIDTH, canvas.width, PATH_WIDTH);
        ctx.fillRect(0, PATH_WIDTH, PATH_WIDTH, GRID_HEIGHT);
        ctx.fillRect(canvas.width - PATH_WIDTH, PATH_WIDTH, PATH_WIDTH, GRID_HEIGHT);
        const basePos = enemyPath[enemyPath.length-1];
        const baseSize = 30;
        ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
        ctx.beginPath();
        ctx.moveTo(basePos.x, basePos.y - baseSize / 2);
        ctx.lineTo(basePos.x - baseSize / 2, basePos.y + baseSize / 2);
        ctx.lineTo(basePos.x + baseSize / 2, basePos.y + baseSize / 2);
        ctx.closePath();
        ctx.fill();
    }
    function drawGrid() {
        ctx.strokeStyle = GRID_BORDER_COLOR;
        ctx.fillStyle = GRID_BG_COLOR;
        for (let i = 0; i < GRID_SIZE; i++) {
            const { x, y } = getGridCoords(i);
            ctx.beginPath();
            ctx.roundRect(x, y, CELL_SIZE, CELL_SIZE, 6);
            ctx.fill();
            ctx.stroke();
        }
    }
    function drawDice() {
        for (let i = 0; i < GRID_SIZE; i++) {
            const die = diceGrid[i];
            if (die && !(dragState.isDragging && dragState.startIndex === i)) {
                const { x, y } = getGridCoords(i);
                drawDie(x, y, die);
            }
        }
    }
    function drawDraggingDice() {
        if (dragState.isDragging && dragState.die) {
            const x = dragState.x - CELL_SIZE / 2;
            const y = dragState.y - CELL_SIZE / 2;
            ctx.save();
            ctx.globalAlpha = 0.7;
            ctx.shadowColor = 'rgba(0,0,0,0.3)';
            ctx.shadowBlur = 10;
            drawDie(x, y, dragState.die);
            ctx.restore();
        }
    }
    function drawDie(x, y, die) {
        ctx.fillStyle = DICE_CONFIG[die.type].color;
        ctx.beginPath();
        ctx.roundRect(x, y, CELL_SIZE, CELL_SIZE, 10);
        ctx.fill();
        drawPips(x, y, die.pips);
    }
    function drawPips(x, y, pips) {
        const pipSize = 5;
        const padding = 12;
        const center = CELL_SIZE / 2;
        const left = padding, right = CELL_SIZE - padding;
        const top = padding, bottom = CELL_SIZE - padding;
        const positions = {
            1: [[center, center]], 2: [[left, top], [right, bottom]], 3: [[left, top], [center, center], [right, bottom]],
            4: [[left, top], [right, top], [left, bottom], [right, bottom]], 5: [[left, top], [right, top], [center, center], [left, bottom], [right, bottom]],
            6: [[left, top], [right, top], [left, center], [right, center], [left, bottom], [right, bottom]],
            7: [[left, top], [right, top], [left, center], [center, center], [right, center], [left, bottom], [right, bottom]]
        };
        const pipsToDraw = positions[pips] || positions[7];
        ctx.fillStyle = 'white';
        ctx.shadowColor = 'rgba(0,0,0,0.5)';
        ctx.shadowBlur = 2;
        pipsToDraw.forEach(([px, py]) => {
            ctx.beginPath();
            ctx.arc(x + px, y + py, pipSize, 0, Math.PI * 2);
            ctx.fill();
        });
        ctx.shadowColor = 'transparent';
        ctx.shadowBlur = 0;
    }

    // --- 10. ì  (Enemy) ë¡œì§ ---
    class Enemy {
        constructor(isBoss = false) {
            this.isBoss = isBoss;
            this.pathIndex = 1;
            this.statusEffects = {};
            // [ìˆ˜ì •] ê³„ë‹¨í˜• ë‚œì´ë„ ê³„ì‚°
            const chapter = Math.max(0, Math.floor((wave - 1) / 10)); // wave 1~10 = chap 0
            const postWave6Multiplier = (wave > 6) ? 1.5 : 1.0; // [ìˆ˜ì •] 6ì›¨ì´ë¸Œ ì´í›„ ë‚œì´ë„ ìƒìŠ¹ (1.5 -> 2.2)

            if (isBoss) {
                this.x = enemyPath[0].x; this.y = enemyPath[0].y;
                this.originalSpeed = 0.5 + (chapter * 0.15);
                this.speed = this.originalSpeed;
                this.maxHp = (500 + (wave * 100)) * Math.pow(2.7, chapter) * postWave6Multiplier; // [ìˆ˜ì •] ë‚œì´ë„ ìƒí–¥ (100 -> 120, 2.7 -> 3.0)
                this.hp = this.maxHp;
                this.radius = 20; this.color = '#8e44ad';
            } else {
                this.x = enemyPath[0].x; this.y = enemyPath[0].y;
                this.originalSpeed = 1 + (chapter * 0.3) + (wave * 0.02);
                this.speed = this.originalSpeed;
                this.maxHp = (50 + (wave * 20)) * Math.pow(2.7, chapter) * postWave6Multiplier; // [ìˆ˜ì •] ë‚œì´ë„ ìƒí–¥ (20 -> 25, 2.7 -> 3.0)
                this.hp = this.maxHp;
                this.radius = 10; this.color = '#c0392b';
            }
        }
        applyStatus(type, pips) {
            switch(type) {
                case 'ice': this.statusEffects.slow = { duration: 120 }; this.speed = this.originalSpeed * 0.5; break;
                case 'fire': this.statusEffects.burn = { duration: 180, damage: pips * 2, tick: 60 }; break;
                case 'wind': this.statusEffects.poison = { duration: 300, damage: pips * 1, tick: 60 }; break;
                case 'earth': this.statusEffects.stun = { duration: 15 }; break;
                case 'light': this.statusEffects.armorBreak = { duration: 240 }; break;
            }
        }
        updateStatusEffects() {
            for (const key in this.statusEffects) {
                const effect = this.statusEffects[key];
                effect.duration--;
                if (key === 'burn' || key === 'poison') {
                    effect.tick--;
                    if (effect.tick <= 0) {
                        const upgrade = diceUpgrades[key === 'burn' ? 'fire' : 'wind'];
                        const dotDamage = Math.round(effect.damage * (1 + (upgrade.level - 1) * 0.1));
                        this.hp -= dotDamage;
                        createDamageNumber(this.x, this.y - this.radius, dotDamage, (key === 'burn' ? '#e74c3c' : '#2ecc71'));
                        effect.tick = 60;
                    }
                }
                if (effect.duration <= 0) {
                    if (key === 'slow') { this.speed = this.originalSpeed; }
                    delete this.statusEffects[key];
                }
            }
        }
        move() {
            this.updateStatusEffects();
            if (this.statusEffects.stun) return;
            if (this.pathIndex >= enemyPath.length) return;
            const target = enemyPath[this.pathIndex];
            const dx = target.x - this.x; const dy = target.y - this.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < this.speed) {
                this.x = target.x; this.y = target.y;
                this.pathIndex++;
            } else {
                this.x += (dx / dist) * this.speed;
                this.y += (dy / dist) * this.speed;
            }
        }
        draw() {
            ctx.fillStyle = this.color;
            if (this.statusEffects.slow) ctx.fillStyle = '#3498db';
            if (this.statusEffects.poison) ctx.fillStyle = '#2ecc71';
            if (this.statusEffects.armorBreak) ctx.fillStyle = '#f1c40f';
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            ctx.fill();
            if(this.statusEffects.burn) { ctx.strokeStyle = '#e74c3c'; ctx.lineWidth = 3; ctx.stroke(); }
            if(this.statusEffects.stun) { ctx.fillStyle = 'white'; ctx.font = 'bold 12px sans-serif'; ctx.textAlign = 'center'; ctx.fillText('Stun!', this.x, this.y - this.radius - 15); }
            const hpBarWidth = this.isBoss ? 40 : 20; const hpBarHeight = 4;
            const hpPercent = this.hp / this.maxHp;
            ctx.fillStyle = '#e74c3c';
            ctx.fillRect(this.x - hpBarWidth / 2, this.y - this.radius - 10, hpBarWidth, hpBarHeight);
            ctx.fillStyle = '#2ecc71';
            ctx.fillRect(this.x - hpBarWidth / 2, this.y - this.radius - 10, hpBarWidth * hpPercent, hpBarHeight);
        }
    }
    function startNextWave() {
        if (wave > MAX_WAVE) {
            gameVictory();
            return;
        }

        wave++;
        waveDisplay.textContent = wave;
        checkAchievements();
        const chapter = Math.max(0, Math.floor((wave - 1) / 10));
        if (wave % 5 === 0) {
            enemies.push(new Enemy(true));
            enemiesToSpawn = 0;
            clearInterval(spawnInterval);
        } else {
            enemiesToSpawn = 10 + (wave * 3) + (chapter * 20); // [ìˆ˜ì •] ìŠ¤í° ìˆ˜ ìƒí–¥
            spawnInterval = setInterval(() => {
                if (enemiesToSpawn > 0) {
                    enemies.push(new Enemy(false));
                    enemiesToSpawn--;
                } else {
                    clearInterval(spawnInterval);
                }
            }, Math.max(100, 1000 - (wave * 30) - (chapter * 70))); // [ìˆ˜ì •] ìŠ¤í° ì†ë„ ìƒí–¥
        }
    }
    function updateEnemies() {
        let waveOver = (enemiesToSpawn === 0 && enemies.length === 0);
        for (let i = enemies.length - 1; i >= 0; i--) {
            const enemy = enemies[i];
            enemy.move();
            if (enemy.pathIndex >= enemyPath.length) {
                enemies.splice(i, 1);
                playerHP--;
                if (playerHP <= 0) { playerHP = 0; gameOver(); }
                updateUI();
            } else if (enemy.hp <= 0) {
                const reward = enemy.isBoss ? (100 + wave * 10) : (5 + wave);
                addResources(reward);
                enemies.splice(i, 1);
            }
        }
        if (waveOver && gameRunning) {
            if (wave === MAX_WAVE) { // 50ì›¨ì´ë¸Œ í´ë¦¬ì–´ ì‹œ
                gameVictory();
            } else {
                startNextWave();
            }
        }
    }
    function drawEnemies() { enemies.forEach(enemy => enemy.draw()); }

    // --- 11. ë‹¤ì´ìŠ¤ ê³µê²© & ë°œì‚¬ì²´ ë¡œì§ ---
    class Projectile {
        constructor(x, y, target, die) {
            this.x = x; this.y = y;
            this.target = target;
            this.speed = 5;
            this.pips = die.pips; this.type = die.type;
            this.color = DICE_CONFIG[die.type].color;
            this.radius = 4;
            const upgrade = diceUpgrades[this.type];
            const baseDamage = die.pips * 10 + (die.pips - 1) * 5;
            this.damage = Math.round(baseDamage * (1 + (upgrade.level - 1) * 0.1));
        }
        move() {
            if (!this.target || this.target.hp <= 0) return false;
            const dx = this.target.x - this.x; const dy = this.target.y - this.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < this.speed) {
                let damageDealt = this.damage;
                if (this.target.statusEffects.armorBreak) { damageDealt *= 1.3; }
                damageDealt = Math.round(damageDealt);
                this.target.hp -= damageDealt;
                createDamageNumber(this.target.x, this.target.y - this.target.radius, damageDealt, this.color);
                this.target.applyStatus(this.type, this.pips);
                return false;
            } else {
                this.x += (dx / dist) * this.speed;
                this.y += (dy / dist) * this.speed;
                return true;
            }
        }
        draw() {
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            ctx.fill();
        }
    }
    function findTarget(dieX, dieY, range) {
        let closestEnemy = null; let minRange = range;
        for (const enemy of enemies) {
            const dx = enemy.x - dieX; const dy = enemy.y - dieY;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < minRange) { minRange = dist; closestEnemy = enemy; }
        }
        return closestEnemy;
    }
    function updateDiceAttacks() {
        for (let i = 0; i < diceGrid.length; i++) {
            const die = diceGrid[i];
            if (!die) continue;
            if (die.cooldown > 0) { die.cooldown--; continue; }
            const { x, y } = getGridCoords(i);
            const dieCenterX = x + CELL_SIZE / 2; const dieCenterY = y + CELL_SIZE / 2;
            const range = 100 + die.pips * 15;
            let target = findTarget(dieCenterX, dieCenterY, range);
            if (target) {
                projectiles.push(new Projectile(dieCenterX, dieCenterY, target, die));
                const upgrade = diceUpgrades[die.type];
                const baseCooldown = 60 - die.pips * 5;
                die.cooldown = Math.max(10, Math.round(baseCooldown * Math.pow(0.95, upgrade.level - 1)));
            }
        }
    }
    function updateProjectiles() {
        for (let i = projectiles.length - 1; i >= 0; i--) {
            if (!projectiles[i].move()) { projectiles.splice(i, 1); }
        }
    }
    function drawProjectiles() { projectiles.forEach(p => p.draw()); }

    // --- 11.5 ë°ë¯¸ì§€ ìˆ«ì ë¡œì§ ---
    function createDamageNumber(x, y, text, color) {
        damageNumbers.push({ x, y, text: Math.round(text), color, alpha: 1.0, duration: 60 });
    }
    function updateDamageNumbers() {
        for (let i = damageNumbers.length - 1; i >= 0; i--) {
            const dn = damageNumbers[i];
            dn.y -= 0.5; dn.duration--;
            dn.alpha = dn.duration / 60;
            if (dn.duration <= 0) { damageNumbers.splice(i, 1); }
        }
    }
    function drawDamageNumbers() {
        ctx.save();
        ctx.font = 'bold 14px sans-serif'; ctx.textAlign = 'center';
        for (const dn of damageNumbers) {
            ctx.globalAlpha = dn.alpha; ctx.fillStyle = dn.color;
            ctx.fillText(dn.text, dn.x, dn.y);
        }
        ctx.restore();
    }

    // --- 12. ìº”ë²„ìŠ¤ ì´ë²¤íŠ¸ í•¸ë“¤ë§ (ë“œë˜ê·¸ ì•¤ ë“œë¡­) ---
    function getMousePos(e) {
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width; const scaleY = canvas.height / rect.height;
        let x, y;
        if (e.changedTouches) {
            x = (e.changedTouches[0].clientX - rect.left) * scaleX;
            y = (e.changedTouches[0].clientY - rect.top) * scaleY;
        } else {
            x = (e.clientX - rect.left) * scaleX;
            y = (e.clientY - rect.top) * scaleY;
        }
        return { x, y };
    }
    function getGridIndexFromPos(x, y) {
        const gridX = x - GRID_OFFSET_X; const gridY = y - GRID_OFFSET_Y;
        for (let i = 0; i < GRID_SIZE; i++) {
            const col = i % GRID_COLS; const row = Math.floor(i / GRID_COLS);
            const cellX = col * (CELL_SIZE + GAP); const cellY = row * (CELL_SIZE + GAP);
            if (gridX >= cellX && gridX <= cellX + CELL_SIZE && gridY >= cellY && gridY <= cellY + CELL_SIZE) {
                return i;
            }
        }
        return -1;
    }
    function getGridCoords(index) {
        const row = Math.floor(index / GRID_COLS); const col = index % GRID_COLS;
        const x = GRID_OFFSET_X + col * (CELL_SIZE + GAP);
        const y = GRID_OFFSET_Y + row * (CELL_SIZE + GAP);
        return { x, y };
    }
    function handleDragStart(e) {
        e.preventDefault();
        const { x, y } = getMousePos(e);
        const index = getGridIndexFromPos(x, y);
        if (index !== -1 && diceGrid[index]) {
            dragState.isDragging = true;
            dragState.startIndex = index;
            dragState.die = { ...diceGrid[index] };
            dragState.x = x; dragState.y = y;
            diceGrid[index] = null;
        }
    }
    function handleDragMove(e) {
        if (!dragState.isDragging) return;
        e.preventDefault();
        const { x, y } = getMousePos(e);
        dragState.x = x; dragState.y = y;
    }
    function handleDragEnd(e) {
        if (!dragState.isDragging) return;
        e.preventDefault();
        const { x, y } = getMousePos(e);
        const dropIndex = getGridIndexFromPos(x, y);
        const dragDice = dragState.die;
        const startIndex = dragState.startIndex;
        if (dropIndex === -1) {
            diceGrid[startIndex] = dragDice;
        } else {
            const dropDice = diceGrid[dropIndex];
            if (dropDice === null) {
                diceGrid[dropIndex] = dragDice;
            } else {
                if (dragDice.type === dropDice.type && dragDice.pips === dropDice.pips) {
                    diceGrid[dropIndex].pips += 1;
                    diceGrid[dropIndex].cooldown = 0;
                    const mergeBonusChance = ((rogueliteUpgrades && rogueliteUpgrades.mergeBonus ? rogueliteUpgrades.mergeBonus.level : 1) - 1) * 0.01;
                    if (Math.random() < mergeBonusChance) {
                        diceGrid[dropIndex].pips += 1;
                        const {x: cellX, y: cellY} = getGridCoords(dropIndex);
                        createDamageNumber(cellX + CELL_SIZE / 2, cellY + CELL_SIZE / 2, "BONUS!", "#f1c40f");
                    }
                    if (diceGrid[dropIndex].pips >= 7) {
                        checkAchievements('pip7');
                    }
                } else {
                    diceGrid[startIndex] = dropDice;
                    diceGrid[dropIndex] = dragDice;
                }
            }
        }
        dragState.isDragging = false;
        dragState.die = null;
        dragState.startIndex = -1;
    }
    canvas.addEventListener('mousedown', handleDragStart);
    canvas.addEventListener('mousemove', handleDragMove);
    canvas.addEventListener('mouseup', handleDragEnd);
    canvas.addEventListener('mouseleave', handleDragEnd);
    canvas.addEventListener('touchstart', handleDragStart, { passive: false });
    canvas.addEventListener('touchmove', handleDragMove, { passive: false });
    canvas.addEventListener('touchend', handleDragEnd, { passive: false });


    // --- 13. [ìˆ˜ì •] ê²Œì„ ì‹œì‘/ì €ì¥/ë¡œë“œ/ì¢…ë£Œ ë¡œì§ ---

    function showModal(modalElement) {
        modalElement.style.display = 'flex';
        document.body.classList.add('modal-open');
    }
    function hideModal(modalElement) {
        modalElement.style.display = 'none';
        document.body.classList.remove('modal-open');
    }

    function initRogueliteUpgrades() {
        return {
            startQP: { level: 1, cost: 100 },
            quizQP: { level: 1, cost: 150 },
            highSpawn: { level: 1, cost: 200 },
            mergeBonus: { level: 1, cost: 250 }
        };
    }
    function initAchievements() {
        return {
            wave5: false, wave10: false, wave20: false, wave30: false, wave50: false, pip7: false
        };
    }
    function updateRogueliteUI() {
        totalPointsDisplayRoguelite.textContent = `ë³´ìœ : ${totalKnowledgePoints} KP`;
        let rgu = rogueliteUpgrades.startQP;
        rogueliteButtons.startQP.desc.textContent = `ì‹œì‘ QPê°€ 20 ì¦ê°€í•©ë‹ˆë‹¤. (í˜„ì¬ +${(rgu.level - 1) * 20})`;
        rogueliteButtons.startQP.cost.textContent = `ë¹„ìš©: ${rgu.cost} KP`;
        rogueliteButtons.startQP.btn.disabled = totalKnowledgePoints < rgu.cost;
        rgu = rogueliteUpgrades.quizQP;
        rogueliteButtons.quizQP.desc.textContent = `í€´ì¦ˆ ë³´ìƒì´ 10% ì¦ê°€í•©ë‹ˆë‹¤. (í˜„ì¬ +${(rgu.level - 1) * 10}%)`;
        rogueliteButtons.quizQP.cost.textContent = `ë¹„ìš©: ${rgu.cost} KP`;
        rogueliteButtons.quizQP.btn.disabled = totalKnowledgePoints < rgu.cost;
        rgu = rogueliteUpgrades.highSpawn;
        rogueliteButtons.highSpawn.desc.textContent = `2ì„± ì†Œí™˜ í™•ë¥ ì´ 1% ì¦ê°€í•©ë‹ˆë‹¤. (í˜„ì¬ ${(rgu.level - 1) * 1}%)`;
        rogueliteButtons.highSpawn.cost.textContent = `ë¹„ìš©: ${rgu.cost} KP`;
        rogueliteButtons.highSpawn.btn.disabled = totalKnowledgePoints < rgu.cost;
        rgu = rogueliteUpgrades.mergeBonus;
        rogueliteButtons.mergeBonus.desc.textContent = `2ë‹¨ í•©ì„± í™•ë¥ ì´ 1% ì¦ê°€í•©ë‹ˆë‹¤. (í˜„ì¬ ${(rgu.level - 1) * 1}%)`;
        rogueliteButtons.mergeBonus.cost.textContent = `ë¹„ìš©: ${rgu.cost} KP`;
        rogueliteButtons.mergeBonus.btn.disabled = totalKnowledgePoints < rgu.cost;
    }
    function buyRogueliteUpgrade(key) {
        const upgrade = rogueliteUpgrades[key];
        if (totalKnowledgePoints >= upgrade.cost) {
            totalKnowledgePoints -= upgrade.cost;
            upgrade.level++;
            upgrade.cost = Math.floor(upgrade.cost * (1.2 + (upgrade.level * 0.1))); // ë¹„ìš© ì¦ê°€
            saveGameData();
            updateRogueliteUI();
        }
    }
    function updateAchievementsUI() {
        Object.keys(achievements).forEach(key => {
            const el = document.getElementById(`ach-${key}`);
            if (el) {
                if (achievements[key]) {
                    el.classList.add('unlocked');
                    el.classList.remove('locked');
                } else {
                    el.classList.add('locked');
                    el.classList.remove('unlocked');
                }
            }
        });
    }
    function checkAchievements(type = 'wave') {
        let changed = false;
        if (type === 'wave') {
            if (wave >= 5 && !achievements.wave5) { achievements.wave5 = true; changed = true; }
            if (wave >= 10 && !achievements.wave10) { achievements.wave10 = true; changed = true; }
            if (wave >= 20 && !achievements.wave20) { achievements.wave20 = true; changed = true; }
            if (wave >= 30 && !achievements.wave30) { achievements.wave30 = true; changed = true; }
            if (wave >= 50 && !achievements.wave50) { achievements.wave50 = true; changed = true; }
        } else if (type === 'pip7' && !achievements.pip7) {
            achievements.pip7 = true; changed = true;
        }
        if (changed) { saveGameData(); }
    }
    function saveGameData() {
        try {
            localStorage.setItem(KP_KEY, totalKnowledgePoints.toString());
            localStorage.setItem(ROGUELITE_KEY, JSON.stringify(rogueliteUpgrades));
            localStorage.setItem(ACHIEVEMENTS_KEY, JSON.stringify(achievements));
        } catch (e) { console.error("Failed to save game data:", e); }
    }
    function loadGameData() {
        try {
            totalKnowledgePoints = parseInt(localStorage.getItem(KP_KEY)) || 0;
            rogueliteUpgrades = JSON.parse(localStorage.getItem(ROGUELITE_KEY)) || initRogueliteUpgrades();
            achievements = JSON.parse(localStorage.getItem(ACHIEVEMENTS_KEY)) || initAchievements();
        } catch (e) {
            console.error("Failed to load game data, resetting:", e);
            totalKnowledgePoints = 0;
            rogueliteUpgrades = initRogueliteUpgrades();
            achievements = initAchievements();
        }
        if (!rogueliteUpgrades.startQP) rogueliteUpgrades.startQP = initRogueliteUpgrades().startQP;
        if (!rogueliteUpgrades.quizQP) rogueliteUpgrades.quizQP = initRogueliteUpgrades().quizQP;
        if (!rogueliteUpgrades.highSpawn) rogueliteUpgrades.highSpawn = initRogueliteUpgrades().highSpawn;
        if (!rogueliteUpgrades.mergeBonus) rogueliteUpgrades.mergeBonus = initRogueliteUpgrades().mergeBonus;
    }

    function stopGame() {
        gameRunning = false;
        cancelAnimationFrame(animationFrameId);
        clearInterval(spawnInterval);
        clearInterval(quizTimerInterval);
    }

    function gameOver() {
        stopGame();
        const pointsEarned = wave * 10;
        totalKnowledgePoints += pointsEarned;
        saveGameData();

        finalWaveDisplay.textContent = wave;
        pointsEarnedDisplay.textContent = `${pointsEarned} KP`;
        totalPointsDisplay.textContent = `${totalKnowledgePoints} KP`;
        showModal(gameOverModal);
    }

    function gameVictory() {
        stopGame();
        checkAchievements('wave50');
        const pointsEarned = (wave * 10) + 500; // 50ì›¨ì´ë¸Œ í´ë¦¬ì–´ ë³´ë„ˆìŠ¤
        totalKnowledgePoints += pointsEarned;
        saveGameData();

        victoryPointsEarnedDisplay.textContent = `${pointsEarned} KP`;
        victoryTotalPointsDisplay.textContent = `${totalKnowledgePoints} KP`;
        showModal(gameVictoryModal);
    }

    function resetGame() {
        if (!rogueliteUpgrades || !rogueliteUpgrades.startQP) { rogueliteUpgrades = initRogueliteUpgrades(); }
        stopGame();

        resources = 100 + ((rogueliteUpgrades && rogueliteUpgrades.startQP ? rogueliteUpgrades.startQP.level : 1) - 1) * 20;
        summonCost = 50;
        playerHP = MAX_HP;
        wave = 0;
        enemiesToSpawn = 0;

        diceGrid = new Array(GRID_SIZE).fill(null);
        enemies = [];
        projectiles = [];
        damageNumbers = [];

        initInGameUpgrades();

        updateUI();

        gameContainer.classList.add('active');
        quizContainer.classList.add('active');
        gameContainer.style.display = 'flex';
        quizContainer.style.display = 'flex';

        gameRunning = true;
        loadQuiz();
        startNextWave();
        animationFrameId = requestAnimationFrame(gameLoop);
    }

    function initGame() {
        if (!rogueliteUpgrades || !rogueliteUpgrades.startQP) { rogueliteUpgrades = initRogueliteUpgrades(); }
        hideModal(startScreenModal);
        resetGame();
    }

    function returnToTitle() {
        hideModal(gameOverModal);
        hideModal(gameVictoryModal);

        gameContainer.style.display = 'none';
        quizContainer.style.display = 'none';
        gameContainer.classList.remove('active');
        quizContainer.classList.remove('active');
        showModal(startScreenModal);
    }

    // --- 14. ì´ˆê¸°í™” ë° ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ---

    document.addEventListener('DOMContentLoaded', () => {
        function fitTextToBox(el, minPx, maxPx) {
            // Shrink font until fits within parent height and width (2 lines clamp)
            let size = maxPx;
            el.style.fontSize = size + 'px';
            const parent = el.parentElement;
            let guard = 0;
            while (guard++ < 20) {
                const overflows = el.scrollHeight > parent.clientHeight - 6 || el.scrollWidth > parent.clientWidth - 6;
                if (!overflows || size <= minPx) break;
                size -= 1;
                el.style.fontSize = size + 'px';
            }
        }
        function autosizeOptionLabels() {
            document.querySelectorAll('.option-btn .option-label').forEach(el => {
                const style = getComputedStyle(document.documentElement);
                const minPx = parseFloat(style.getPropertyValue('--opt-font-min')) || 11;
                const maxPx = parseFloat(style.getPropertyValue('--opt-font-max')) || 16;
                fitTextToBox(el, minPx, maxPx);
            });
        }

        function fitTextWithin(el, minPx, maxPx) {
            const parent = el.parentElement || el;
            let size = maxPx;
            el.style.fontSize = size + 'px';
            // Try shrink until it fits (safeguard iterations)
            let guard = 0;
            while (guard++ < 16 && size > minPx && el.scrollWidth > parent.clientWidth - 4) {
                size -= 1;
                el.style.fontSize = size + 'px';
            }
        }
        function autosizeUpgradeTexts() {
            const infos = document.querySelectorAll('#upgrade-panel .upgrade-info, #upgrade-panel .upgrade-cost');
            infos.forEach(el => fitTextWithin(el, 10, 14));
        }

        loadGameData();

        // ì‹œì‘ í™”ë©´
        showModal(startScreenModal);
        document.getElementById('start-game-btn').onclick = initGame;
        document.getElementById('show-roguelite-btn').onclick = () => {
            updateRogueliteUI();
            showModal(rogueliteModal);
        };
        document.getElementById('show-achievements-btn').onclick = () => {
            updateAchievementsUI();
            showModal(achievementsModal);
        };

        restartBtn.onclick = returnToTitle;
        victoryRestartBtn.onclick = returnToTitle;

        // ëª¨ë‹¬ ë‹«ê¸° ë²„íŠ¼
        document.getElementById('close-roguelite-btn').onclick = () => {
            hideModal(rogueliteModal);
        };
        document.getElementById('close-achievements-btn').onclick = () => {
            hideModal(achievementsModal);
        };

        // ì˜êµ¬ ê°•í™” êµ¬ë§¤ ë²„íŠ¼
        rogueliteButtons.startQP.btn.onclick = () => buyRogueliteUpgrade('startQP');
        rogueliteButtons.quizQP.btn.onclick = () => buyRogueliteUpgrade('quizQP');
        rogueliteButtons.highSpawn.btn.onclick = () => buyRogueliteUpgrade('highSpawn');
        rogueliteButtons.mergeBonus.btn.onclick = () => buyRogueliteUpgrade('mergeBonus');
    });


    function ensureContainersVisible() {
        // Recover the correct screen on rotation
        const modals = Array.from(document.querySelectorAll('.modal-overlay'));
        const anyModalShown = modals.some(m => m.style.display !== 'none' && m.offsetParent !== null);
        if (gameRunning && !anyModalShown) {
            gameContainer.classList.add('active');
            quizContainer.classList.add('active');
            gameContainer.style.display = 'flex';
            quizContainer.style.display = 'flex';
        }
        // viewport fix variable
        document.documentElement.style.setProperty('--vh', (window.innerHeight * 0.01) + 'px');
        // Nudge canvas redraw to avoid blank frames
        try {
            clearCanvas(); drawPath(); drawGrid(); drawDice(); drawEnemies(); drawProjectiles(); drawDamageNumbers();
        } catch (_) {}
        autosizeUpgradeTexts();
    }
    window.addEventListener('orientationchange', ensureContainersVisible);
    window.addEventListener('resize', ensureContainersVisible);
    window.addEventListener('resize', autosizeOptionLabels);
    window.addEventListener('orientationchange', autosizeOptionLabels);

</script>

<!-- === PATCH: Title buttons & rotation white-screen hardener === -->
<script>
    (function() {
        function byId(id){ return document.getElementById(id); }
        function safeBind(el, handler){
            if(!el) return;
            el.onclick = null;
            el.addEventListener('click', function(e){ e.preventDefault(); handler(); });
            el.addEventListener('touchend', function(e){ e.preventDefault(); handler(); }, { passive: false });
        }
        function ensureVisible(){
            try {
                var game = byId('game-container');
                var quiz = byId('quiz-container');
                if (!game || !quiz) return;
                // force reflow for Safari viewport bugs
                document.documentElement.style.minHeight = '100dvh';
                void document.body.offsetHeight;
                if (game.classList.contains('active')) { game.style.display = 'flex'; }
                if (quiz.classList.contains('active')) { quiz.style.display = 'flex'; }
            } catch(e){ /* no-op */ }
        }

        function wireStartButtons(){
            var startBtn = byId('start-game-btn');
            var rogueliteBtn = byId('show-roguelite-btn');
            var achieveBtn = byId('show-achievements-btn');

            // Map to global if present
            var g = window;
            var start = g.initGame || (typeof initGame === 'function' ? initGame : null);
            var showRogue = (g.updateRogueliteUI && g.showModal && byId('roguelite-upgrade-modal'))
                ? function(){ g.updateRogueliteUI(); g.showModal(byId('roguelite-upgrade-modal')); } : null;
            var showAch = (g.refreshAchievementsUI && g.showModal && byId('achievements-modal'))
                ? function(){ g.refreshAchievementsUI(); g.showModal(byId('achievements-modal')); } : null;

            if (start) safeBind(startBtn, start);
            if (showRogue) safeBind(rogueliteBtn, showRogue);
            if (showAch) safeBind(achieveBtn, showAch);
        }

        // Run ASAP after DOM is interactive
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', function(){ wireStartButtons(); ensureVisible(); });
        } else {
            wireStartButtons(); ensureVisible();
        }

        // Fix white blank when rotating or returning to tab
        window.addEventListener('orientationchange', function(){ setTimeout(ensureVisible, 50); });
        window.addEventListener('resize', function(){ setTimeout(ensureVisible, 50); });
        window.addEventListener('pageshow', function(){ setTimeout(ensureVisible, 50); });
    })();
</script>
<script>
    /* === HOTFIX v3.2b: window.* ì°¸ì¡°ë¡œ ê¹¨ì§„ ê°•í™” ë²„íŠ¼ ë³µêµ¬ + ë‚œì´ë„/ë¹„ìš© ì™„í™” ìœ ì§€ === */
    (function () {
        const COST_FACTOR = 0.5;   // ì˜êµ¬ê°•í™” ë°˜ê°’
        const HP_RAMP    = 1.04;   // 6ì›¨ì´ë¸Œ ì´í›„ HP ì™„ë§Œ ìƒìŠ¹
        const SPAWN_RAMP = 1.04;   // 6ì›¨ì´ë¸Œ ì´í›„ ìŠ¤í° ìˆ˜ ì™„ë§Œ ìƒìŠ¹
        const SPEED_RAMP = 1.03;   // 6ì›¨ì´ë¸Œ ì´í›„ ìŠ¤í° ì†ë„(ê°„ê²© ê°ì†Œ) ì™„ë§Œ ìƒìŠ¹
        const MIG_KEY    = "quizTowerDefense_migrated_v32a";
        const ROG_KEY    = (typeof ROGUELITE_KEY !== 'undefined' ? ROGUELITE_KEY : 'quizTowerDefense_Roguelite');

        /* 1) 1íšŒ ë§ˆì´ê·¸ë ˆì´ì…˜: ì €ì¥ëœ ì˜êµ¬ê°•í™” ë¹„ìš©ì„ ë°˜ê°’ìœ¼ë¡œ */
        try {
            if (!localStorage.getItem(MIG_KEY)) {
                const raw = localStorage.getItem(ROG_KEY);
                if (raw) {
                    const data = JSON.parse(raw);
                    ['startQP','quizQP','highSpawn','mergeBonus'].forEach(k => {
                        if (data && data[k] && typeof data[k].cost === 'number') {
                            data[k].cost = Math.max(1, Math.round(data[k].cost * COST_FACTOR));
                        }
                    });
                    localStorage.setItem(ROG_KEY, JSON.stringify(data));
                    if (typeof rogueliteUpgrades !== 'undefined' && rogueliteUpgrades) {
                        Object.assign(rogueliteUpgrades, data);
                    }
                }
                localStorage.setItem(MIG_KEY, '1');
            }
        } catch(e) {}

        /* 2) ì˜êµ¬ê°•í™” UI íŒ¨ì¹˜: í‘œê¸°/disabledë¥¼ ë°˜ê°’ ê¸°ì¤€ìœ¼ë¡œ ê°±ì‹  */
        if (typeof updateRogueliteUI === 'function') {
            const __u = updateRogueliteUI;
            updateRogueliteUI = function () {
                __u();
                try {
                    ['startQP','quizQP','highSpawn','mergeBonus'].forEach(key => {
                        const up = rogueliteUpgrades?.[key];
                        const el = rogueliteButtons?.[key];
                        if (!up || !el) return;
                        const eff = Math.max(1, Math.round((up.cost|0) * COST_FACTOR));
                        if (el.cost) el.cost.textContent = `ë¹„ìš©: ${eff} KP`;
                        if (el.btn)  el.btn.disabled = (totalKnowledgePoints < eff);
                    });
                } catch(_) {}
            };
        }

        /* 3) ì˜êµ¬ê°•í™” êµ¬ë§¤ ë¡œì§ íŒ¨ì¹˜: ë°˜ê°’ ì°¨ê° + ì›ë˜ ì„±ì¥ì‹ ìœ ì§€ */
        if (typeof buyRogueliteUpgrade === 'function') {
            buyRogueliteUpgrade = function (key) {
                const up = rogueliteUpgrades?.[key];
                if (!up) return;
                const eff = Math.max(1, Math.round((up.cost|0) * COST_FACTOR));
                if ((totalKnowledgePoints|0) < eff) return;
                totalKnowledgePoints -= eff;
                up.level = (up.level|0) + 1;
                up.cost  = Math.floor(up.cost * (1.2 + (up.level * 0.1))); // ì €ì¥/ì„±ì¥ì€ ì› ê³µì‹
                if (typeof saveGameData === 'function') saveGameData();
                if (typeof updateRogueliteUI === 'function') updateRogueliteUI();
            };
        }

        /* 4) ì¸ê²Œì„ ê°•í™” ì‹œì‘ê°€/ì¦ê°€ ê³ ì •: 10 ì‹œì‘, ì´í›„ +5 (ë°˜ê°’ ë³´ì • ì œê±°) */
        if (typeof initInGameUpgrades === 'function') {
            const __initIG = initInGameUpgrades;
            initInGameUpgrades = function(){
                __initIG();
                try {
                    Object.values(diceUpgrades || {}).forEach(u => {
                        if (u) u.cost = Math.max(10, u.cost); // ì‹œì‘ê°€ë¥¼ 10 ì´ìƒìœ¼ë¡œ ê³ ì •
                    });
                    if (typeof updateUI === 'function') updateUI();
                } catch(_) {}
            };
        }

        /* 5) ë‚œì´ë„ ì™„í™”: HP ë¨í”„(1.5 ê³ ì •ë°°ìˆ˜ â†’ ì™„ë§Œ ë¨í”„) */
        if (typeof Enemy === 'function') {
            const Base = Enemy;
            Enemy = class extends Base {
                constructor(isBoss){
                    super(isBoss);
                    try {
                        if ((typeof wave === 'number') && wave > 6) {
                            const factor = Math.pow(HP_RAMP, Math.max(0, wave - 6)) / 1.5;
                            this.maxHp = Math.max(1, Math.round(this.maxHp * factor));
                            this.hp    = Math.min(this.hp, this.maxHp);
                        }
                    } catch(_) {}
                }
            };
        }

        /* 6) ë‚œì´ë„ ì™„í™”: ìŠ¤í° ìˆ˜/ì†ë„ ë¨í”„ ì™„ë§Œí™” */
        if (typeof startNextWave === 'function') {
            const __start = startNextWave;
            startNextWave = function () {
                __start();
                if ((wave|0) % 5 === 0) return; // ë³´ìŠ¤ ì›¨ì´ë¸Œ ì œì™¸
                try {
                    clearInterval(spawnInterval);
                    const w = wave|0;
                    const chapter = Math.max(0, Math.floor((w - 1) / 10));

                    const baseCount = 10 + (w * 2) + (chapter * 10);
                    const rampCount = (w > 6) ? Math.pow(SPAWN_RAMP, (w - 6)) : 1;
                    enemiesToSpawn = Math.max(0, Math.round(baseCount * rampCount));

                    const baseMs = 1000 - (w * 20) - (chapter * 50);
                    const rampSp = (w > 6) ? Math.pow(SPEED_RAMP, (w - 6)) : 1;
                    const delay  = Math.max(100, Math.round(baseMs / rampSp));

                    spawnInterval = setInterval(function () {
                        if (enemiesToSpawn > 0) {
                            enemies.push(new Enemy(false));
                            enemiesToSpawn--;
                        } else {
                            clearInterval(spawnInterval);
                        }
                    }, delay);
                } catch(_) {}
            };
        }
    })();
</script>

<script>
    /* === QDD QuizPack Loader (network-first, fallback-safe) === */
    (function () {
        const QP_VER = window.QP_VER || "20251112"; // â† ë°°í¬ ì‹œ ë‚ ì§œ/ì»¤ë°‹ í•´ì‹œë¡œ ë°”ê¿”ì£¼ì„¸ìš”
        const QUIZ_PACK_BASE =
            "https://unluckyidiot16.github.io/assets-common/QuizDiceDefense/QuizPack/quizpack.json";
        const QUIZ_PACK_URL = `${QUIZ_PACK_BASE}?v=${encodeURIComponent(QP_VER)}`;
        const QUIZ_CACHE_NAME = `QDD-QuizPack-quizpack-v${QP_VER}`;

        let _ready = null;

        async function loadNetworkFirst(url) {
            // 1) í•­ìƒ ë„¤íŠ¸ì›Œí¬ë¡œ ETag ì¬ê²€ì¦í•´ì„œ ìµœì‹  ì‹œë„
            try {
                const resp = await fetch(url, { cache: "no-cache" });
                if (!resp.ok) throw new Error("fetch failed: " + resp.status);
                // 2) ì„±ê³µ ì‹œ ìºì‹œì— ê°±ì‹  ì €ì¥
                try { const c = await caches.open(QUIZ_CACHE_NAME); await c.put(url, resp.clone()); } catch (_) {}
                return await resp.json();
            } catch (e) {
                // 3) ì˜¤í”„ë¼ì¸/ì‹¤íŒ¨ë©´ ìºì‹œâ†’ì—†ìœ¼ë©´ ì—ëŸ¬
                const c = await caches.open(QUIZ_CACHE_NAME);
                const hit = await c.match(url);
                if (hit) return hit.json();
                throw e;
            }
        }

        async function ensureQuizPack() {
            if (_ready) return _ready;
            _ready = (async () => {
                try {
                    try { const keys = await caches.keys(); await Promise.all(keys.filter(k=>k.startsWith('QDD-QuizPack-quizpack-v') && k!==QUIZ_CACHE_NAME).map(k=>caches.delete(k))); } catch(_){}
                    const remote = await loadNetworkFirst(QUIZ_PACK_URL);
                    if (Array.isArray(remote) && remote.length) {
                        if (typeof quizData !== "undefined" && quizData?.splice) {
                            quizData.splice(0, quizData.length, ...remote); // ì œìë¦¬ êµì²´
                        }
                        console.log("[QDD] QuizPack (latest) loaded:", QUIZ_PACK_URL, `(${quizData.length})`);
                    } else {
                        console.warn("[QDD] Remote pack empty, using built-in fallback.");
                    }
                } catch (e) {
                    console.warn("[QDD] Network failed, using built-in fallback.", e);
                }
            })();
            return _ready;
        }

        document.addEventListener("DOMContentLoaded", () => { try { ensureQuizPack(); } catch(_){} });

        const __initGame__ = window.initGame;
        if (typeof __initGame__ === "function") {
            window.initGame = async function () {
                try { await ensureQuizPack(); } catch (_) {}
                return __initGame__.apply(this, arguments);
            };
        }
    })();
</script>
<script>
    /* === QDD v3.3b (bootstrapped): HP Max Roguelite + Merge Perks & +50% Damage === */
    (function(){
        const FPS = 60;
        const PERK_COOLDOWN = Math.round(6.1*FPS);
        const PERK_COLORS = { multishot:'#ff66aa', bounce:'#66ccff', range:'#66ff66', selfAS:'#ffaa00', auraAS:'#00ccff', auraATK:'#ffcc00' };

        // ì‘ì€ ìœ í‹¸
        const sleep = (ms)=>new Promise(r=>setTimeout(r,ms));
        const g = (k)=> (typeof window[k] !== 'undefined' ? window[k] : undefined);
        const ensureCanvasCtx = () => {
            if (window.ctx && typeof window.ctx.save === 'function') return window.ctx;
            const c = document.querySelector('canvas');
            try { return c ? c.getContext('2d') : null; } catch { return null; }
        };
        function strokeRoundedRect(ctx,x,y,w,h,r){
            if (!ctx) return;
            if (typeof ctx.roundRect === 'function'){
                ctx.beginPath(); ctx.roundRect(x,y,w,h,r); ctx.stroke(); return;
            }
            // í´ë¦¬í•„
            const rr = Math.max(0, Math.min(r, Math.min(w,h)/2));
            ctx.beginPath();
            ctx.moveTo(x+rr, y);
            ctx.lineTo(x+w-rr, y);
            ctx.arcTo(x+w, y, x+w, y+rr, rr);
            ctx.lineTo(x+w, y+h-rr);
            ctx.arcTo(x+w, y+h, x+w-rr, y+h, rr);
            ctx.lineTo(x+rr, y+h);
            ctx.arcTo(x, y+h, x, y+h-rr, rr);
            ctx.lineTo(x, y+rr);
            ctx.arcTo(x, y, x+rr, y, rr);
            ctx.stroke();
        }

        // == í›„í‚¹ ëŒ€ìƒë“¤ì´ ì¤€ë¹„ë  ë•Œê¹Œì§€ ê¸°ë‹¤ë ¸ë‹¤ê°€ í•œ ë²ˆë§Œ íŒ¨ì¹˜ ==
        async function boot(){
            // ìµœëŒ€ 6ì´ˆ(60 * 100ms) ê¸°ë‹¤ë¦¬ë©° ì „ì—­ í›… ëŒ€ìƒë“¤ì„ íƒì§€
            for (let t=0; t<60; t++){
                const okUI  = g('updateUI') && g('resetGame');
                const okDie = g('handleDragEnd') && g('diceGrid') && g('getMousePos') && g('getGridIndexFromPos');
                const okAtk = g('updateDiceAttacks') && g('findTarget') && g('projectiles');
                const okCls = typeof g('Projectile') === 'function';
                const okDraw= typeof g('drawDie') === 'function';
                if (okUI && okDie && okAtk && okCls && okDraw) break;
                await sleep(100);
            }
            try{ applyPatches(); }catch(err){
                console.error('[QDD v3.3b] patch failed:', err);
            }
        }

        function applyPatches(){
            // ==================== [A] ì˜êµ¬ê°•í™”: ìµœëŒ€ HP ì¶”ê°€ ====================
            if (typeof window.initRogueliteUpgrades === 'function'){
                const __init = window.initRogueliteUpgrades;
                window.initRogueliteUpgrades = function(){
                    const u = __init();
                    if (!u.hpMax) u.hpMax = { level:1, cost:180 };
                    return u;
                };
            }
            function ensureRogueKeys(){
                if (!window.rogueliteUpgrades) return;
                if (!window.rogueliteUpgrades.hpMax) window.rogueliteUpgrades.hpMax = { level:1, cost:180 };
            }
            function ensureHpMaxUI(){
                ensureRogueKeys();
                if (!document.getElementById('roguelite-hpmax-btn')) {
                    const grid = document.querySelector('.roguelite-upgrade-grid');
                    if (!grid) return;
                    const item = document.createElement('div');
                    item.className = 'roguelite-upgrade-item';
                    const lv = (window.rogueliteUpgrades?.hpMax?.level||1);
                    const cost = (window.rogueliteUpgrades?.hpMax?.cost||180);
                    item.innerHTML = `
          <h3>ìµœëŒ€ HP ì¦ê°€</h3>
          <p id="roguelite-hpmax-desc">ìµœëŒ€ HPê°€ 5 ì¦ê°€í•©ë‹ˆë‹¤. (í˜„ì¬ +${(lv-1)*5})</p>
          <button id="roguelite-hpmax-btn" class="roguelite-upgrade-btn">ê°•í™”</button>
          <div class="roguelite-cost" id="roguelite-hpmax-cost">ë¹„ìš©: ${cost} KP</div>`;
                    grid.appendChild(item);
                    const btn = document.getElementById('roguelite-hpmax-btn');
                    if (btn) btn.onclick = ()=> { if (typeof window.buyRogueliteUpgrade==='function') window.buyRogueliteUpgrade('hpMax'); };
                }
            }
            if (typeof window.updateRogueliteUI === 'function'){
                const __u = window.updateRogueliteUI;
                window.updateRogueliteUI = function(){
                    __u();
                    try{
                        ensureHpMaxUI();
                        const u = window.rogueliteUpgrades.hpMax;
                        const desc = document.getElementById('roguelite-hpmax-desc');
                        const cost = document.getElementById('roguelite-hpmax-cost');
                        if (desc) desc.textContent = `ìµœëŒ€ HPê°€ 5 ì¦ê°€í•©ë‹ˆë‹¤. (í˜„ì¬ +${(u.level-1)*5})`;
                        const eff = Math.max(1, Math.round(u.cost * 0.5)); // v3.2b ë°˜ê°’ UI ì •í•©
                        if (cost) cost.textContent = `ë¹„ìš©: ${eff} KP`;
                        const btn = document.getElementById('roguelite-hpmax-btn');
                        if (btn) btn.disabled = (window.totalKnowledgePoints ?? 0) < eff;
                    }catch{}
                };
            }
            if (typeof window.resetGame === 'function'){
                const __reset = window.resetGame;
                window.resetGame = function(){
                    ensureRogueKeys();
                    window.playerHPMax = 20 + ((window.rogueliteUpgrades?.hpMax?.level||1)-1)*5;
                    __reset();
                    try{
                        window.playerHP = Math.min(window.playerHPMax, window.playerHP||window.playerHPMax);
                        const maxEl = document.getElementById('player-hp-max');
                        if (maxEl) maxEl.textContent = window.playerHPMax;
                        if (typeof window.updateUI==='function') window.updateUI();
                    }catch{}
                };
            }
            if (typeof window.updateUI === 'function'){
                const __ui = window.updateUI;
                window.updateUI = function(){
                    __ui();
                    try{
                        const maxEl = document.getElementById('player-hp-max');
                        if (maxEl && typeof window.playerHPMax==='number') maxEl.textContent = window.playerHPMax;
                    }catch{}
                };
            }

            // ==================== [B] í•©ì„±: +50% ë°ë¯¸ì§€ & ëœë¤ í¼í¬ ====================
            function ensureDieFields(d){
                if (!d) return d;
                if (typeof d.damageMul!=='number') d.damageMul = 1;
                if (!d.buffs) d.buffs = [];
                if (typeof d.tempSpeedMult!=='number') d.tempSpeedMult = 1;
                if (typeof d.tempDamageMult!=='number') d.tempDamageMult = 1;
                if (typeof d.perkCooldown!=='number') d.perkCooldown = 0;
                return d;
            }
            function grantRandomPerk(d){
                const types = ['multishot','bounce','range','selfAS','auraAS','auraATK'];
                const pick = types[Math.floor(Math.random()*types.length)];
                if (!d.perk) d.perk = { type: pick, level: 1 };
                else if (d.perk.type === pick) d.perk.level++;
                else d.perk = { type: pick, level: 1 };
                d.borderColor = PERK_COLORS[d.perk.type] || '#ffffff';
            }

            if (typeof window.handleDragEnd === 'function'){
                const __drag = window.handleDragEnd; // ë°±ì—…(í•„ìš”ì‹œ ì›ë³¸ í˜¸ì¶œìš©)
                window.handleDragEnd = function(e){
                    // ì›ë³¸ ë¡œì§ì—ì„œ í•„ìš”í•œ ì „ì—­(ê²Œì„ ì½”ë“œ)ì´ ì¤€ë¹„ë˜ì–´ ìˆë‹¤ê³  ê°€ì •
                    if (!window.dragState) return __drag ? __drag(e) : undefined;
                    const { diceGrid, dragState, getMousePos, getGridIndexFromPos } = window;
                    e.preventDefault?.();
                    if (!dragState.isDragging){ return __drag ? __drag(e) : undefined; }

                    const { x, y } = getMousePos(e);
                    const dropIndex = getGridIndexFromPos(x, y);
                    const dragDice = dragState.die;
                    const startIndex = dragState.startIndex;

                    if (dropIndex === -1) {
                        diceGrid[startIndex] = dragDice;
                    } else {
                        const dropDice = diceGrid[dropIndex];
                        if (dropDice === null) {
                            diceGrid[dropIndex] = dragDice;
                        } else {
                            if (dragDice.type === dropDice.type && dragDice.pips === dropDice.pips) {
                                // === í•©ì„± ===
                                ensureDieFields(dropDice);
                                diceGrid[dropIndex].pips += 1;
                                diceGrid[dropIndex].cooldown = 0;

                                // +50% ë°ë¯¸ì§€(ëˆ„ì )
                                dropDice.damageMul = (dropDice.damageMul||1) * 1.5;

                                // ì˜êµ¬ê°•í™” ë³´ë„ˆìŠ¤(ìˆìœ¼ë©´)
                                try {
                                    const mergeBonusChance = ((window.rogueliteUpgrades?.mergeBonus?.level || 1) - 1) * 0.01;
                                    if (Math.random() < mergeBonusChance) {
                                        diceGrid[dropIndex].pips += 1;
                                        try {
                                            const c = window.getGridCoords(dropIndex);
                                            window.createDamageNumber?.(c.x + 35, c.y + 35, "BONUS!", "#f1c40f");
                                        } catch {}
                                    }
                                } catch {}

                                // í¼í¬ í™•ë¥  = ëˆˆê¸ˆ * 15% (ìµœëŒ€ 100%)
                                const pips = diceGrid[dropIndex].pips|0;
                                if (Math.random() < Math.min(1, pips*0.15)) {
                                    grantRandomPerk(dropDice);
                                }

                                if (diceGrid[dropIndex].pips >= 7) window.checkAchievements?.('pip7');
                            } else {
                                // ìŠ¤ì™‘
                                diceGrid[startIndex] = dropDice;
                                diceGrid[dropIndex] = dragDice;
                            }
                        }
                    }
                    dragState.isDragging = false;
                    dragState.die = null;
                    dragState.startIndex = -1;
                };
            }

            if (typeof window.summonDice === 'function'){
                const __sum = window.summonDice;
                window.summonDice = function(){
                    __sum();
                    try{ window.diceGrid.forEach(ensureDieFields); }catch{}
                };
            }

            // ==================== [C] íˆ¬ì‚¬ì²´ í™•ì¥: ë°ë¯¸ì§€ ë°°ìˆ˜/ì—°ì‡„ ====================
            if (typeof window.Projectile === 'function'){
                const Base = window.Projectile;
                window.Projectile = class extends Base {
                    constructor(x,y,target,die){
                        super(x,y,target,die);
                        try{
                            this.damage = Math.round(this.damage * (die?.damageMul||1) * (die?.tempDamageMult||1));
                            this.bounces = (die?.perk && die.perk.type==='bounce') ? Math.max(0, die.pips|0) : 0;
                            this.bounceLoss = 0.85;
                            this._visited = new Set();
                        }catch{}
                    }
                    move(){
                        if (!this.target || this.target.hp <= 0) return false;
                        const ok = super.move();
                        if (!ok && this.bounces > 0){
                            const n = (function(fromEnemy, radius, visited){
                                let cand=null, min=1e9;
                                window.enemies?.forEach(e=>{
                                    if (visited?.has(e)) return;
                                    if (e===fromEnemy || e.hp<=0) return;
                                    const d=Math.hypot(e.x-fromEnemy.x, e.y-fromEnemy.y);
                                    if (d<radius && d<min){min=d;cand=e;}
                                });
                                return cand;
                            })(this.target, 140, this._visited);
                            if (n){
                                this._visited.add(this.target);
                                this.target = n;
                                this.bounces--;
                                this.damage = Math.max(1, Math.round(this.damage * this.bounceLoss));
                                return true;
                            }
                        }
                        return ok;
                    }
                };
            }

            // ==================== [D] ê·¸ë¦¬ê¸° í›…: í¼í¬ í…Œë‘ë¦¬ ====================
            if (typeof window.drawDie === 'function'){
                const __drawDie = window.drawDie;
                window.drawDie = function(x,y,die){
                    __drawDie(x,y,die);
                    try{
                        ensureDieFields(die);
                        if (die && die.perk){
                            const ctx = ensureCanvasCtx();
                            if (!ctx) return;
                            ctx.save();
                            ctx.lineWidth = 4;
                            ctx.strokeStyle = die.borderColor || '#ffffff';
                            strokeRoundedRect(ctx, x, y, 70, 70, 10);
                            ctx.restore();
                        }
                    }catch{}
                };
            }

            // ==================== [E] ê³µê²© ë£¨í”„: ë©€í‹°ìƒ·/ì‚¬ê±°ë¦¬/ë²„í”„/ì˜¤ë¼ ====================
            function neighborsWithin(centerIndex, radiusPx){
                const out=[];
                const c0 = window.getGridCoords(centerIndex);
                const cx0 = c0.x+35, cy0=c0.y+35;
                window.diceGrid?.forEach((d,idx)=>{
                    if (!d) return;
                    const c=window.getGridCoords(idx); const cx=c.x+35, cy=c.y+35;
                    if (Math.hypot(cx0-cx, cy0-cy)<=radiusPx) out.push({die:d, idx});
                });
                return out;
            }
            if (typeof window.updateDiceAttacks === 'function'){
                window.updateDiceAttacks = function(){
                    const diceGrid = window.diceGrid||[];
                    for (let i=0;i<diceGrid.length;i++){
                        const die = diceGrid[i];
                        if (!die) continue;
                        ensureDieFields(die);

                        // 1) ë²„í”„ í‹±
                        die.tempSpeedMult = 1; die.tempDamageMult = 1;
                        for (let b=die.buffs.length-1;b>=0;b--){
                            const bf = die.buffs[b]; bf.t--;
                            if (bf.type==='as')  die.tempSpeedMult  *= (1+bf.v);
                            if (bf.type==='atk') die.tempDamageMult *= (1+bf.v);
                            if (bf.t<=0) die.buffs.splice(b,1);
                        }

                        // 2) ì£¼ê¸°ì  í¼í¬(ìê¸°/ì˜¤ë¼)
                        if (die.perk && (die.perk.type==='selfAS' || die.perk.type==='auraAS' || die.perk.type==='auraATK')) {
                            die.perkCooldown--;
                            if (die.perkCooldown<=0){
                                const dur = (die.pips|0) * FPS;      // pipsì´ˆ
                                const val = (die.pips|0) * 0.10;     // +pips*10%
                                if (die.perk.type==='selfAS'){
                                    die.buffs.push({type:'as', v:val, t:dur});
                                } else if (die.perk.type==='auraAS'){
                                    neighborsWithin(i,130).forEach(o=>{ if (o.die!==die){ ensureDieFields(o.die); o.die.buffs.push({type:'as', v:val, t:dur}); }});
                                } else if (die.perk.type==='auraATK'){
                                    neighborsWithin(i,130).forEach(o=>{ if (o.die!==die){ ensureDieFields(o.die); o.die.buffs.push({type:'atk', v:val, t:dur}); }});
                                }
                                die.perkCooldown = PERK_COOLDOWN;
                            }
                        }

                        // 3) ê³µê²© ì¿¨/ì‚¬ê±°ë¦¬/ë©€í‹°ìƒ·
                        if (die.cooldown > 0) { die.cooldown--; continue; }
                        const { x, y } = window.getGridCoords(i);
                        const cx = x+35, cy = y+35;

                        let range = 100 + (die.pips|0)*15;
                        if (die.perk && die.perk.type==='range') range += (die.pips|0)*20;

                        const main = window.findTarget(cx, cy, range);
                        if (!main) continue;

                        const shots = (die.perk && die.perk.type==='multishot') ? Math.max(1, (die.pips|0)) : 1;

                        const targets = [main];
                        if (shots>1) {
                            const cand=[];
                            window.enemies?.forEach(e=>{
                                if (e===main) return;
                                const d = Math.hypot(e.x-cx, e.y-cy);
                                if (d<range) cand.push({e,d});
                            });
                            cand.sort((a,b)=>a.d-b.d);
                            for (let k=0;k<shots-1 && k<cand.length;k++) targets.push(cand[k].e);
                            while (targets.length<shots) targets.push(main);
                        }
                        targets.forEach(t=>window.projectiles.push(new window.Projectile(cx, cy, t, die)));

                        const up = window.diceUpgrades?.[die.type] || {level:1};
                        const baseCd = Math.max(10, 60 - (die.pips|0)*5);
                        const levelScale = Math.pow(0.95, (up.level-1));
                        const speedScale = 1 / Math.max(0.1, die.tempSpeedMult);
                        die.cooldown = Math.max(6, Math.round(baseCd * levelScale * speedScale));
                    }
                };
            }

            console.log('[QDD v3.3b] patches applied');
        }

        if (document.readyState === 'complete') boot();
        else window.addEventListener('load', boot);
    })();
</script>

</body>
</html>