<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ì†”ë¦¬í…Œì–´ í•˜ë²„</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Noto Sans KR', sans-serif;
            touch-action: manipulation; /* Disable double-tap zoom on mobile */
        }
        .card {
            transition: transform 0.2s ease-out, box-shadow 0.2s ease-out;
            position: relative; /* For positioning the discard button */
        }
        .card:hover:not(.tutorial-locked) {
            transform: translateY(-8px) scale(1.03);
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
        /* Discard button style */
        .discard-btn {
            position: absolute;
            top: -5px;
            right: -5px;
            width: 24px;
            height: 24px;
            background-color: #ef4444;
            color: white;
            border-radius: 9999px;
            border: 2px solid white;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            opacity: 0.8;
            transition: opacity 0.2s, transform 0.2s;
            z-index: 10;
        }
        .discard-btn:hover {
            opacity: 1;
            transform: scale(1.1);
        }
        .mandatory-card {
            border-color: #ef4444;
            box-shadow: 0 0 15px #ef4444;
        }
        .slot.highlight {
            outline: 2px solid #3b82f6;
            box-shadow: 0 0 15px #3b82f6;
        }
        .animated-coin {
            position: absolute;
            font-size: 1.5rem;
            animation: float-up 1.5s ease-out forwards;
        }
        @keyframes float-up {
            0% { transform: translateY(0) scale(1); opacity: 1; }
            100% { transform: translateY(-80px) scale(1.5); opacity: 0; }
        }
        .modal-backdrop {
            background-color: rgba(0,0,0,0.75);
        }
        .tutorial-overlay {
            position: absolute;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 1rem 1.5rem;
            border-radius: 0.5rem;
            border: 2px solid white;
            z-index: 50;
            max-width: 300px;
            text-align: center;
        }
        .tutorial-locked {
            opacity: 0.5;
            pointer-events: none;
            transition: opacity 0.3s ease-in-out;
        }
        .rarity-common { background: linear-gradient(135deg, #a3a3a3, #e5e5e5); color: #171717;}
        .rarity-uncommon { background: linear-gradient(135deg, #22c55e, #86efac); color: #14532d;}
        .rarity-rare { background: linear-gradient(135deg, #3b82f6, #93c5fd); color: #1e3a8a;}
        .rarity-epic { background: linear-gradient(135deg, #a855f7, #d8b4fe); color: #581c87;}
    </style>
</head>
<body class="bg-gray-100 text-gray-800 flex flex-col items-center justify-center min-h-screen p-2 sm:p-4">

<div id="game-container" class="w-full max-w-7xl mx-auto hidden">
    <!-- ìƒë‹¨ HUD -->
    <div id="hud" class="grid grid-cols-2 sm:grid-cols-4 gap-2 sm:gap-4 mb-4 text-center">
        <div class="bg-white p-3 rounded-lg shadow"><div class="text-sm font-bold text-gray-500">í„´</div><div id="turn-counter" class="text-2xl font-bold">1 / 20</div></div>
        <div class="bg-white p-3 rounded-lg shadow"><div class="text-sm font-bold text-gray-500">ë‚¨ì€ ìƒí™˜ê¸ˆ</div><div id="debt-counter" class="text-2xl font-bold text-red-600">35</div></div>
        <div class="bg-white p-3 rounded-lg shadow"><div class="text-sm font-bold text-gray-500">ë³´ìœ  ì½”ì¸</div><div id="coin-counter" class="text-2xl font-bold text-yellow-600">2</div></div>
        <div class="bg-white p-3 rounded-lg shadow"><div class="text-sm font-bold text-gray-500">í† ì§€</div><div id="land-counter" class="text-2xl font-bold">3 / 6</div></div>
    </div>
    <div id="milestone-alert" class="hidden text-center my-2 p-2 bg-red-100 border-l-4 border-red-500 text-red-700 rounded-md"></div>
    <!-- ê²Œì„ ë³´ë“œ -->
    <div id="board" class="grid grid-cols-3 lg:grid-cols-6 gap-4 mb-4 min-h-[180px]"></div>
    <!-- í”Œë ˆì´ì–´ ì†íŒ¨ -->
    <div id="hand" class="flex flex-wrap items-center justify-center gap-4 p-4 bg-gray-200 rounded-lg shadow-inner min-h-[170px]"></div>
    <!-- í–‰ë™ ë²„íŠ¼ -->
    <div id="actions" class="flex flex-wrap items-center justify-center gap-4 mt-4">
        <button id="buy-land-btn" class="px-6 py-3 bg-green-500 text-white font-bold rounded-lg shadow-md hover:bg-green-600 transition-colors disabled:bg-gray-400 disabled:cursor-not-allowed">í† ì§€ êµ¬ë§¤ (2ì›)</button>
        <button id="shop-btn" class="px-6 py-3 bg-blue-500 text-white font-bold rounded-lg shadow-md hover:bg-blue-600 transition-colors">ìƒì </button>
        <button id="end-turn-btn" class="px-6 py-3 bg-red-500 text-white font-bold rounded-lg shadow-md hover:bg-red-600 transition-colors">í„´ ì¢…ë£Œ</button>
    </div>
</div>

<!-- ê²Œì„ ì‹œì‘ í™”ë©´ -->
<div id="start-menu" class="text-center p-8 bg-white rounded-lg shadow-xl">
    <h1 class="text-4xl font-bold mb-2">ì†”ë¦¬í…Œì–´ í•˜ë²„</h1>
    <p class="text-gray-600 mb-8">í• ì•„ë²„ì§€ì˜ ë¹šì„ ê°šê³  í† ì§€ë¥¼ ì§€ì¼œë‚´ì„¸ìš”!</p>
    <div class="space-y-4">
        <button data-mode="tutorial" class="start-btn w-full px-6 py-3 bg-green-500 text-white font-bold rounded-lg shadow-md hover:bg-green-600 transition-transform hover:scale-105">íŠœí† ë¦¬ì–¼ (ì¶”ì²œ)</button>
        <button data-mode="normal" class="start-btn w-full px-6 py-3 bg-blue-500 text-white font-bold rounded-lg shadow-md hover:bg-blue-600 transition-transform hover:scale-105">ê¸°ë³¸ ëª¨ë“œ (20í„´, 35ì›)</button>
        <button data-mode="hard" class="start-btn w-full px-6 py-3 bg-red-500 text-white font-bold rounded-lg shadow-md hover:bg-red-600 transition-transform hover:scale-105">í•˜ë“œ ëª¨ë“œ (22í„´, 45ì› + ì¤‘ê°„ì´ì)</button>
    </div>
</div>

<!-- ëª¨ë‹¬ (ìƒì , ê²Œì„ ì˜¤ë²„ ë“±) -->
<div id="modal" class="hidden fixed inset-0 z-40 flex items-center justify-center modal-backdrop">
    <div id="modal-content" class="bg-white rounded-lg shadow-2xl p-6 w-11/12 max-w-md relative"></div>
</div>

<!-- íŠœí† ë¦¬ì–¼ ì˜¤ë²„ë ˆì´ -->
<div id="tutorial-container"></div>

<script>
    const gameData = {
        "config": {
            "startingCoins": 2, "startingSlots": 3, "maxSlots": 6, "handMax": 5, "stackMax": 8, "landBaseCost": 2, "landCostPerStage": 1,
            "unlockCosts": { "lightIndustry": 12, "heavyIndustry": 20 },
            "debtModes": {
                "normal": { "turnLimit": 20, "targetCoins": 35, "milestones": [] },
                "hard": { "turnLimit": 22, "targetCoins": 45, "milestones": [{ "turn": 8, "due": 4 }, { "turn": 16, "due": 5 }] }
            }
        },
        "cards": [
            { "id":"crop_potato","name":"ê°ì","tier":"T1","sector":"agri_basic","rarity":"common","copies":18, "sellTable":[ {"need":2,"coins":1}, {"need":4,"coins":3}, {"need":6,"coins":5}, {"need":8,"coins":8} ] },
            { "id":"crop_corn","name":"ì˜¥ìˆ˜ìˆ˜","tier":"T1","sector":"agri_basic","rarity":"common","copies":16, "sellTable":[ {"need":2,"coins":1}, {"need":4,"coins":3}, {"need":6,"coins":5}, {"need":8,"coins":8} ] },
            { "id":"crop_wheat","name":"ë°€","tier":"T1","sector":"agri_basic","rarity":"uncommon","copies":12, "sellTable":[ {"need":2,"coins":2}, {"need":3,"coins":4}, {"need":5,"coins":7} ] },
            { "id":"crop_rice","name":"ìŒ€","tier":"T1","sector":"agri_basic","rarity":"uncommon","copies":12, "sellTable":[ {"need":2,"coins":2}, {"need":3,"coins":4}, {"need":5,"coins":7} ] },
            { "id":"crop_coffee","name":"ì»¤í”¼ì²´ë¦¬","tier":"T1","sector":"agri_basic","rarity":"rare","copies":8, "sellTable":[ {"need":1,"coins":2}, {"need":2,"coins":5}, {"need":3,"coins":9}, {"need":4,"coins":14} ] },
            { "id":"proc_cheese","name":"ì¹˜ì¦ˆ","tier":"T1","sector":"agri_processed","rarity":"uncommon","copies":10, "sellTable":[ {"need":1,"coins":2}, {"need":2,"coins":4}, {"need":3,"coins":7}, {"need":4,"coins":11} ] },
            { "id":"proc_jam","name":"ì¼","tier":"T1","sector":"agri_processed","rarity":"uncommon","copies":10, "sellTable":[ {"need":1,"coins":2}, {"need":2,"coins":4}, {"need":3,"coins":7}, {"need":4,"coins":11} ] },
            { "id":"proc_oil","name":"ì˜¬ë¦¬ë¸Œìœ ","tier":"T1","sector":"agri_processed","rarity":"rare","copies":8, "sellTable":[ {"need":1,"coins":3}, {"need":2,"coins":6}, {"need":3,"coins":10}, {"need":4,"coins":15} ] },
            { "id":"light_textile","name":"ì§ë¬¼","tier":"T2","sector":"light_industry","rarity":"uncommon","copies":9, "sellTable":[ {"need":1,"coins":3}, {"need":2,"coins":7}, {"need":3,"coins":12} ] },
            { "id":"light_paper","name":"ì¢…ì´","tier":"T2","sector":"light_industry","rarity":"uncommon","copies":9, "sellTable":[ {"need":1,"coins":3}, {"need":2,"coins":7}, {"need":3,"coins":12} ] },
            { "id":"light_glass","name":"ìœ ë¦¬ë³‘","tier":"T2","sector":"light_industry","rarity":"rare","copies":7, "sellTable":[ {"need":1,"coins":4}, {"need":2,"coins":9}, {"need":3,"coins":15} ] },
            { "id":"heavy_steel","name":"ê°•ì² ë¹”","tier":"T2","sector":"heavy_industry","rarity":"rare","copies":6, "sellTable":[ {"need":1,"coins":5}, {"need":2,"coins":11}, {"need":3,"coins":18} ] },
            { "id":"heavy_engine","name":"ì—”ì§„","tier":"T2","sector":"heavy_industry","rarity":"epic","copies":4, "sellTable":[ {"need":1,"coins":6}, {"need":2,"coins":13}, {"need":3,"coins":21} ] }
        ],
        "packs": [
            { "id":"pack_t1_agri","name":"T1 ë†ì—… íŒ©","cost":3, "weights":{"common":0.6,"uncommon":0.3,"rare":0.1}, "pool":["crop_potato","crop_corn","crop_wheat","crop_rice","crop_coffee","proc_cheese","proc_jam","proc_oil"] },
            { "id":"pack_t2_light","name":"T2 ê²½ê³µì—… íŒ©","cost":6, "unlock":"lightIndustry", "weights":{"uncommon":0.65,"rare":0.35}, "pool":["light_textile","light_paper","light_glass"] },
            { "id":"pack_t2_heavy","name":"T2 ì¤‘ê³µì—… íŒ©","cost":8, "unlock":"heavyIndustry", "weights":{"rare":0.5,"epic":0.5}, "pool":["heavy_steel","heavy_engine"] }
        ]
    };

    const tutorialData = {
        turnLimit: 8, targetCoins: 10, milestones: [],
        turnHands: {
            1: ["crop_potato", "crop_potato", "crop_wheat", "proc_jam", "crop_corn"],
            2: ["crop_potato", "crop_potato", "crop_corn", "proc_oil", "crop_coffee"],
            3: ["proc_jam", "crop_wheat", "crop_corn", "crop_potato", "crop_rice"]
        },
        steps: [
            { guide: { text: 'ì†íŒ¨ ë§¨ ì•ì˜ ê°ìë¥¼ ë¹ˆ í† ì§€ì— ì‹¬ì–´ë³´ì„¸ìš”.', element: '#hand .card:first-child' }, waitFor: { trigger: 'plant', card: 'crop_potato' } },
            { guide: { text: 'ì¢‹ì•„ìš”! ê°™ì€ ì¹´ë“œëŠ” ê²¹ì³ì„œ ì‹¬ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë‹¤ìŒ ê°ìë„ ê°™ì€ ê³³ì— ì‹¬ì–´ë³´ì„¸ìš”.', element: '#hand .card:first-child' }, waitFor: { trigger: 'plant', card: 'crop_potato' } },
            { guide: { text: 'í›Œë¥­í•©ë‹ˆë‹¤! ì´ì œ ë‹¤ë¥¸ ì¢…ë¥˜ì¸ ë°€ì„ ìƒˆ í† ì§€ì— ì‹¬ì–´ë´…ì‹œë‹¤.', element: '#hand .card:first-child' }, waitFor: { trigger: 'plant', card: 'crop_wheat' } },
            { guide: { text: 'ê¸°ë³¸ ê·œì¹™ì„ ìµí˜”ë„¤ìš”. ë” ë¹„ì‹¸ê²Œ íŒ”ê¸° ìœ„í•´ ì¹´ë“œë¥¼ ëª¨ì•„ë´…ì‹œë‹¤. í„´ì„ ì¢…ë£Œí•˜ì„¸ìš”.', element: '#end-turn-btn' }, waitFor: { trigger: 'turn_start', turn: 2 } },
            { guide: { text: 'ìƒˆ ì¹´ë“œë¥¼ ë°›ì•˜ë„¤ìš”. ê°ìë¥¼ ë” ìŒ“ì•„ì„œ 4ì¥ì„ ì±„ì›Œë´…ì‹œë‹¤. ì²« ë²ˆì§¸ ê°ìë¥¼ ì‹¬ì–´ì£¼ì„¸ìš”.', element: '#hand .card:first-child' }, waitFor: { trigger: 'plant', card: 'crop_potato' } },
            { guide: { text: 'í•œ ì¥ ë”!', element: '#hand .card:first-child' }, waitFor: { trigger: 'plant', card: 'crop_potato' } },
            { guide: { text: 'ê°ì 4ì¥ì„ ëª¨ì•˜ìŠµë‹ˆë‹¤! ì´ì œ íŒ”ë©´ 3ì›ì„ ë²Œ ìˆ˜ ìˆì–´ìš”. íŒë§¤ ë²„íŠ¼ì„ ëˆŒëŸ¬ë³´ì„¸ìš”.', element: '#board .slot:nth-child(1) .sell-btn' }, waitFor: { trigger: 'sell', card: 'crop_potato' } },
            { guide: { text: 'ì²« ìˆ˜ìµì´ë„¤ìš”! ê·¸ ëˆìœ¼ë¡œ í† ì§€ë¥¼ êµ¬ë§¤í•´ì„œ ë” ë§ì€ ì‘ë¬¼ì„ í‚¤ì›Œë´…ì‹œë‹¤.', element: '#buy-land-btn' }, waitFor: { trigger: 'buy_land' } },
            { guide: { text: 'ì¢‹ì•„ìš”! ì´ì œ í„´ì„ ì¢…ë£Œí•˜ì„¸ìš”.', element: '#end-turn-btn' }, waitFor: { trigger: 'turn_start', turn: 3 } },
            { guide: { text: "'ì¼'ì€ 1ì¥ë§Œ íŒ”ì•„ë„ ë¹„ì‹¸ë‹µë‹ˆë‹¤. ë¹ˆ í† ì§€ì— ì‹¬ê³  ë°”ë¡œ íŒ”ì•„ë´…ì‹œë‹¤.", element: '#hand .card:first-child' }, waitFor: { trigger: 'plant', card: 'proc_jam' } },
            { guide: { text: "ë°”ë¡œ íŒë§¤í•´ì„œ 'ë¹ ë¥¸ í˜„ê¸ˆí™”'ë¥¼ ì²´í—˜í•´ë³´ì„¸ìš”.", element: 'SLOT_WITH_CARD(proc_jam) .sell-btn' }, waitFor: { trigger: 'sell', card: 'proc_jam' } },
            { guide: { text: 'ì´ì œ ììœ ë¡­ê²Œ í”Œë ˆì´í•˜ë©° ë‚¨ì€ ë¹šì„ ê°šì•„ë³´ì„¸ìš”! ë ˆì–´ ì¹´ë“œëŠ” ë” ë¹„ì‹¸ë‹µë‹ˆë‹¤.', element: '#game-container', unlock: true }, waitFor: { trigger: 'debt_cleared' } }
        ]
    };

    const $ = (selector) => document.querySelector(selector);
    const $$ = (selector) => document.querySelectorAll(selector);

    const elements = {
        gameContainer: $('#game-container'), startMenu: $('#start-menu'),
        hud: { turn: $('#turn-counter'), debt: $('#debt-counter'), coins: $('#coin-counter'), land: $('#land-counter'), },
        board: $('#board'), hand: $('#hand'),
        actions: { buyLandBtn: $('#buy-land-btn'), shopBtn: $('#shop-btn'), endTurnBtn: $('#end-turn-btn'), },
        modal: { container: $('#modal'), content: $('#modal-content'), },
        milestoneAlert: $('#milestone-alert'), tutorialContainer: $('#tutorial-container')
    };

    let state = {};

    const Game = {
        init(mode) {
            let config = (mode === 'tutorial') ? { ...gameData.config.debtModes.normal, ...tutorialData } : gameData.config.debtModes[mode];
            Tutorial.unlockAllActions();
            state = {
                mode, turn: 1, turnLimit: config.turnLimit, coins: gameData.config.startingCoins, debt: config.targetCoins,
                debtMilestones: [...config.milestones],
                slots: Array(gameData.config.startingSlots).fill(null).map(() => ({ cardId: null, stack: [] })),
                hand: [], deck: [], discard: [], selectedCardIndex: -1,
                unlocked: { lightIndustry: false, heavyIndustry: false },
                isTutorial: mode === 'tutorial', tutorialStep: 0,
                tutorialGuidedStepsCompleted: false, sellCount: 0, gameOver: false, isProcessing: false,
            };
            if (state.isTutorial) Tutorial.setHandForTurn(1);
            else { this.createDeck(); this.drawHand(gameData.config.handMax); }
            elements.startMenu.classList.add('hidden');
            elements.gameContainer.classList.remove('hidden');
            this.renderAll();
            if (state.isTutorial) setTimeout(() => Tutorial.showGuide(tutorialData.steps[0].guide), 100);
        },
        createDeck() {
            state.deck = [];
            gameData.cards.forEach(cardDef => {
                for (let i = 0; i < cardDef.copies; i++) state.deck.push(cardDef.id);
            });
            this.shuffleDeck();
        },
        shuffleDeck() {
            for (let i = state.deck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [state.deck[i], state.deck[j]] = [state.deck[j], state.deck[i]];
            }
        },
        drawCard() {
            if (state.deck.length === 0) {
                if (state.discard.length === 0) return null;
                state.deck = [...state.discard];
                state.discard = [];
                this.shuffleDeck();
            }
            return state.deck.pop();
        },
        drawHand(count) {
            for (let i = 0; i < count; i++) {
                if (state.hand.length < gameData.config.handMax) {
                    const cardId = this.drawCard();
                    if (cardId) state.hand.push(cardId);
                }
            }
        },
        async endTurn() {
            if (state.isProcessing || state.gameOver) return;
            state.isProcessing = true;
            while (state.hand.length > gameData.config.handMax) {
                const cardToDiscard = state.hand.shift();
                state.discard.push(cardToDiscard);
                this.showToast(`ì†íŒ¨ê°€ ê°€ë“ ì°¨ ${this.getCardDef(cardToDiscard).name} ì¹´ë“œë¥¼ ë²„ë¦½ë‹ˆë‹¤.`, 'error');
                this.renderHand();
                await this.sleep(500);
            }
            state.turn++;
            state.sellCount = 0;
            if (this.checkGameOver()) { state.isProcessing = false; return; }
            if (state.isTutorial && !state.tutorialGuidedStepsCompleted) Tutorial.setHandForTurn(state.turn);
            else {
                if (state.deck.length === 0 && state.discard.length === 0 && (state.isTutorial || state.mode !== 'tutorial')) this.createDeck();
                this.drawHand(gameData.config.handMax - state.hand.length);
            }
            this.renderAll();
            const milestone = state.debtMilestones.find(m => m.turn === state.turn);
            if (milestone) {
                elements.milestoneAlert.textContent = `${state.turn}í„´ ì¤‘ê°„ ì´ì(${milestone.due}ì›) ì²­êµ¬!`;
                elements.milestoneAlert.classList.remove('hidden');
                state.coins -= milestone.due;
                if (state.coins < 0) {
                    this.showToast('ì´ìë¥¼ ë‚´ì§€ ëª»í•´ íŒŒì‚°í–ˆìŠµë‹ˆë‹¤!', 'error');
                    this.triggerGameOver(false);
                } else this.showToast(`${milestone.due}ì›ì˜ ì¤‘ê°„ ì´ìë¥¼ ë‚©ë¶€í–ˆìŠµë‹ˆë‹¤.`, 'warn');
            } else elements.milestoneAlert.classList.add('hidden');
            this.updateUI();
            state.isProcessing = false;
            if (state.isTutorial) Tutorial.checkTrigger('turn_start', { turn: state.turn });
        },
        checkGameOver() {
            if (state.debt <= 0) { this.triggerGameOver(true); return true; }
            if (state.turn > state.turnLimit) { this.triggerGameOver(false); return true; }
            return false;
        },
        triggerGameOver(isWin) {
            state.gameOver = true;
            if (state.isTutorial) Tutorial.unlockAllActions();
            const title = isWin ? "ğŸ‰ ìƒí™˜ ì™„ë£Œ! ğŸ‰" : "ğŸ˜­ íŒŒì‚° ğŸ˜­";
            let message, html;
            if (isWin && state.mode === 'tutorial') {
                message = `ì¶•í•˜í•©ë‹ˆë‹¤! íŠœí† ë¦¬ì–¼ì„ ì„±ê³µì ìœ¼ë¡œ ì™„ë£Œí–ˆìŠµë‹ˆë‹¤!`;
                html = `<h2 class="text-3xl font-bold mb-4 text-center">${title}</h2><p class="text-center mb-6">${message}</p><div class="flex justify-center"><button onclick="location.reload()" class="px-4 py-2 bg-gray-500 text-white rounded hover:bg-gray-600">ë©”ì¸ìœ¼ë¡œ ëŒì•„ê°€ê¸°</button></div>`;
            } else {
                message = isWin ? `ì¶•í•˜í•©ë‹ˆë‹¤! ${state.turn - 1}í„´ ë§Œì— ëª¨ë“  ë¹šì„ ê°šê³  í† ì§€ë¥¼ ì§€ì¼œëƒˆìŠµë‹ˆë‹¤!` : `ì•½ì†ëœ ${state.turnLimit}í„´ ì•ˆì— ë¹šì„ ê°šì§€ ëª»í–ˆìŠµë‹ˆë‹¤. í† ì§€ëŠ” ì´ì œ ë¹šìŸì´ë“¤ì˜ ê²ƒì…ë‹ˆë‹¤...`;
                html = `<h2 class="text-3xl font-bold mb-4 text-center">${title}</h2><p class="text-center mb-6">${message}</p><div class="flex justify-center space-x-4"><button onclick="Game.init('normal')" class="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600">ê¸°ë³¸ ëª¨ë“œ</button><button onclick="Game.init('hard')" class="px-4 py-2 bg-red-500 text-white rounded hover:bg-red-600">í•˜ë“œ ëª¨ë“œ</button><button onclick="location.reload()" class="px-4 py-2 bg-gray-500 text-white rounded hover:bg-gray-600">ë©”ì¸ìœ¼ë¡œ</button></div>`;
            }
            this.showModal(html);
        },
        getCardDef(cardId) { return gameData.cards.find(c => c.id === cardId); },
        selectCard(cardIndex) {
            if (state.isProcessing) return;
            if (cardIndex > 0 && (state.isTutorial && !state.tutorialGuidedStepsCompleted)) {
                this.showToast('ë§¨ ì•ì˜ ì¹´ë“œë¶€í„° ì‹¬ì–´ì•¼ í•©ë‹ˆë‹¤.', 'warn'); return;
            }
            state.selectedCardIndex = cardIndex;
            this.renderAll();
            if (state.isTutorial) {
                const currentStep = tutorialData.steps[state.tutorialStep];
                if (currentStep && currentStep.waitFor.trigger === 'plant') Tutorial.lockActions('#board .slot');
            }
        },
        plantCard(slotIndex) {
            if (state.selectedCardIndex === -1) return;
            const cardId = state.hand[state.selectedCardIndex];
            const slot = state.slots[slotIndex];
            const canPlant = (slot.cardId === null || slot.cardId === cardId) && slot.stack.length < gameData.config.stackMax;
            if (canPlant) {
                const plantedCardId = state.hand[state.selectedCardIndex];
                if (slot.cardId === null) slot.cardId = plantedCardId;
                slot.stack.push(plantedCardId);
                state.hand.splice(state.selectedCardIndex, 1);
                state.selectedCardIndex = -1;
                this.renderAll();
                if (state.isTutorial) Tutorial.checkTrigger('plant', { card: plantedCardId });
            } else this.showToast('ì—¬ê¸°ì— ì‹¬ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.', 'error');
        },
        sellStack(slotIndex) {
            if (state.isProcessing) return;
            if (state.sellCount >= 1 && !(state.isTutorial && !state.tutorialGuidedStepsCompleted)) { this.showToast('íŒë§¤ëŠ” í„´ ë‹¹ í•œ ë²ˆë§Œ ê°€ëŠ¥í•©ë‹ˆë‹¤.', 'warn'); return; }
            const slot = state.slots[slotIndex];
            if (!slot || slot.stack.length === 0) return;
            const cardDef = this.getCardDef(slot.cardId);
            const stackSize = slot.stack.length;
            let payout = 0;
            for (const rule of cardDef.sellTable) { if (stackSize >= rule.need) payout = rule.coins; }
            if (payout > 0) {
                const soldCardId = slot.cardId;
                state.coins += payout;
                state.debt -= payout;
                if (state.debt < 0) state.debt = 0;
                if (!state.discard) state.discard = [];
                state.discard.push(...slot.stack);
                slot.cardId = null;
                slot.stack = [];
                state.sellCount++;
                const slotElement = $$('#board .slot')[slotIndex];
                this.showCoinAnimation(payout, slotElement);
                this.renderAll();
                if (state.isTutorial) Tutorial.checkTrigger('sell', { card: soldCardId });
                if (state.debt <= 0 && !state.gameOver) {
                    if (state.isTutorial) Tutorial.checkTrigger('debt_cleared');
                    this.checkGameOver();
                }
            } else this.showToast('íŒë§¤í•  ìˆ˜ ìˆëŠ” ìˆ˜ëŸ‰ì´ ì•„ë‹™ë‹ˆë‹¤.', 'warn');
        },
        buyLand() {
            const cost = this.getLandCost();
            if (state.coins >= cost && state.slots.length < gameData.config.maxSlots) {
                state.coins -= cost;
                state.slots.push({ cardId: null, stack: [] });
                this.renderAll();
                if (state.isTutorial) Tutorial.checkTrigger('buy_land');
            } else this.showToast('í† ì§€ë¥¼ êµ¬ë§¤í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.', 'error');
        },
        discardCard(cardIndex) {
            if (state.isTutorial && !state.tutorialGuidedStepsCompleted) {
                this.showToast('íŠœí† ë¦¬ì–¼ ì¤‘ì—ëŠ” ì¹´ë“œë¥¼ ë²„ë¦´ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.', 'warn'); return;
            }
            if (cardIndex === 0) {
                this.showToast('ë§¨ ì•ì˜ ì¹´ë“œëŠ” ë²„ë¦´ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ë°˜ë“œì‹œ ì‹¬ì–´ì•¼ í•©ë‹ˆë‹¤.', 'error'); return;
            }
            const [discardedCard] = state.hand.splice(cardIndex, 1);
            state.discard.push(discardedCard);
            this.showToast(`${this.getCardDef(discardedCard).name} ì¹´ë“œë¥¼ ë²„ë ¸ìŠµë‹ˆë‹¤.`, 'info');
            this.renderHand();
        },
        clearSlot(slotIndex) {
            const cost = 1;
            if (state.isTutorial && !state.tutorialGuidedStepsCompleted) {
                this.showToast('íŠœí† ë¦¬ì–¼ ì¤‘ì—ëŠ” í† ì§€ë¥¼ ê°œê°„í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.', 'warn'); return;
            }
            if (state.coins < cost) {
                this.showToast('ë¹„ìš©ì´ ë¶€ì¡±í•˜ì—¬ ê°œê°„í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.', 'error'); return;
            }
            const slot = state.slots[slotIndex];
            if (!slot || slot.stack.length === 0) return;
            state.coins -= cost;
            const cardName = this.getCardDef(slot.cardId).name;
            if (!state.discard) state.discard = [];
            state.discard.push(...slot.stack);
            slot.cardId = null;
            slot.stack = [];
            this.showToast(`${cardName} ì‘ë¬¼ì„ ê°œê°„í–ˆìŠµë‹ˆë‹¤. (-1 ì½”ì¸)`, 'info');
            this.renderAll();
        },
        getLandCost() { return gameData.config.landBaseCost + (state.slots.length - gameData.config.startingSlots) * gameData.config.landCostPerStage; },
        renderAll() { this.updateUI(); this.renderBoard(); this.renderHand(); },
        updateUI() {
            elements.hud.turn.textContent = `${state.turn} / ${state.turnLimit}`;
            elements.hud.debt.textContent = state.debt;
            elements.hud.coins.textContent = state.coins;
            elements.hud.land.textContent = `${state.slots.length} / ${gameData.config.maxSlots}`;
            const landCost = this.getLandCost();
            elements.actions.buyLandBtn.textContent = `í† ì§€ êµ¬ë§¤ (${landCost}ì›)`;
            elements.actions.buyLandBtn.disabled = state.coins < landCost || state.slots.length >= gameData.config.maxSlots;
        },
        renderBoard() {
            elements.board.innerHTML = '';
            state.slots.forEach((slot, index) => {
                const slotEl = document.createElement('div');
                slotEl.className = 'slot relative border-2 border-dashed bg-gray-200/50 rounded-lg p-2 flex flex-col justify-between items-center min-h-[180px] transition-all';
                if (state.selectedCardIndex !== -1) { // *** CHANGED *** - Simplified highlight logic
                    slotEl.classList.add('highlight', 'cursor-pointer');
                }
                slotEl.dataset.slotIndex = index;
                if (slot.cardId) {
                    const cardDef = this.getCardDef(slot.cardId);
                    const stackSize = slot.stack.length;
                    let nextThreshold = Infinity, currentPayout = 0;
                    for (const rule of cardDef.sellTable) {
                        if (stackSize >= rule.need) currentPayout = rule.coins;
                        else { nextThreshold = rule.need; break; }
                    }
                    const progress = nextThreshold === Infinity ? 100 : (stackSize / nextThreshold) * 100;
                    const canClear = state.coins >= 1 && !(state.isTutorial && !state.tutorialGuidedStepsCompleted);
                    slotEl.innerHTML = `<div class="w-full text-center"><h3 class="font-bold text-lg">${cardDef.name}</h3><p class="text-sm ${cardDef.rarity === 'common' || cardDef.rarity === 'uncommon' ? 'text-gray-600' : 'font-semibold text-purple-600'}">${cardDef.rarity}</p></div><div class="text-4xl font-black my-2">${stackSize}</div><div class="w-full text-center space-y-1"><div class="w-full bg-gray-300 rounded-full h-2.5 mb-1"><div class="bg-green-500 h-2.5 rounded-full" style="width: ${progress}%"></div></div><p class="text-xs">ë‹¤ìŒ êµ¬ê°„: ${nextThreshold === Infinity ? 'ìµœëŒ€' : `${nextThreshold}ì¥`} / í˜„ì¬ê°€ì¹˜: ${currentPayout}ì›</p><button class="sell-btn w-full px-3 py-1 bg-yellow-400 text-yellow-900 font-bold rounded shadow hover:bg-yellow-500 disabled:bg-gray-400" ${state.sellCount >= 1 && !(state.isTutorial && !state.tutorialGuidedStepsCompleted) ? 'disabled' : ''}>íŒë§¤</button><button class="clear-btn w-full px-3 py-1 bg-gray-500 text-white font-bold rounded shadow hover:bg-gray-600 disabled:bg-gray-400" ${!canClear ? 'disabled' : ''}>ê°œê°„ (1ì›)</button></div>`;
                    slotEl.classList.remove('bg-gray-200/50', 'border-dashed');
                    slotEl.classList.add('bg-white', 'shadow-md', 'border-solid', 'border-gray-300');
                } else slotEl.innerHTML = `<span class="text-gray-400">ë¹ˆ í† ì§€</span>`;
                elements.board.appendChild(slotEl);
            });
        },
        renderHand() {
            elements.hand.innerHTML = '';
            state.hand.forEach((cardId, index) => {
                const cardDef = this.getCardDef(cardId);
                const cardEl = document.createElement('div');
                cardEl.className = `card w-28 h-40 p-2 rounded-lg shadow-md flex flex-col justify-between cursor-pointer border-4 border-transparent rarity-${cardDef.rarity}`;
                cardEl.dataset.cardIndex = index;
                let discardBtnHtml = '';
                if (index > 0) discardBtnHtml = `<button class="discard-btn" data-card-index="${index}">X</button>`;
                cardEl.innerHTML = `${discardBtnHtml}<div class="text-center"><h4 class="font-bold">${cardDef.name}</h4><p class="text-xs font-semibold">${cardDef.rarity}</p></div><div class="text-center text-xs">${cardDef.sellTable.map(r => `<span>${r.need}â†’${r.coins}</span>`).join(' ')}</div>`;
                if (index === 0) cardEl.classList.add('mandatory-card');
                if (index === state.selectedCardIndex) cardEl.classList.add('ring-4', 'ring-blue-500', 'transform', 'translate-y-[-10px]');
                elements.hand.appendChild(cardEl);
            });
        },
        showModal(htmlContent) { elements.modal.content.innerHTML = htmlContent; elements.modal.container.classList.remove('hidden'); },
        closeModal() { elements.modal.container.classList.add('hidden'); },
        showToast(message, type = 'info') {
            const toast = document.createElement('div');
            const typeClasses = { info: 'bg-blue-500', success: 'bg-green-500', warn: 'bg-yellow-500', error: 'bg-red-500' };
            toast.className = `fixed bottom-5 right-5 text-white px-6 py-3 rounded-lg shadow-lg transform transition-all animate-bounce ${typeClasses[type]}`;
            toast.textContent = message;
            document.body.appendChild(toast);
            setTimeout(() => { toast.remove(); }, 3000);
        },
        async showCoinAnimation(amount, element) {
            const rect = element.getBoundingClientRect();
            const coinAnim = document.createElement('div');
            coinAnim.className = 'animated-coin text-yellow-400 font-bold';
            coinAnim.textContent = `+${amount}ğŸ’°`;
            coinAnim.style.left = `${rect.left + rect.width / 2 - 20}px`;
            coinAnim.style.top = `${rect.top}px`;
            document.body.appendChild(coinAnim);
            setTimeout(() => coinAnim.remove(), 1500);
        },
        sleep(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }
    };

    const Tutorial = {
        setHandForTurn(turn) { state.hand = tutorialData.turnHands[turn] ? [...tutorialData.turnHands[turn]] : []; },
        checkTrigger(triggerType, data = {}) {
            if (!state.isTutorial) return;
            const currentStepData = tutorialData.steps[state.tutorialStep];
            if (!currentStepData) return;
            const waitCondition = currentStepData.waitFor;
            let conditionMet = false;
            if (waitCondition.trigger === triggerType) {
                switch (triggerType) {
                    case 'plant': case 'sell': if (waitCondition.card === data.card) conditionMet = true; break;
                    case 'turn_start': if (waitCondition.turn === data.turn) conditionMet = true; break;
                    case 'buy_land': case 'debt_cleared': conditionMet = true; break;
                }
            }
            if (conditionMet) {
                state.tutorialStep++;
                const nextStepData = tutorialData.steps[state.tutorialStep];
                if (nextStepData) setTimeout(() => this.showGuide(nextStepData.guide), 100);
                else { this.clearGuide(); this.unlockAllActions(); }
            }
        },
        showGuide(guide) {
            this.clearGuide();
            if (!guide) return;
            let guideElementSelector = guide.element;
            if (guide.element.startsWith('SLOT_WITH_CARD')) {
                const cardIdToFind = guide.element.match(/\(([^)]+)\)/)[1];
                const slotIndex = state.slots.findIndex(slot => slot.cardId === cardIdToFind);
                if (slotIndex !== -1) guideElementSelector = `[data-slot-index="${slotIndex}"] .sell-btn`;
                else guideElementSelector = '#board';
            }
            const targetElement = $(guideElementSelector);
            if (!targetElement) {
                const guideEl = document.createElement('div');
                guideEl.className = 'tutorial-overlay fixed top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2';
                guideEl.innerHTML = `<p>${guide.text}</p>`;
                elements.tutorialContainer.appendChild(guideEl);
            } else {
                const rect = targetElement.getBoundingClientRect();
                const guideEl = document.createElement('div');
                guideEl.className = 'tutorial-overlay';
                guideEl.innerHTML = `<p>${guide.text}</p><div class="absolute w-4 h-4 bg-inherit transform rotate-45 -bottom-2 left-1/2 -translate-x-1/2"></div>`;
                elements.tutorialContainer.appendChild(guideEl);
                guideEl.style.left = `${Math.max(10, rect.left + rect.width / 2 - guideEl.offsetWidth / 2)}px`;
                guideEl.style.top = `${rect.top - guideEl.offsetHeight - 10}px`;
                if (rect.top - guideEl.offsetHeight - 10 < 0) {
                    guideEl.style.top = `${rect.bottom + 10}px`;
                    guideEl.querySelector('div').className = 'absolute w-4 h-4 bg-inherit transform rotate-45 -top-2 left-1/2 -translate-x-1/2';
                }
            }
            if (guide.unlock) {
                state.tutorialGuidedStepsCompleted = true;
                this.unlockAllActions();
                setTimeout(() => this.clearGuide(), 4000);
            } else this.lockActions(guideElementSelector);
        },
        clearGuide() { elements.tutorialContainer.innerHTML = ''; },
        lockActions(allowedSelector) {
            this.unlockAllActions();
            $$('#actions button, #hand .card, #board .slot, #board .slot .sell-btn, #board .slot .clear-btn').forEach(el => el.classList.add('tutorial-locked'));
            if (allowedSelector) {
                $$(allowedSelector).forEach(el => {
                    el.classList.remove('tutorial-locked');
                    if (el.classList.contains('sell-btn')) el.closest('.slot')?.classList.remove('tutorial-locked');
                });
            }
        },
        unlockAllActions() { $$('.tutorial-locked').forEach(el => el.classList.remove('tutorial-locked')); }
    };

    window.addEventListener('DOMContentLoaded', () => {
        $$('.start-btn').forEach(btn => btn.addEventListener('click', () => Game.init(btn.dataset.mode)));
        elements.actions.endTurnBtn.addEventListener('click', () => Game.endTurn());
        elements.actions.buyLandBtn.addEventListener('click', () => Game.buyLand());
        elements.actions.shopBtn.addEventListener('click', () => Game.showShop());
        elements.hand.addEventListener('click', (e) => {
            const cardEl = e.target.closest('.card');
            const discardBtn = e.target.closest('.discard-btn');
            if (discardBtn && !discardBtn.classList.contains('tutorial-locked')) {
                Game.discardCard(parseInt(discardBtn.dataset.cardIndex));
            } else if (cardEl && !cardEl.classList.contains('tutorial-locked')) {
                Game.selectCard(parseInt(cardEl.dataset.cardIndex));
            }
        });
        elements.board.addEventListener('click', (e) => {
            const slotEl = e.target.closest('.slot');
            if (slotEl && !slotEl.classList.contains('tutorial-locked')) {
                const slotIndex = parseInt(slotEl.dataset.slotIndex);
                const sellBtn = e.target.closest('.sell-btn');
                const clearBtn = e.target.closest('.clear-btn');
                if (sellBtn && !sellBtn.classList.contains('tutorial-locked')) Game.sellStack(slotIndex);
                else if (clearBtn && !clearBtn.classList.contains('tutorial-locked')) Game.clearSlot(slotIndex);
                else if (state.selectedCardIndex !== -1) Game.plantCard(slotIndex);
            }
        });
        elements.modal.container.addEventListener('click', (e) => { if (e.target === elements.modal.container) Game.closeModal(); });
    });
</script>
</body>
</html>
