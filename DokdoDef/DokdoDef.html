<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>ë…ë„ ì§€í‚´ì´</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #70a1ff;
            --main-green: #2ecc71;
            --main-red: #e74c3c;
            --main-blue: #3498db;
            --text-color: #ffffff;
            --dark-text: #2c3e50;
            --ui-bg: rgba(44, 62, 80, 0.85);
            --level-up-color: #f1c40f;
        }

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: var(--bg-color);
            font-family: 'Noto Sans KR', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #game-container {
            width: 100%;
            height: 100%;
            max-width: 1200px; /* ìµœëŒ€ ë„ˆë¹„ ì œí•œ */
            max-height: 800px; /* ìµœëŒ€ ë†’ì´ ì œí•œ */
            position: relative;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        canvas {
            background-color: #87CEEB;
            display: block;
            border-radius: 15px;
            box-shadow: 0 10px 20px rgba(0,0,0,0.2);
        }

        #ui-container {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 10px;
            box-sizing: border-box;
            background: var(--ui-bg);
            border-bottom-left-radius: 15px;
            border-bottom-right-radius: 15px;
        }

        #top-ui-container {
            position: absolute;
            top: 10px;
            left: 10px;
            display: flex;
            gap: 10px;
            align-items: center;
        }

        #resource-bar, #level-up-bar {
            background-color: var(--ui-bg);
            color: var(--text-color);
            padding: 10px 15px;
            border-radius: 10px;
            font-size: 18px;
            font-weight: bold;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            display: flex;
            align-items: center;
        }

        #level-up-button {
            background-color: var(--level-up-color);
            color: var(--dark-text);
            border: none;
            border-radius: 5px;
            padding: 5px 10px;
            font-weight: bold;
            cursor: pointer;
            margin-left: 10px;
            transition: background-color 0.2s;
        }

        #level-up-button:hover {
            background-color: #f39c12;
        }

        #level-up-button:disabled {
            background-color: #95a5a6;
            cursor: not-allowed;
        }


        .unit-button {
            background-color: var(--main-blue);
            color: white;
            border: 2px solid white;
            border-radius: 10px;
            cursor: pointer;
            margin: 0 5px;
            padding: 10px;
            text-align: center;
            font-size: 14px;
            font-weight: bold;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between;
            width: 80px;
            height: 90px;
            transition: all 0.2s ease;
            position: relative;
            overflow: hidden;
        }

        .unit-button.unsummonable {
            filter: brightness(0.6);
            cursor: not-allowed;
        }

        .unit-button:not(.unsummonable):hover {
            transform: translateY(-3px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }

        .unit-icon {
            font-size: 28px; /* Fallback for emoji */
            width: 40px;
            height: 40px;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            display: block;
        }

        .unit-cost {
            background-color: rgba(0,0,0,0.5);
            padding: 2px 5px;
            border-radius: 5px;
            font-size: 12px;
        }

        .cooldown-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(44, 62, 80, 0.8);
            transform: translateY(100%);
            transition: transform 0.1s linear;
        }

        #game-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            z-index: 10;
        }

        #game-overlay h1 {
            font-size: 48px;
            margin-bottom: 20px;
        }

        #game-overlay p {
            font-size: 20px;
            margin-bottom: 30px;
            max-width: 80%;
        }

        #game-overlay button {
            background-color: var(--main-green);
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 22px;
            font-weight: bold;
            border-radius: 10px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        #game-overlay button:hover {
            background-color: #27ae60;
        }

        /* ë°˜ì‘í˜• ë””ìì¸ */
        @media (max-width: 768px) {
            .unit-button {
                width: 60px;
                height: 75px;
                font-size: 10px;
                margin: 0 3px;
            }
            .unit-icon {
                width: 30px;
                height: 30px;
                font-size: 20px; /* Fallback for emoji */
            }
            #top-ui-container {
                flex-direction: column;
                align-items: flex-start;
            }
            #resource-bar, #level-up-bar {
                font-size: 14px;
                padding: 8px 12px;
            }
            #game-overlay h1 {
                font-size: 32px;
            }
            #game-overlay p {
                font-size: 16px;
            }
            #game-overlay button {
                padding: 12px 24px;
                font-size: 18px;
            }
        }
    </style>
</head>
<body>
<div id="game-container">
    <canvas id="gameCanvas"></canvas>
    <div id="ui-container"></div>
    <div id="top-ui-container">
        <div id="resource-bar">ğŸŒŠ ì¹œí™˜ê²½ ì—ë„ˆì§€: 100</div>
        <div id="level-up-bar">
            <span>ë…ë„ Lv.1</span>
            <button id="level-up-button">ë ˆë²¨ ì—… (ë¹„ìš©: 50)</button>
        </div>
    </div>
    <div id="game-overlay">
        <h1>ë…ë„ ì§€í‚´ì´</h1>
        <p>ìš°ë¦¬ ë•… ë…ë„ë¥¼ ì¹¨ëµí•˜ëŠ” ì ë“¤ì„ ë§‰ì•„ë‚´ì„¸ìš”!<br>ì¹œí™˜ê²½ ì—ë„ˆì§€ë¥¼ ëª¨ì•„ ìš°ë¦¬ ìœ ë‹›ì„ ì†Œí™˜í•˜ì—¬ ì  ê¸°ì§€ë¥¼ íŒŒê´´í•˜ì„¸ìš”.</p>
        <button id="startButton">ê²Œì„ ì‹œì‘</button>
    </div>
</div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const gameContainer = document.getElementById('game-container');
    const uiContainer = document.getElementById('ui-container');
    const topUiContainer = document.getElementById('top-ui-container');
    const resourceBar = document.getElementById('resource-bar');
    const levelUpBar = document.getElementById('level-up-bar');
    const levelUpButton = document.getElementById('level-up-button');
    const gameOverlay = document.getElementById('game-overlay');
    const startButton = document.getElementById('startButton');

    let scale = 1;
    let gameSpeed = 1;
    let resource = 100;
    let resourceGenerationRate = 2;
    let lastTime = 0;
    let gameRunning = false;
    let currentStage = 0;

    let playerBase, enemyBase;
    let dokdoLevel = 1;
    const LEVEL_UP_COSTS = [50, 100, 150]; // ë ˆë²¨ 2, 3, 4ë¡œ ê°€ê¸° ìœ„í•œ ë¹„ìš©
    let currentLevelUpCost;
    const entities = [];
    const projectiles = [];
    const images = {};

    const UNIT_DATA = {
        shrimp: { name: "ìƒˆìš°", icon: "ğŸ¦", iconPath: "https://unluckyidiot16.github.io/assets-common/DokdoDef/shrimp.png", cost: 80, hp: 200, damage: 30, range: 50, speed: 2, cooldown: 2000 },
        squid: { name: "ì˜¤ì§•ì–´", icon: "ğŸ¦‘", iconPath: "https://unluckyidiot16.github.io/assets-common/DokdoDef/squid.png", cost: 100, hp: 300, damage: 40, range: 200, speed: 1, cooldown: 3000 },
        seagull: { name: "ê°ˆë§¤ê¸°", icon: "ğŸ¦", iconPath: "https://unluckyidiot16.github.io/assets-common/DokdoDef/seagull.png", cost: 120, hp: 400, damage: 60, range: 60, speed: 1.5, cooldown: 4000 },
        seal: { name: "ê°•ì¹˜", icon: "ğŸ¦­", iconPath: "https://unluckyidiot16.github.io/assets-common/DokdoDef/seal.png", cost: 250, hp: 1000, damage: 50, range: 60, speed: 0.8, cooldown: 8000 },
        ship: { name: "ë°°", icon: "ğŸ›¶", iconPath: "https://unluckyidiot16.github.io/assets-common/DokdoDef/ship.png", cost: 500, hp: 1500, damage: 150, range: 250, speed: 0.8, cooldown: 20000 }
    };

    const ENEMY_DATA = {
        waste: { name: "í•´ì–‘ ì“°ë ˆê¸°", icon: "ğŸ—‘ï¸", iconPath: "https://unluckyidiot16.github.io/assets-common/DokdoDef/recyclingbag.png", hp: 150, damage: 20, range: 40, speed: 1, resource: 10 },
        oil: { name: "íìœ ", icon: "âš«", iconPath: "https://unluckyidiot16.github.io/assets-common/DokdoDef/plastic.png", hp: 400, damage: 35, range: 70, speed: 0.7, resource: 25 },
        poacher: { name: "ë¶ˆë²• ì–´ì„ ", icon: "ğŸš¤", iconPath: "https://unluckyidiot16.github.io/assets-common/DokdoDef/pollution.png", hp: 1200, damage: 60, range: 100, speed: 0.5, resource: 80 },
        boss: { name: "ì´ˆëŒ€í˜• íê¸°ë¬¼", icon: "ğŸ’¥", iconPath: "https://unluckyidiot16.github.io/assets-common/DokdoDef/pollution.png", hp: 6000, damage: 120, range: 90, speed: 0.4, resource: 400 }
    };

    const loadImage = (key, path, fallbackIcon) => {
        return new Promise((resolve) => {
            const img = new Image();
            img.crossOrigin = "Anonymous";
            img.src = path;
            img.onload = () => { images[key] = img; resolve(); };
            img.onerror = () => {
                console.warn(`ì´ë¯¸ì§€ ë¡œë”© ì‹¤íŒ¨: ${path}. ëŒ€ì²´ ì´ë¯¸ì§€ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.`); // Changed from console.error
                const fallbackImg = new Image();
                fallbackImg.crossOrigin = "Anonymous";
                fallbackImg.src = `https://placehold.co/64x64/cccccc/ffffff?text=${encodeURIComponent(fallbackIcon || 'â“')}`;
                fallbackImg.onload = () => { images[key] = fallbackImg; resolve(); };
                fallbackImg.onerror = () => {
                    console.error(`ëŒ€ì²´ ì´ë¯¸ì§€ ë¡œë”© ì‹¤íŒ¨: ${key}`);
                    images[key] = null;
                    resolve();
                };
            };
        });
    };

    async function preloadImages() {
        const promises = [];
        promises.push(loadImage('playerBase', 'https://unluckyidiot16.github.io/assets-common/DokdoDef/Dokdo.png', 'ğŸï¸'));
        promises.push(loadImage('enemyBase', 'https://placehold.co/128x128/c0392b/ffffff?text=ğŸŒ‹', 'ğŸŒ‹'));
        for (const [key, data] of Object.entries(UNIT_DATA)) { promises.push(loadImage(`unit_${key}`, data.iconPath, data.icon)); }
        for (const [key, data] of Object.entries(ENEMY_DATA)) { promises.push(loadImage(`enemy_${key}`, data.iconPath, data.icon)); }
        await Promise.all(promises);
        console.log("All images preloaded.");
    }


    const STAGES = [
        { name: "1 ìŠ¤í…Œì´ì§€: í•´ì•ˆ ì •í™”", waves: [ { time: 2, type: 'waste' }, { time: 5, type: 'waste' }, { time: 9, type: 'oil' }, { time: 13, type: 'waste' }, { time: 16, type: 'waste' }, { time: 20, type: 'oil' }, { time: 25, type: 'waste' }, { time: 28, type: 'oil' }, { time: 32, type: 'waste' }, { time: 35, type: 'poacher' }, { time: 42, type: 'oil' }, { time: 45, type: 'waste' }, { time: 48, type: 'waste' }, { time: 52, type: 'poacher' } ], totalTime: 58 },
        { name: "2 ìŠ¤í…Œì´ì§€: ì˜¤ì—¼ì› ì¶”ì ", waves: [ { time: 2, type: 'oil' }, { time: 4, type: 'poacher' }, { time: 8, type: 'waste' }, { time: 12, type: 'oil' }, { time: 15, 'type': 'poacher'}, { time: 22, type: 'oil' }, { time: 23, type: 'oil' }, { time: 28, type: 'poacher' }, { time: 33, type: 'waste' }, { time: 35, type: 'waste' }, { time: 40, type: 'poacher' }, { time: 42, type: "oil" }, { time: 48, type: 'waste' }, { time: 50, type: 'waste' }, { time: 54, type: 'poacher' }, { time: 60, type: 'poacher' }, { time: 61, type: 'oil' } ], totalTime: 70 },
        { name: "3 ìŠ¤í…Œì´ì§€: ì‹¬í•´ì˜ ìœ„í˜‘", waves: [ { time: 3, type: 'poacher' }, { time: 5, type: 'oil' }, { time: 8, type: 'waste' }, { time: 12, type: 'poacher' }, { time: 15, type: 'oil' }, { time: 22, type: 'waste' }, { time: 24, type: 'oil' }, { time: 28, type: 'poacher' }, { time: 33, type: 'poacher' }, { time: 38, type: 'oil' }, { time: 45, type: 'oil' }, { time: 48, type: 'poacher' }, { time: 52, type: 'waste' }, { time: 58, type: 'poacher' }, { time: 65, type: 'poacher' }, { time: 75, type: 'boss' } ], totalTime: 90 }
    ];

    let stageTimer = 0;
    let spawnIndex = 0;

    class Projectile {
        constructor(x, y, target, damage, isAlly = true) { this.x = x; this.y = y; this.target = target; this.damage = damage; this.speed = 5 * scale * gameSpeed; this.isAlly = isAlly; this.radius = 6 * scale; this.toRemove = false; }
        update(deltaTime) {
            if (!this.target.isAlive()) { this.toRemove = true; return; }
            const targetX = this.target.x + this.target.width / 2; const targetY = this.target.y + this.target.height / 2; const dx = targetX - this.x; const dy = targetY - this.y; const distance = Math.sqrt(dx * dx + dy * dy);
            if (distance < this.speed) { this.target.takeDamage(this.damage); this.toRemove = true; } else { this.x += (dx / distance) * this.speed; this.y += (dy / distance) * this.speed; }
        }
        draw(ctx) {
            ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.fillStyle = this.isAlly ? '#f1c40f' : '#e74c3c'; ctx.fill(); ctx.strokeStyle = 'rgba(0,0,0,0.5)'; ctx.lineWidth = 2; ctx.stroke();
        }
    }

    class Entity {
        constructor(x, y, width, height, hp, icon, imageKey) {
            this.x = x; this.y = y; this.width = width * scale; this.height = height * scale; this.maxHp = hp; this.hp = hp; this.icon = icon; this.image = images[imageKey]; this.attackTarget = null; this.attackCooldown = 0; this.isAttacking = false; this.attackAnimDuration = 300; this.attackAnimTimer = 0;
        }
        draw(ctx) {
            let drawX = this.x; if (this.isAttacking) { const shakeAmount = 4 * scale; const shakeFrequency = 0.05; drawX += Math.sin(this.attackAnimTimer * shakeFrequency) * shakeAmount; }
            if (this.image) { ctx.drawImage(this.image, drawX, this.y, this.width, this.height); } else { ctx.font = `${this.height * 0.8}px sans-serif`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(this.icon, drawX + this.width / 2, this.y + this.height / 2); }
            const barWidth = this.width; const barHeight = 5 * scale; const yOffset = this.y - barHeight - 2; ctx.fillStyle = '#e74c3c'; ctx.fillRect(drawX, yOffset, barWidth, barHeight); ctx.fillStyle = '#2ecc71'; ctx.fillRect(drawX, yOffset, barWidth * (this.hp / this.maxHp), barHeight);
        }
        update(deltaTime) { if (this.attackCooldown > 0) { this.attackCooldown -= deltaTime; } if (this.isAttacking) { this.attackAnimTimer -= deltaTime; if (this.attackAnimTimer <= 0) { this.isAttacking = false; } } }
        isAlive() { return this.hp > 0; }
        takeDamage(damage) { this.hp -= damage; }
    }

    class Base extends Entity {
        constructor(x, y, width, height, hp, icon, imageKey) { super(x, y, width, height, hp, icon, imageKey); }
        draw(ctx) {
            super.draw(ctx);
            if (this.isAlly) {
                ctx.fillStyle = 'white'; ctx.font = `bold ${18 * scale}px 'Noto Sans KR'`; ctx.textAlign = 'center';
                ctx.fillText(`Lv.${dokdoLevel}`, this.x + this.width / 2, this.y - 20 * scale);
            }
        }
        update(deltaTime) {}
    }


    class Unit extends Entity {
        constructor(x, y, width, height, data) { super(x, y, width, height, data.hp, data.icon, `unit_${Object.keys(UNIT_DATA).find(key => UNIT_DATA[key] === data)}`); this.damage = data.damage; this.range = data.range * scale; this.speed = data.speed * scale * gameSpeed; this.isAlly = true; }
        update(deltaTime, entities) {
            super.update(deltaTime); this.attackTarget = null; let closestEnemy = null; let closestDistance = Infinity;
            for (const entity of entities) { if (!entity.isAlly && entity.isAlive()) { const distance = entity.x - (this.x + this.width); if (distance < closestDistance) { closestDistance = distance; closestEnemy = entity; } } }
            const baseDistance = enemyBase.x - (this.x + this.width); if (baseDistance < closestDistance) { closestDistance = baseDistance; closestEnemy = enemyBase; }
            if (closestEnemy) { if (closestDistance <= this.range) { this.attack(closestEnemy); } else { this.x += this.speed; } } else { if (this.x + this.width < enemyBase.x) { this.x += this.speed; } }
        }
        attack(target) {
            if (this.attackCooldown <= 0) {
                this.isAttacking = true; this.attackAnimTimer = this.attackAnimDuration; const MELEE_RANGE = 80 * scale;
                if (this.range > MELEE_RANGE) { projectiles.push(new Projectile(this.x + this.width / 2, this.y + this.height / 2, target, this.damage, this.isAlly)); } else { target.takeDamage(this.damage); }
                this.attackCooldown = 1000;
            }
        }
    }

    class Enemy extends Entity {
        constructor(x, y, width, height, data) { const key = Object.keys(ENEMY_DATA).find(k => ENEMY_DATA[k] === data); super(x, y, width, height, data.hp, data.icon, `enemy_${key}`); this.damage = data.damage; this.range = data.range * scale; this.speed = data.speed * scale * gameSpeed; this.resource = data.resource; this.isAlly = false; }
        update(deltaTime, entities) {
            super.update(deltaTime); this.attackTarget = null; let closestAlly = null; let closestDistance = Infinity;
            for (const entity of entities) { if (entity.isAlly && entity.isAlive()) { const distance = this.x - (entity.x + entity.width); if (distance < closestDistance) { closestDistance = distance; closestAlly = entity; } } }
            const baseDistance = this.x - (playerBase.x + playerBase.width); if (baseDistance < closestDistance) { closestDistance = baseDistance; closestAlly = playerBase; }
            if (closestAlly) { if (closestDistance <= this.range) { this.attack(closestAlly); } else { this.x -= this.speed; } } else { if (this.x > playerBase.x + playerBase.width) { this.x -= this.speed; } }
        }
        attack(target) {
            if (this.attackCooldown <= 0) {
                this.isAttacking = true; this.attackAnimTimer = this.attackAnimDuration; const MELEE_RANGE = 80 * scale;
                if (this.range > MELEE_RANGE) { projectiles.push(new Projectile(this.x + this.width / 2, this.y + this.height / 2, target, this.damage, this.isAlly)); } else { target.takeDamage(this.damage); }
                this.attackCooldown = 1000;
            }
        }
    }

    function resizeCanvas() {
        const containerRatio = gameContainer.clientWidth / gameContainer.clientHeight; const gameRatio = 16 / 9;
        if (containerRatio > gameRatio) { canvas.height = gameContainer.clientHeight; canvas.width = canvas.height * gameRatio; } else { canvas.width = gameContainer.clientWidth; canvas.height = canvas.width / gameRatio; }
        uiContainer.style.width = `${canvas.width}px`;
        const containerRect = gameContainer.getBoundingClientRect(); const canvasRect = canvas.getBoundingClientRect();
        topUiContainer.style.left = `${canvasRect.left - containerRect.left + 10}px`; topUiContainer.style.top = `${canvasRect.top - containerRect.top + 10}px`;
        scale = canvas.width / 1200; gameSpeed = scale;
    }

    function createUnitButtons() {
        uiContainer.innerHTML = '';
        for (const key in UNIT_DATA) {
            const data = UNIT_DATA[key]; const button = document.createElement('button'); button.className = 'unit-button'; button.dataset.unit = key;
            button.innerHTML = `<div class="unit-icon" style="background-image: url('${data.iconPath}')"></div> <div class="unit-name">${data.name}</div> <div class="unit-cost">ğŸŒŠ ${data.cost}</div> <div class="cooldown-overlay"></div>`;
            button.addEventListener('click', () => spawnUnit(key)); uiContainer.appendChild(button); data.lastSpawnTime = -data.cooldown;
        }
    }

    function spawnUnit(type) {
        const data = UNIT_DATA[type]; const now = Date.now();
        if (resource >= data.cost && now - data.lastSpawnTime >= data.cooldown) {
            resource -= data.cost; data.lastSpawnTime = now; const unitSize = 75; const groundY = canvas.height - 70 * scale;
            const unit = new Unit(playerBase.x + playerBase.width, groundY - (unitSize * scale), unitSize, unitSize, data);
            entities.push(unit); updateUnitButtonsUI();
        }
    }

    function spawnEnemy(type) {
        const data = ENEMY_DATA[type]; let unitSize = 75; if(type === 'boss') { unitSize = 110; }
        const groundY = canvas.height - 70 * scale;
        const enemy = new Enemy(canvas.width - unitSize * scale, groundY - (unitSize * scale), unitSize, unitSize, data);
        entities.push(enemy);
    }

    function updateUnitButtonsUI() {
        const now = Date.now();
        const buttons = document.querySelectorAll('.unit-button');
        buttons.forEach(button => {
            const unitType = button.dataset.unit;
            const data = UNIT_DATA[unitType];
            const timeSinceSpawn = now - data.lastSpawnTime;
            const onCooldown = timeSinceSpawn < data.cooldown;
            const canAfford = resource >= data.cost;

            const overlay = button.querySelector('.cooldown-overlay');
            if (onCooldown) {
                const progress = 1 - (timeSinceSpawn / data.cooldown);
                overlay.style.transform = `translateY(${progress * 100}%)`;
            } else {
                overlay.style.transform = `translateY(100%)`;
            }

            if (canAfford && !onCooldown) {
                button.classList.remove('unsummonable');
            } else {
                button.classList.add('unsummonable');
            }
        });
    }

    function updateLevelUpUI() {
        const levelSpan = levelUpBar.querySelector('span');
        levelSpan.textContent = `ë…ë„ Lv.${dokdoLevel}`;

        if (dokdoLevel - 1 < LEVEL_UP_COSTS.length) {
            currentLevelUpCost = LEVEL_UP_COSTS[dokdoLevel - 1];
            levelUpButton.textContent = `ë ˆë²¨ ì—… (ë¹„ìš©: ${currentLevelUpCost})`;
            levelUpButton.disabled = resource < currentLevelUpCost;
            levelUpButton.style.display = 'inline-block';
        } else {
            levelUpButton.textContent = 'ìµœëŒ€ ë ˆë²¨';
            levelUpButton.disabled = true;
            levelUpButton.style.display = 'none';
        }
    }

    function levelUpDokdo() {
        if (resource >= currentLevelUpCost && dokdoLevel - 1 < LEVEL_UP_COSTS.length) {
            resource -= currentLevelUpCost; dokdoLevel++;
            playerBase.maxHp += 1000; playerBase.hp = playerBase.maxHp; resourceGenerationRate += 0.5;
            updateLevelUpUI();
        }
    }

    function checkGameOver() {
        if (!playerBase.isAlive()) { endGame(false); }
        if (!enemyBase.isAlive()) {
            const stageData = STAGES[currentStage]; const allEnemiesSpawned = stageTimer >= stageData.totalTime; const noEnemiesOnField = !entities.some(e => !e.isAlly);
            if (allEnemiesSpawned && noEnemiesOnField) { endGame(true); }
        }
    }

    function endGame(isWin) {
        gameRunning = false; gameOverlay.style.display = 'flex'; const h1 = gameOverlay.querySelector('h1'); const p = gameOverlay.querySelector('p'); const btn = gameOverlay.querySelector('button');
        if (isWin) {
            if (currentStage < STAGES.length - 1) {
                h1.textContent = "ìŠ¹ë¦¬!"; p.textContent = `${STAGES[currentStage].name} í´ë¦¬ì–´! ë‹¤ìŒ ìŠ¤í…Œì´ì§€ì— ë„ì „í•˜ì„¸ìš”.`; btn.textContent = "ë‹¤ìŒ ìŠ¤í…Œì´ì§€"; currentStage++; btn.onclick = startGame;
            } else {
                h1.textContent = "ìµœì¢… ìŠ¹ë¦¬!"; p.textContent = "ëª¨ë“  ìŠ¤í…Œì´ì§€ë¥¼ í´ë¦¬ì–´í•˜ê³  ë…ë„ë¥¼ ì™„ë²½í•˜ê²Œ ì§€ì¼œëƒˆìŠµë‹ˆë‹¤!"; btn.textContent = "ë‹¤ì‹œ ì‹œì‘"; currentStage = 0; btn.onclick = startGame;
            }
        } else {
            h1.textContent = "íŒ¨ë°°"; p.textContent = "ë…ë„ë¥¼ ì§€í‚¤ì§€ ëª»í–ˆìŠµë‹ˆë‹¤... ë‹¤ì‹œ ë„ì „í•˜ì—¬ ìš°ë¦¬ ë•…ì„ ë˜ì°¾ìœ¼ì„¸ìš”."; btn.textContent = "ë‹¤ì‹œ ë„ì „"; btn.onclick = startGame;
        }
    }

    async function startGame() {
        gameOverlay.style.display = 'none';
        projectiles.length = 0; entities.length = 0; resource = 200; stageTimer = 0; spawnIndex = 0; dokdoLevel = 1;
        resourceGenerationRate = 2;
        playerBase = new Base(0, canvas.height - (120*scale), 80, 120, 5000, 'ğŸï¸', 'playerBase');
        playerBase.isAlly = true;
        enemyBase = new Base(canvas.width - (80*scale), canvas.height - (120*scale), 80, 120, STAGES[currentStage].totalTime * 250, 'ğŸŒ‹', 'enemyBase');
        for(const key in UNIT_DATA){ UNIT_DATA[key].lastSpawnTime = -UNIT_DATA[key].cooldown; }
        updateLevelUpUI(); updateUnitButtonsUI();
        if (!gameRunning) { gameRunning = true; requestAnimationFrame(gameLoop); }
    }


    function update(deltaTime) {
        if (!gameRunning) return;

        resource += resourceGenerationRate * (deltaTime / 1000);
        resourceBar.textContent = `ğŸŒŠ ì¹œí™˜ê²½ ì—ë„ˆì§€: ${Math.floor(resource)}`;

        updateUnitButtonsUI();
        updateLevelUpUI();

        stageTimer += deltaTime / 1000;
        const stageData = STAGES[currentStage];
        if (spawnIndex < stageData.waves.length && stageTimer >= stageData.waves[spawnIndex].time) {
            spawnEnemy(stageData.waves[spawnIndex].type);
            spawnIndex++;
        }

        [...entities, playerBase, enemyBase].forEach(e => e.update(deltaTime, entities));
        projectiles.forEach(p => p.update(deltaTime));

        for (let i = entities.length - 1; i >= 0; i--) {
            if (!entities[i].isAlive()) {
                if (!entities[i].isAlly) { resource += entities[i].resource; }
                entities.splice(i, 1);
            }
        }

        for (let i = projectiles.length - 1; i >= 0; i--) {
            if (projectiles[i].toRemove) {
                projectiles.splice(i, 1);
            }
        }

        checkGameOver();
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        ctx.fillStyle = '#87CEEB'; ctx.fillRect(0, 0, canvas.width, canvas.height * 0.85);
        ctx.fillStyle = '#1E90FF'; ctx.fillRect(0, canvas.height * 0.85, canvas.width, canvas.height * 0.15);

        playerBase.draw(ctx);
        enemyBase.draw(ctx);

        entities.sort((a, b) => a.y - b.y);
        entities.forEach(e => e.draw(ctx));

        projectiles.forEach(p => p.draw(ctx));

        ctx.fillStyle = 'white'; ctx.font = `bold ${20 * scale}px 'Noto Sans KR'`; ctx.textAlign = 'center';
        ctx.fillText(STAGES[currentStage].name, canvas.width / 2, 30 * scale);
    }

    function gameLoop(timestamp) {
        if (!gameRunning) return;
        const deltaTime = timestamp - lastTime; lastTime = timestamp;
        update(deltaTime || 0); draw();
        requestAnimationFrame(gameLoop);
    }

    window.addEventListener('resize', () => {
        resizeCanvas();
        if(playerBase) {
            playerBase.y = canvas.height - (120*scale); enemyBase.y = canvas.height - (120*scale); enemyBase.x = canvas.width - (80*scale);
        }
    });

    levelUpButton.addEventListener('click', levelUpDokdo);
    startButton.addEventListener('click', () => { lastTime = performance.now(); startGame(); });

    preloadImages().then(() => { resizeCanvas(); createUnitButtons(); });
</script>
</body>
</html>


