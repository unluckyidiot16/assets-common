<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>ë…ë„ ë””íœìŠ¤</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #70a1ff;
            --main-green: #2ecc71;
            --main-red: #e74c3c;
            --main-blue: #3498db;
            --text-color: #ffffff;
            --dark-text: #2c3e50;
            --ui-bg: rgba(44, 62, 80, 0.85);
        }

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: var(--bg-color);
            font-family: 'Noto Sans KR', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #game-container {
            width: 100%;
            height: 100%;
            max-width: 1200px; /* ìµœëŒ€ ë„ˆë¹„ ì œí•œ */
            max-height: 800px; /* ìµœëŒ€ ë†’ì´ ì œí•œ */
            position: relative;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        canvas {
            background-color: #87CEEB;
            display: block;
            border-radius: 15px;
            box-shadow: 0 10px 20px rgba(0,0,0,0.2);
        }

        #ui-container {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 10px;
            box-sizing: border-box;
            background: var(--ui-bg);
            border-bottom-left-radius: 15px;
            border-bottom-right-radius: 15px;
        }

        .unit-button {
            background-color: var(--main-blue);
            color: white;
            border: 2px solid white;
            border-radius: 10px;
            cursor: pointer;
            margin: 0 5px;
            padding: 10px;
            text-align: center;
            font-size: 14px;
            font-weight: bold;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between;
            width: 80px;
            height: 90px;
            transition: all 0.2s ease;
            position: relative;
            overflow: hidden;
        }

        .unit-button:hover {
            transform: translateY(-3px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }

        .unit-button.on-cooldown {
            background-color: #7f8c8d;
            cursor: not-allowed;
        }

        .unit-icon {
            font-size: 28px; /* Fallback for emoji */
            width: 40px;
            height: 40px;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            display: block;
        }

        .unit-cost {
            background-color: rgba(0,0,0,0.5);
            padding: 2px 5px;
            border-radius: 5px;
            font-size: 12px;
        }

        .cooldown-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(44, 62, 80, 0.8);
            transform: translateY(100%);
            transition: transform 0.1s linear;
        }

        #resource-bar {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: var(--ui-bg);
            color: var(--text-color);
            padding: 10px 15px;
            border-radius: 10px;
            font-size: 18px;
            font-weight: bold;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        #game-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            z-index: 10;
        }

        #game-overlay h1 {
            font-size: 48px;
            margin-bottom: 20px;
        }

        #game-overlay p {
            font-size: 20px;
            margin-bottom: 30px;
            max-width: 80%;
        }

        #game-overlay button {
            background-color: var(--main-green);
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 22px;
            font-weight: bold;
            border-radius: 10px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        #game-overlay button:hover {
            background-color: #27ae60;
        }

        /* ë°˜ì‘í˜• ë””ìì¸ */
        @media (max-width: 768px) {
            .unit-button {
                width: 60px;
                height: 75px;
                font-size: 10px;
                margin: 0 3px;
            }
            .unit-icon {
                width: 30px;
                height: 30px;
                font-size: 20px; /* Fallback for emoji */
            }
            #resource-bar {
                font-size: 14px;
                padding: 8px 12px;
            }
            #game-overlay h1 {
                font-size: 32px;
            }
            #game-overlay p {
                font-size: 16px;
            }
            #game-overlay button {
                padding: 12px 24px;
                font-size: 18px;
            }
        }
    </style>
</head>
<body>
<div id="game-container">
    <canvas id="gameCanvas"></canvas>
    <div id="ui-container"></div>
    <div id="resource-bar">ğŸŒŠ íƒœê·¹ë ¥: 100</div>
    <div id="game-overlay">
        <h1>ë…ë„ ë””íœìŠ¤</h1>
        <p>ìš°ë¦¬ ë•… ë…ë„ë¥¼ ì¹¨ëµí•˜ëŠ” ì ë“¤ì„ ë§‰ì•„ë‚´ì„¸ìš”!<br>íƒœê·¹ë ¥ì„ ëª¨ì•„ ìš°ë¦¬ ìœ ë‹›ì„ ì†Œí™˜í•˜ì—¬ ì  ê¸°ì§€ë¥¼ íŒŒê´´í•˜ì„¸ìš”.</p>
        <button id="startButton">ê²Œì„ ì‹œì‘</button>
    </div>
</div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const gameContainer = document.getElementById('game-container');
    const uiContainer = document.getElementById('ui-container');
    const resourceBar = document.getElementById('resource-bar');
    const gameOverlay = document.getElementById('game-overlay');
    const startButton = document.getElementById('startButton');

    let scale = 1;
    let gameSpeed = 1;
    let resource = 100;
    let resourceGenerationRate = 2; // ì´ˆë‹¹ ìƒì„±ëŸ‰
    let lastTime = 0;
    let gameRunning = false;
    let currentStage = 0;

    let playerBase, enemyBase;
    const entities = [];

    // ìœ ë‹› ì •ë³´ (ì•„ì´ì½˜ ì´ë¯¸ì§€ë¥¼ ìœ„í•œ path ì¶”ê°€)
    const UNIT_DATA = {
        turtle: { name: "ê±°ë¶ì„ ", icon: "ğŸ¢", iconPath: "https://unluckyidiot16.github.io/assets-common/DokdoDef/turtle.png", cost: 150, hp: 1000, damage: 50, range: 60, speed: 0.5, cooldown: 5000 },
        archer: { name: "í™”ë‘ ê¶ìˆ˜", icon: "ğŸ¹", iconPath: "https://unluckyidiot16.github.io/assets-common/DokdoDef/archer.png", cost: 100, hp: 300, damage: 40, range: 200, speed: 1, cooldown: 3000 },
        haetae: { name: "í•´íƒœ", icon: "ğŸ¦", iconPath: "https://unluckyidiot16.github.io/assets-common/DokdoDef/haetae.png", cost: 250, hp: 700, damage: 80, range: 70, speed: 1.2, cooldown: 8000 },
        bird: { name: "ì €ì–´ìƒˆ", icon: "ğŸ¦¢", iconPath: "https://unluckyidiot16.github.io/assets-common/DokdoDef/bird.png", cost: 80, hp: 200, damage: 30, range: 50, speed: 2, cooldown: 2000 },
        hero: { name: "ì´ìˆœì‹  ì¥êµ°", icon: "ğŸ¤º", iconPath: "https://unluckyidiot16.github.io/assets-common/DokdoDef/hero.png", cost: 500, hp: 1500, damage: 150, range: 250, speed: 0.8, cooldown: 20000 }
    };

    // ì  ì •ë³´ (ì•„ì´ì½˜ ì´ë¯¸ì§€ë¥¼ ìœ„í•œ path ì¶”ê°€ ë° ì´ë¦„ ë³€ê²½)
    const ENEMY_DATA = {
        shrimp: { name: "ìƒˆìš°", icon: "ğŸ¦", iconPath: "https://unluckyidiot16.github.io/assets-common/DokdoDef/shrimp.png", hp: 100, damage: 15, range: 30, speed: 1.5, resource: 5 },
        squid: { name: "ì˜¤ì§•ì–´", icon: "ğŸ¦‘", iconPath: "https://unluckyidiot16.github.io/assets-common/DokdoDef/squid.png", hp: 300, damage: 30, range: 60, speed: 0.8, resource: 20 },
        gull: { name: "ê°ˆë§¤ê¸°", icon: "ğŸ¦", iconPath: "https://unluckyidiot16.github.io/assets-common/DokdoDef/gull.png", hp: 150, damage: 20, range: 40, speed: 1.2, resource: 10 },
        seal: { name: "ê°•ì¹˜", icon: "ğŸ¦­", iconPath: "https://unluckyidiot16.github.io/assets-common/DokdoDef/seal.png", hp: 800, damage: 40, range: 50, speed: 0.6, resource: 50 },
        boat: { name: "ë¶ˆë²• ì–´ì„ ", icon: "ğŸ›¶", iconPath: "https://unluckyidiot16.github.io/assets-common/DokdoDef/boat.png", hp: 5000, damage: 100, range: 80, speed: 0.4, resource: 300 }
    };

    // ì´ë¯¸ì§€ í”„ë¦¬ë¡œë“œ
    const images = {};
    const loadImage = (key, path) => {
        return new Promise((resolve) => {
            const img = new Image();
            img.src = path;
            img.onload = () => {
                images[key] = img;
                resolve();
            };
            img.onerror = () => {
                console.error(`Failed to load image: ${path}`);
                images[key] = null; // ì‹¤íŒ¨ ì‹œ null ë˜ëŠ” ëŒ€ì²´ ì´ë¯¸ì§€ë¡œ ì²˜ë¦¬
                resolve();
            };
        });
    };

    async function preloadImages() {
        const imagePaths = {
            playerBase: "https://unluckyidiot16.github.io/assets-common/DokdoDef/Dokdo.png",
            enemyBase: "https://unluckyidiot16.github.io/assets-common/DokdoDef/Dokdo_enemy.png", // ì  ê¸°ì§€ ì´ë¯¸ì§€ (ì˜ˆì‹œë¡œ ë…ë„ ì´ë¯¸ì§€ ì‚¬ìš©)
            ...Object.fromEntries(Object.entries(UNIT_DATA).map(([key, data]) => [`unit_${key}`, data.iconPath])),
            ...Object.fromEntries(Object.entries(ENEMY_DATA).map(([key, data]) => [`enemy_${key}`, data.iconPath]))
        };

        const promises = Object.entries(imagePaths).map(([key, path]) => loadImage(key, path));
        await Promise.all(promises);
        console.log("All images preloaded.");
    }


    // ìŠ¤í…Œì´ì§€ êµ¬ì„±
    const STAGES = [
        {
            name: "1 ìŠ¤í…Œì´ì§€: ë™ë„ ìˆ˜í˜¸",
            waves: [
                { time: 2, type: 'shrimp' }, { time: 4, type: 'gull' }, { time: 8, type: 'shrimp' }, { time: 10, type: 'gull' }, { time: 12, type: 'seal' },
                { time: 18, type: 'shrimp' }, { time: 20, type: 'gull' }, { time: 25, type: 'shrimp' }, { time: 28, type: 'seal' }, { time: 30, type: 'squid' },
                { time: 40, type: 'gull' }, { time: 41, type: 'shrimp' }, { time: 42, type: 'gull' }, { time: 43, type: 'shrimp' }, { time: 50, type: 'seal' }
            ],
            totalTime: 55
        },
        {
            name: "2 ìŠ¤í…Œì´ì§€: ì„œë„ ë°©ì–´",
            waves: [
                { time: 2, type: 'gull' }, { time: 3, type: 'squid' }, { time: 7, type: 'shrimp' }, { time: 9, type: 'seal' }, { time: 13, type: 'squid' },
                { time: 20, type: 'seal' }, { time: 21, type: 'seal' }, { time: 25, type: 'squid' }, { time: 28, type: 'gull' }, { time: 30, type: 'shrimp' },
                { time: 35, type: 'seal' }, { time: 36, type: "squid" }, { time: 45, type: 'gull' }, { time: 46, type: 'shrimp' }, { time: 47, type: 'squid' },
                { time: 55, type: 'seal' }, { time: 56, type: 'seal' }
            ],
            totalTime: 65
        },
        {
            name: "3 ìŠ¤í…Œì´ì§€: ì‹¬í•´ì˜ ìœ„í˜‘",
            waves: [
                { time: 3, type: 'seal' }, { time: 4, type: 'squid' }, { time: 5, type: 'gull' }, { time: 10, type: 'seal' }, { time: 12, type: 'squid' },
                { time: 20, type: 'shrimp' }, { time: 21, type: 'gull' }, { time: 22, type: 'squid' }, { time: 28, type: 'seal' }, { time: 30, type: 'seal' },
                { time: 38, type: 'squid' }, { time: 39, type: 'squid' }, { time: 40, type: 'gull' }, { time: 48, type: 'seal' }, { time: 50, type: 'seal' },
                { time: 60, type: 'boat' }
            ],
            totalTime: 90
        }
    ];

    let stageTimer = 0;
    let spawnIndex = 0;

    // --- ê²Œì„ í´ë˜ìŠ¤ ì •ì˜ ---
    class Entity {
        constructor(x, y, width, height, hp, icon, imageKey) {
            this.x = x;
            this.y = y;
            this.width = width * scale;
            this.height = height * scale;
            this.maxHp = hp;
            this.hp = hp;
            this.icon = icon; // Fallback for emoji
            this.image = images[imageKey]; // ì‹¤ì œ ì´ë¯¸ì§€ ê°ì²´
            this.attackTarget = null;
            this.attackCooldown = 0;
        }

        draw(ctx) {
            if (this.image) {
                ctx.drawImage(this.image, this.x, this.y, this.width, this.height);
            } else {
                // ì´ë¯¸ì§€ ë¡œë“œ ì‹¤íŒ¨ ì‹œ ì´ëª¨ì§€ Fallback
                ctx.font = `${this.height * 0.8}px sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.icon, this.x + this.width / 2, this.y + this.height / 2);
            }

            // ì²´ë ¥ ë°”
            const barWidth = this.width;
            const barHeight = 5 * scale;
            const yOffset = this.y - barHeight - 2;
            ctx.fillStyle = '#e74c3c'; // red
            ctx.fillRect(this.x, yOffset, barWidth, barHeight);
            ctx.fillStyle = '#2ecc71'; // green
            ctx.fillRect(this.x, yOffset, barWidth * (this.hp / this.maxHp), barHeight);
        }

        update(deltaTime) {
            if (this.attackCooldown > 0) {
                this.attackCooldown -= deltaTime;
            }
        }

        isAlive() {
            return this.hp > 0;
        }

        takeDamage(damage) {
            this.hp -= damage;
        }
    }

    class Base extends Entity {
        constructor(x, y, width, height, hp, icon, imageKey) {
            super(x, y, width, height, hp, icon, imageKey);
        }

        // ê¸°ì§€ëŠ” ì›€ì§ì´ê±°ë‚˜ ê³µê²©í•˜ì§€ ì•Šìœ¼ë¯€ë¡œ updateëŠ” ë¹„ì›Œë‘ 
        update(deltaTime) {}
    }


    class Unit extends Entity {
        constructor(x, y, width, height, data) {
            super(x, y, width, height, data.hp, data.icon, `unit_${Object.keys(UNIT_DATA).find(key => UNIT_DATA[key] === data)}`);
            this.damage = data.damage;
            this.range = data.range * scale;
            this.speed = data.speed * scale * gameSpeed;
            this.isAlly = true;
        }

        update(deltaTime, entities) {
            super.update(deltaTime);
            this.attackTarget = null;
            let closestEnemy = null;
            let closestDistance = Infinity;

            for (const entity of entities) {
                if (!entity.isAlly && entity.isAlive()) {
                    const distance = entity.x - (this.x + this.width);
                    if (distance < closestDistance) {
                        closestDistance = distance;
                        closestEnemy = entity;
                    }
                }
            }

            // ê¸°ì§€ë„ ê³µê²© ëŒ€ìƒì— í¬í•¨
            const baseDistance = enemyBase.x - (this.x + this.width);
            if (baseDistance < closestDistance) {
                closestDistance = baseDistance;
                closestEnemy = enemyBase;
            }

            if (closestEnemy) {
                if (closestDistance <= this.range) {
                    this.attack(closestEnemy);
                } else {
                    this.x += this.speed;
                }
            } else {
                // ì ì´ ì—†ìœ¼ë©´ ì  ê¸°ì§€ë¡œ ì „ì§„
                if (this.x + this.width < enemyBase.x) {
                    this.x += this.speed;
                }
            }
        }

        attack(target) {
            if (this.attackCooldown <= 0) {
                target.takeDamage(this.damage);
                this.attackCooldown = 1000; // 1ì´ˆ ê³µê²© ì¿¨ë‹¤ìš´
            }
        }
    }

    class Enemy extends Entity {
        constructor(x, y, width, height, data) {
            super(x, y, width, height, data.hp, data.icon, `enemy_${Object.keys(ENEMY_DATA).find(key => ENEMY_DATA[key] === data)}`);
            this.damage = data.damage;
            this.range = data.range * scale;
            this.speed = data.speed * scale * gameSpeed;
            this.resource = data.resource;
            this.isAlly = false;
        }

        update(deltaTime, entities) {
            super.update(deltaTime);
            this.attackTarget = null;
            let closestAlly = null;
            let closestDistance = Infinity;

            // ì•„êµ° ìœ ë‹› ì°¾ê¸°
            for (const entity of entities) {
                if (entity.isAlly && entity.isAlive()) {
                    const distance = this.x - (entity.x + entity.width);
                    if (distance < closestDistance) {
                        closestDistance = distance;
                        closestAlly = entity;
                    }
                }
            }

            // ì•„êµ° ê¸°ì§€ë„ ê³µê²© ëŒ€ìƒì— í¬í•¨
            const baseDistance = this.x - (playerBase.x + playerBase.width);
            if (baseDistance < closestDistance) {
                closestDistance = baseDistance;
                closestAlly = playerBase;
            }


            if (closestAlly) {
                if (closestDistance <= this.range) {
                    this.attack(closestAlly);
                } else {
                    this.x -= this.speed;
                }
            } else {
                // ì•„êµ°ì´ ì—†ìœ¼ë©´ ì•„êµ° ê¸°ì§€ë¡œ ì „ì§„
                if (this.x > playerBase.x + playerBase.width) {
                    this.x -= this.speed;
                }
            }
        }
        attack(target) {
            if (this.attackCooldown <= 0) {
                target.takeDamage(this.damage);
                this.attackCooldown = 1000;
            }
        }
    }

    // --- ê²Œì„ í•¨ìˆ˜ ---

    function resizeCanvas() {
        const containerRatio = gameContainer.clientWidth / gameContainer.clientHeight;
        const gameRatio = 16 / 9;

        if (containerRatio > gameRatio) {
            canvas.height = gameContainer.clientHeight;
            canvas.width = canvas.height * gameRatio;
        } else {
            canvas.width = gameContainer.clientWidth;
            canvas.height = canvas.width / gameRatio;
        }

        // UI ì»¨í…Œì´ë„ˆ ë„ˆë¹„ ë§ì¶”ê¸°
        uiContainer.style.width = `${canvas.width}px`;
        uiContainer.style.borderBottomLeftRadius = '15px';
        uiContainer.style.borderBottomRightRadius = '15px';

        // ë¦¬ì†ŒìŠ¤ ë°” ìœ„ì¹˜ ì¡°ì •
        const containerRect = gameContainer.getBoundingClientRect();
        const canvasRect = canvas.getBoundingClientRect();
        resourceBar.style.left = `${canvasRect.left - containerRect.left + 10}px`;
        resourceBar.style.top = `${canvasRect.top - containerRect.top + 10}px`;

        scale = canvas.width / 1200; // ê¸°ì¤€ í•´ìƒë„ ë„ˆë¹„ 1200px
        gameSpeed = scale;
    }

    function createUnitButtons() {
        uiContainer.innerHTML = '';
        for (const key in UNIT_DATA) {
            const data = UNIT_DATA[key];
            const button = document.createElement('button');
            button.className = 'unit-button';
            button.dataset.unit = key;
            button.innerHTML = `
                    <div class="unit-icon" style="background-image: url('${data.iconPath}')"></div>
                    <div class="unit-name">${data.name}</div>
                    <div class="unit-cost">ğŸŒŠ ${data.cost}</div>
                    <div class="cooldown-overlay"></div>
                `;
            button.addEventListener('click', () => spawnUnit(key));
            uiContainer.appendChild(button);
            data.lastSpawnTime = -data.cooldown; // ê²Œì„ ì‹œì‘ ì‹œ ë°”ë¡œ ì†Œí™˜ ê°€ëŠ¥í•˜ë„ë¡
        }
    }

    function spawnUnit(type) {
        const data = UNIT_DATA[type];
        const now = Date.now();
        if (resource >= data.cost && now - data.lastSpawnTime >= data.cooldown) {
            resource -= data.cost;
            data.lastSpawnTime = now;
            const unit = new Unit(playerBase.x + playerBase.width, canvas.height - (70 * scale) - (40*scale), 50, 40, data);
            entities.push(unit);
            updateCooldownVisuals();
        }
    }

    function spawnEnemy(type) {
        const data = ENEMY_DATA[type];
        const enemy = new Enemy(canvas.width - 50 * scale, canvas.height - (70 * scale) - (40 * scale), 50, 40, data);
        entities.push(enemy);
    }

    function updateCooldownVisuals() {
        const now = Date.now();
        const buttons = document.querySelectorAll('.unit-button');
        buttons.forEach(button => {
            const unitType = button.dataset.unit;
            const data = UNIT_DATA[unitType];
            const timeSinceSpawn = now - data.lastSpawnTime;
            const cooldown = data.cooldown;

            if (timeSinceSpawn < cooldown) {
                button.classList.add('on-cooldown');
                const overlay = button.querySelector('.cooldown-overlay');
                const progress = 1 - (timeSinceSpawn / cooldown);
                overlay.style.transform = `translateY(${progress * 100}%)`;
            } else {
                button.classList.remove('on-cooldown');
                const overlay = button.querySelector('.cooldown-overlay');
                overlay.style.transform = `translateY(100%)`;
            }
        });
    }

    function checkGameOver() {
        if (!playerBase.isAlive()) {
            endGame(false);
        }
        if (!enemyBase.isAlive()) {
            // í˜„ì¬ ìŠ¤í…Œì´ì§€ì˜ ëª¨ë“  ì ì´ ì†Œí™˜ë˜ê³ , í•„ë“œì— ì ì´ ì—†ìœ¼ë©´ ìŠ¹ë¦¬
            const stageData = STAGES[currentStage];
            const allEnemiesSpawned = stageTimer >= stageData.totalTime;
            const noEnemiesOnField = !entities.some(e => !e.isAlly);

            if (allEnemiesSpawned && noEnemiesOnField) {
                endGame(true);
            }
        }
    }

    function endGame(isWin) {
        gameRunning = false;
        gameOverlay.style.display = 'flex';
        const h1 = gameOverlay.querySelector('h1');
        const p = gameOverlay.querySelector('p');
        const btn = gameOverlay.querySelector('button');

        if (isWin) {
            if (currentStage < STAGES.length - 1) {
                h1.textContent = "ìŠ¹ë¦¬!";
                p.textContent = `${STAGES[currentStage].name} í´ë¦¬ì–´! ë‹¤ìŒ ìŠ¤í…Œì´ì§€ì— ë„ì „í•˜ì„¸ìš”.`;
                btn.textContent = "ë‹¤ìŒ ìŠ¤í…Œì´ì§€";
                currentStage++;
                btn.onclick = startGame;
            } else {
                h1.textContent = "ìµœì¢… ìŠ¹ë¦¬!";
                p.textContent = "ëª¨ë“  ìŠ¤í…Œì´ì§€ë¥¼ í´ë¦¬ì–´í•˜ê³  ë…ë„ë¥¼ ì™„ë²½í•˜ê²Œ ì§€ì¼œëƒˆìŠµë‹ˆë‹¤!";
                btn.textContent = "ë‹¤ì‹œ ì‹œì‘";
                currentStage = 0;
                btn.onclick = startGame;
            }
        } else {
            h1.textContent = "íŒ¨ë°°";
            p.textContent = "ë…ë„ë¥¼ ì§€í‚¤ì§€ ëª»í–ˆìŠµë‹ˆë‹¤... ë‹¤ì‹œ ë„ì „í•˜ì—¬ ìš°ë¦¬ ë•…ì„ ë˜ì°¾ìœ¼ì„¸ìš”.";
            btn.textContent = "ë‹¤ì‹œ ë„ì „";
            btn.onclick = startGame;
        }
    }

    async function startGame() {
        gameOverlay.style.display = 'none';

        // ê²Œì„ ìƒíƒœ ì´ˆê¸°í™”
        entities.length = 0;
        resource = 200;
        stageTimer = 0;
        spawnIndex = 0;

        playerBase = new Base(0, canvas.height - (120*scale), 80, 120, 5000, 'ğŸï¸', 'playerBase');
        enemyBase = new Base(canvas.width - (80*scale), canvas.height - (120*scale), 80, 120, STAGES[currentStage].totalTime * 200, 'ğŸŒ‹', 'enemyBase');

        // ìœ ë‹› ì¿¨ë‹¤ìš´ ì´ˆê¸°í™”
        for(const key in UNIT_DATA){
            UNIT_DATA[key].lastSpawnTime = -UNIT_DATA[key].cooldown;
        }

        if (!gameRunning) {
            gameRunning = true;
            requestAnimationFrame(gameLoop);
        }
    }


    function update(deltaTime) {
        if (!gameRunning) return;

        // ìì› ìƒì„±
        resource += resourceGenerationRate * (deltaTime / 1000);
        resourceBar.textContent = `ğŸŒŠ íƒœê·¹ë ¥: ${Math.floor(resource)}`;

        // ìŠ¤í…Œì´ì§€ ì§„í–‰ ë° ì  ìƒì„±
        stageTimer += deltaTime / 1000;
        const stageData = STAGES[currentStage];
        if (spawnIndex < stageData.waves.length && stageTimer >= stageData.waves[spawnIndex].time) {
            spawnEnemy(stageData.waves[spawnIndex].type);
            spawnIndex++;
        }

        // ëª¨ë“  ì—”í‹°í‹° ì—…ë°ì´íŠ¸
        [...entities, playerBase, enemyBase].forEach(e => e.update(deltaTime, entities));

        // ì£½ì€ ì—”í‹°í‹° ì œê±°
        for (let i = entities.length - 1; i >= 0; i--) {
            if (!entities[i].isAlive()) {
                if (!entities[i].isAlly) {
                    resource += entities[i].resource; // ì  ì²˜ì¹˜ ì‹œ ìì› íšë“
                }
                entities.splice(i, 1);
            }
        }

        updateCooldownVisuals();
        checkGameOver();
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // ë°°ê²½ ê·¸ë¦¬ê¸°
        ctx.fillStyle = '#87CEEB'; // í•˜ëŠ˜
        ctx.fillRect(0, 0, canvas.width, canvas.height * 0.85);
        ctx.fillStyle = '#1E90FF'; // ë°”ë‹¤
        ctx.fillRect(0, canvas.height * 0.85, canvas.width, canvas.height * 0.15);

        // ê¸°ì§€ ê·¸ë¦¬ê¸°
        playerBase.draw(ctx);
        enemyBase.draw(ctx);

        // ì—”í‹°í‹° ê·¸ë¦¬ê¸° (yì¢Œí‘œ ìˆœìœ¼ë¡œ ì •ë ¬í•˜ì—¬ ê²¹ì¹˜ì§€ ì•Šê²Œ)
        entities.sort((a, b) => a.y - b.y);
        entities.forEach(e => e.draw(ctx));

        // ìŠ¤í…Œì´ì§€ ì •ë³´
        ctx.fillStyle = 'white';
        ctx.font = `bold ${20 * scale}px 'Noto Sans KR'`;
        ctx.textAlign = 'center';
        ctx.fillText(STAGES[currentStage].name, canvas.width / 2, 30 * scale);
    }

    function gameLoop(timestamp) {
        if (!gameRunning) return;

        const deltaTime = timestamp - lastTime;
        lastTime = timestamp;

        update(deltaTime || 0);
        draw();

        requestAnimationFrame(gameLoop);
    }

    // ì´ˆê¸°í™”
    window.addEventListener('resize', () => {
        resizeCanvas();
        // ê²Œì„ ìƒíƒœì— ë”°ë¼ ê°ì²´ë“¤ì˜ í¬ê¸°ì™€ ìœ„ì¹˜ë„ ì¬ì¡°ì •í•´ì•¼ í•¨
        // ê°„ë‹¨í•˜ê²Œ ì¬ì‹œì‘í•˜ë„ë¡ ì²˜ë¦¬í•˜ê±°ë‚˜, ëª¨ë“  ê°ì²´ì˜ scaleì„ ë‹¤ì‹œ ì ìš©
        if(playerBase) {
            // ê²Œì„ì´ ì‹¤í–‰ì¤‘ì´ì—ˆë‹¤ë©´ ë¦¬ì‚¬ì´ì¦ˆì— ë§ì¶°ì„œ ìœ„ì¹˜/í¬ê¸° ì¬ì¡°ì •
            playerBase.y = canvas.height - (120*scale);
            enemyBase.y = canvas.height - (120*scale);
            enemyBase.x = canvas.width - (80*scale);
            // ëª¨ë“  ì—”í‹°í‹°ë“¤ì˜ width, height, x, yë„ scaleì— ë§ì¶°ì„œ ì¬ì¡°ì • í•„ìš”
            // ì´ ì˜ˆì œì—ì„œëŠ” ë‹¨ìˆœí™”ë¥¼ ìœ„í•´ ê²Œì„ ì¬ì‹œì‘ ì‹œì ì—ë§Œ ì •í™•íˆ ì„¸íŒ…ë˜ë„ë¡ í•¨
            // ì‹¤ì œ ê²Œì„ì—ì„œëŠ” ì—”í‹°í‹° ìƒì„± ì‹œì ì— scale ì ìš©í•˜ê±°ë‚˜ ë¦¬ì‚¬ì´ì¦ˆ ì‹œ ëª¨ë‘ ì—…ë°ì´íŠ¸
        }
    });

    startButton.addEventListener('click', () => {
        lastTime = performance.now();
        startGame();
    });

    // ì´ë¯¸ì§€ í”„ë¦¬ë¡œë“œ í›„ ê²Œì„ ì´ˆê¸°í™”
    preloadImages().then(() => {
        resizeCanvas();
        createUnitButtons();
    });
</script>
</body>
</html>
